<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BudgetKit - Core Transaction Register</title>
  <style>
    :root {
      --bg: #0a0f16;
      --panel: #111a26;
      --panel2: #172335;
      --text: #e7edf6;
      --muted: #a8b7ca;
      --line: #2a3a52;
      --accent: #6ec1ff;
      --ok: #3ed598;
      --warn: #ffd479;
      --bad: #ff7f7f;
      --radius: 12px;
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--sans);
      color: var(--text);
      background: radial-gradient(circle at top right, #17263b 0%, #0a0f16 45%, #070b10 100%);
      min-height: 100vh;
    }
    .wrap { max-width: 1260px; margin: 0 auto; padding: 16px; }
    .topbar, .panel {
      border: 1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(17, 26, 38, 0.92);
      box-shadow: var(--shadow);
    }
    .topbar {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 12px;
      flex-wrap: wrap;
      padding: 12px;
    }
    h1 { margin: 0; font-size: 18px; }
    .sub { margin-top: 4px; color: var(--muted); font-size: 12px; }
    .auth {
      display: flex;
      gap: 8px;
      align-items: flex-end;
      flex-wrap: wrap;
    }
    .field { display: flex; flex-direction: column; gap: 5px; }
    label { color: var(--muted); font-size: 12px; }
    input[type="text"], input[type="password"], input[type="date"], select, textarea {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(23, 35, 53, 0.95);
      color: var(--text);
      padding: 8px 10px;
      outline: none;
    }
    input:focus, select:focus, textarea:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(110, 193, 255, 0.15); }
    textarea { min-height: 68px; resize: vertical; }
    .btn {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 12px;
      background: rgba(23, 35, 53, 0.95);
      color: var(--text);
      cursor: pointer;
      font-weight: 600;
    }
    .btn:hover { border-color: var(--accent); }
    .btn.primary { border-color: rgba(110, 193, 255, 0.55); background: rgba(110, 193, 255, 0.18); }
    .btn.danger { border-color: rgba(255, 127, 127, 0.55); background: rgba(255, 127, 127, 0.16); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .logout {
      display: none;
      color: var(--muted);
      text-decoration: none;
      font-size: 12px;
      margin-left: 8px;
    }
    .status {
      margin-top: 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 9px 10px;
      font-size: 13px;
      background: rgba(14, 22, 33, 0.75);
      color: var(--muted);
    }
    .status.ok { border-color: rgba(62, 213, 152, 0.45); color: #bdf7df; }
    .status.warn { border-color: rgba(255, 212, 121, 0.45); color: #ffeabc; }
    .status.bad { border-color: rgba(255, 127, 127, 0.45); color: #ffd1d1; }
    #app { display: none; margin-top: 12px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    .panel { padding: 12px; }
    .panel h2 { margin: 0 0 10px; font-size: 14px; }
    .line { display: flex; gap: 8px; flex-wrap: wrap; align-items: flex-end; }
    .line .field { min-width: 110px; }
    .mono { font-family: var(--mono); font-size: 12px; color: var(--muted); }
    .toolbar {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 10px;
    }
    table { width: 100%; border-collapse: collapse; table-layout: fixed; }
    th, td {
      border-bottom: 1px solid rgba(42, 58, 82, 0.75);
      padding: 9px 8px;
      font-size: 12px;
      text-align: left;
      vertical-align: top;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    th { color: var(--muted); font-size: 11px; text-transform: uppercase; letter-spacing: 0.2px; }
    tr.selected { background: rgba(110, 193, 255, 0.08); }
    tr.txn-parent td {
      background: rgba(110, 193, 255, 0.06);
      border-bottom: 0;
      font-weight: 600;
    }
    tr.txn-sub td {
      background: rgba(110, 193, 255, 0.03);
      border-bottom: 0;
    }
    tr.txn-sub td:nth-child(3),
    tr.txn-sub td:nth-child(4) { padding-left: 20px; }
    tr.txn-sub-end td { border-bottom: 1px solid rgba(42, 58, 82, 0.75); }
    tr.txn-edit td {
      background: rgba(255, 212, 121, 0.08);
      border-bottom: 0;
      vertical-align: middle;
    }
    tr.txn-edit-end td { border-bottom: 1px solid rgba(42, 58, 82, 0.75); }
    .inlineInput, .inlineSelect {
      width: 100%;
      min-width: 0;
      height: 30px;
      border: 1px solid var(--line);
      border-radius: 8px;
      background: rgba(23, 35, 53, 0.95);
      color: var(--text);
      padding: 5px 8px;
      margin: 0;
      font-size: 12px;
      line-height: 1.2;
      box-sizing: border-box;
      display: block;
    }
    .inlineSelect {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }
    .pill {
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 2px 7px;
      font-size: 11px;
      display: inline-flex;
      align-items: center;
    }
    .help { color: var(--muted); font-size: 12px; line-height: 1.35; }
    @media (max-width: 1080px) {
      .grid { grid-template-columns: 1fr; }
    }
    @media (max-width: 760px) {
      .auth input[type="text"], .auth input[type="password"] { width: 100%; }
      .auth .field { min-width: 100%; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1>Core Transaction Register <a class="logout" id="logoutLink" href="#">logout</a></h1>
        <div class="sub">Transactions (`txns`) and entries (`entries`) with multi-entry support.</div>
      </div>
      <div class="auth" id="authPanel">
        <div class="field">
          <label for="pbUrl">URL</label>
          <input id="pbUrl" type="text" placeholder="http://127.0.0.1:8090" />
        </div>
        <div class="field">
          <label for="pbEmail">Email</label>
          <input id="pbEmail" type="text" placeholder="you@example.com" />
        </div>
        <div class="field">
          <label for="pbPass">Password</label>
          <input id="pbPass" type="password" placeholder="password" />
        </div>
        <button class="btn primary" id="btnLogin">Login</button>
      </div>
    </div>

    <div class="status" id="statusBox">Not authenticated.</div>

    <div id="app">
      <div class="grid">
        <section class="panel">
          <div class="toolbar">
            <h2 style="margin:0;">Register</h2>
            <div class="line">
              <button class="btn primary" id="btnNewTxn" type="button">New Transaction</button>
              <button class="btn primary" id="btnEditSave" type="button" style="display:none;">Save Edit</button>
              <button class="btn" id="btnEditCancel" type="button" style="display:none;">Cancel</button>
              <button class="btn" id="btnRefresh">Refresh</button>
              <button class="btn danger" id="btnDeleteTxn" disabled>Delete selected txn</button>
            </div>
          </div>

          <div class="line" style="margin-bottom:8px;">
            <div class="field">
              <label for="fltFrom">From</label>
              <input id="fltFrom" type="date" />
            </div>
            <div class="field">
              <label for="fltTo">To</label>
              <input id="fltTo" type="date" />
            </div>
            <div class="field">
              <label for="fltAccount">Account</label>
              <select id="fltAccount"></select>
            </div>
            <div class="field">
              <label for="fltCategory">Category</label>
              <select id="fltCategory"></select>
            </div>
            <div class="field">
              <label for="fltStatus">Status</label>
              <select id="fltStatus">
                <option value="">(any)</option>
                <option value="pending">pending</option>
                <option value="cleared">cleared</option>
              </select>
            </div>
            <div class="field">
              <label for="fltBudgetOnly">Budget kinds</label>
              <select id="fltBudgetOnly">
                <option value="0">All entries</option>
                <option value="1">Income/Expense only</option>
              </select>
            </div>
          </div>

          <div style="overflow:auto;">
            <table>
              <colgroup>
                <col style="width:11%;" />
                <col style="width:18%;" />
                <col style="width:14%;" />
                <col style="width:16%;" />
                <col style="width:17%;" />
                <col style="width:13%;" />
                <col style="width:9%;" />
              </colgroup>
              <thead>
                <tr>
                  <th>Date</th>
                  <th>Account</th>
                  <th>Payee</th>
                  <th>Category</th>
                  <th>Memo</th>
                  <th>Amount</th>
                  <th>Status</th>
                </tr>
              </thead>
              <tbody id="registerBody"></tbody>
            </table>
          </div>
          <div class="help" id="resultCount" style="margin-top:10px;"></div>
        </section>
      </div>
    </div>
  </div>

  <script>
    (function() {
      const $ = (s, el) => (el || document).querySelector(s);
      const $$ = (s, el) => Array.from((el || document).querySelectorAll(s));

      const store = {
        get(k, d) { try { const v = localStorage.getItem(k); return v == null ? d : v; } catch { return d; } },
        set(k, v) { try { localStorage.setItem(k, v); } catch {} },
        del(k) { try { localStorage.removeItem(k); } catch {} }
      };

      const SESSION = { base: "", token: "" };
      const state = {
        loading: false,
        saving: false,
        deleting: false,
        accounts: [],
        accountById: new Map(),
        assets: [],
        categories: [],
        categoryById: new Map(),
        txns: new Map(),
        entries: [],
        selectedTxnIds: [],
        selectionAnchorTxnId: "",
        visibleTxnOrder: [],
        editingTxnId: "",
        editDraft: null,
        pendingFocusKey: ""
      };

      function escapeHtml(v) {
        return String(v == null ? "" : v)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      function normalizeDateToNoonUtc(dateStr) {
        return dateStr + "T12:00:00Z";
      }

      function fmtDate(dateValue) {
        if (!dateValue) return "";
        const d = new Date(dateValue);
        if (isNaN(d.getTime())) return String(dateValue);
        return d.toISOString().slice(0, 10);
      }

      function setStatus(kind, message) {
        const box = $("#statusBox");
        box.className = "status" + (kind ? " " + kind : "");
        box.textContent = message;
      }

      function classifyError(err) {
        if (!err || typeof err !== "object") return { kind: "bad", message: String(err || "Unknown error") };
        if (err.kind === "network") return { kind: "bad", message: "Network error: check URL, protocol (http/https), host, and CORS." };
        if (err.kind === "auth") return { kind: "bad", message: "Auth failure: session expired or credentials/token were rejected." };
        if (err.kind === "query") return { kind: "warn", message: "Query/schema mismatch (HTTP 400): fallback query was used." };
        return { kind: "bad", message: err.message || "Request failed." };
      }

      async function pbFetch(path, options) {
        if (!SESSION.base) {
          const e = new Error("PocketBase URL is required.");
          e.kind = "auth";
          throw e;
        }

        const headers = Object.assign({ "Content-Type": "application/json" }, (options && options.headers) || {});
        if (SESSION.token) headers["Authorization"] = /^Bearer\s+/i.test(SESSION.token) ? SESSION.token : ("Bearer " + SESSION.token);

        let res;
        try {
          res = await fetch(SESSION.base + path, Object.assign({}, options || {}, { headers }));
        } catch (error) {
          const e = new Error("Network error (fetch failed): " + (error && error.message ? error.message : String(error)));
          e.kind = "network";
          throw e;
        }

        const text = await res.text();
        let data = null;
        try { data = text ? JSON.parse(text) : null; } catch { data = text; }

        if (!res.ok) {
          const e = new Error("HTTP " + res.status + ": " + (typeof data === "string" ? data : JSON.stringify(data || {})));
          e.status = res.status;
          if (res.status === 401 || res.status === 403) e.kind = "auth";
          else if (res.status === 400) e.kind = "query";
          else e.kind = "bad";
          throw e;
        }

        return data;
      }

      function toQS(params) {
        return Object.keys(params)
          .filter((k) => params[k] !== "" && params[k] != null)
          .map((k) => encodeURIComponent(k) + "=" + encodeURIComponent(params[k]))
          .join("&");
      }

      async function listRecordsSafe(collection, opts) {
        const options = opts || {};
        const perPage = options.perPage || 200;

        const attemptOne = {
          page: 1,
          perPage: perPage,
          filter: options.filter || "",
          sort: options.sort || "",
          expand: options.expand || ""
        };
        const attemptTwo = {
          page: 1,
          perPage: perPage,
          sort: options.sort || "",
          expand: options.expand || ""
        };
        const attemptThree = { page: 1, perPage: perPage };

        async function runAttempt(q) {
          const qs = toQS(q);
          const data = await pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records?" + qs, { method: "GET" });
          return (data && data.items) ? data.items : [];
        }

        try {
          return await runAttempt(attemptOne);
        } catch (e1) {
          if (e1 && e1.status === 400) {
            try {
              setStatus("warn", "Adjusted listing query after HTTP 400 (schema/filter mismatch). Loaded with fewer filters.");
              return await runAttempt(attemptTwo);
            } catch (e2) {
              if (e2 && e2.status === 400) {
                setStatus("warn", "Adjusted listing query again after HTTP 400. Loaded with no filter/sort constraints.");
                return await runAttempt(attemptThree);
              }
              throw e2;
            }
          }
          throw e1;
        }
      }

      async function createRecord(collection, body) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records", {
          method: "POST",
          body: JSON.stringify(body)
        });
      }

      async function updateRecord(collection, id, body) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records/" + encodeURIComponent(id), {
          method: "PATCH",
          body: JSON.stringify(body)
        });
      }

      async function getRecord(collection, id) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records/" + encodeURIComponent(id), { method: "GET" });
      }

      async function deleteRecord(collection, id) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records/" + encodeURIComponent(id), { method: "DELETE" });
      }

      async function authWithPassword(email, password) {
        return pbFetch("/api/collections/users/auth-with-password", {
          method: "POST",
          body: JSON.stringify({ identity: email, password: password })
        });
      }

      async function authRefresh() {
        return pbFetch("/api/collections/users/auth-refresh", { method: "POST" });
      }

      function setAuthenticatedUI(isLoggedIn) {
        $("#authPanel").style.display = isLoggedIn ? "none" : "flex";
        $("#logoutLink").style.display = isLoggedIn ? "inline" : "none";
        $("#app").style.display = isLoggedIn ? "block" : "none";
      }

      function setBusy() {
        const editing = !!state.editingTxnId;
        const disabled = !SESSION.token || state.loading || state.saving || state.deleting || editing;
        ["#btnRefresh", "#btnNewTxn", "#btnLogin"].forEach((sel) => {
          const el = $(sel);
          if (el) el.disabled = disabled && sel !== "#btnLogin";
        });
        ["#fltFrom", "#fltTo", "#fltAccount", "#fltCategory", "#fltStatus", "#fltBudgetOnly"].forEach((sel) => {
          const el = $(sel);
          if (el) el.disabled = disabled;
        });
        const canDelete = !!SESSION.token && state.selectedTxnIds.length > 0 && !state.loading && !state.saving && !state.deleting && !editing;
        $("#btnDeleteTxn").disabled = !canDelete;
        const btnEditSave = $("#btnEditSave");
        const btnEditCancel = $("#btnEditCancel");
        if (btnEditSave) btnEditSave.style.display = editing ? "inline-flex" : "none";
        if (btnEditCancel) btnEditCancel.style.display = editing ? "inline-flex" : "none";
        if (btnEditSave) btnEditSave.disabled = !editing || state.saving || state.loading || state.deleting;
        if (btnEditCancel) btnEditCancel.disabled = !editing || state.saving || state.loading || state.deleting;
      }

      function refillFilterSelect(selId, list, placeholder, labelFn) {
        const sel = $(selId);
        const current = sel.value;
        sel.innerHTML = '<option value="">' + escapeHtml(placeholder) + '</option>' + list.map((item) => '<option value="' + escapeHtml(item.id) + '">' + escapeHtml(labelFn(item)) + '</option>').join("");
        sel.value = current;
      }

      function buildEntriesFilter() {
        const out = [];
        const account = $("#fltAccount").value;
        const category = $("#fltCategory").value;
        const status = $("#fltStatus").value;
        const from = $("#fltFrom").value;
        const to = $("#fltTo").value;

        if (account) out.push('account = "' + account.replaceAll('"', '\\"') + '"');
        if (category) out.push('category = "' + category.replaceAll('"', '\\"') + '"');
        if (status) out.push('status = "' + status.replaceAll('"', '\\"') + '"');
        if (from) out.push('date >= "' + normalizeDateToNoonUtc(from) + '"');
        if (to) out.push('date <= "' + normalizeDateToNoonUtc(to) + '"');
        return out.join(" && ");
      }

      function filteredClientSide(entries) {
        const budgetOnly = $("#fltBudgetOnly").value === "1";
        if (!budgetOnly) return entries;

        return entries.filter((e) => {
          const c = getCategoryById(e.category);
          const a = getAccountById(e.account);
          if (!c || !a) return false;
          return (c.kind === "income" || c.kind === "expense") && a.type !== "virtual";
        });
      }

      async function loadReferenceData() {
        const [accounts, assets, categories] = await Promise.all([
          listRecordsSafe("accounts", { filter: "is_archived = false", sort: "name", perPage: 500 }),
          listRecordsSafe("assets", { sort: "symbol", perPage: 500 }),
          listRecordsSafe("categories", { filter: "is_archived = false", sort: "name", perPage: 500 })
        ]);
        state.accounts = accounts;
        state.accountById = new Map(state.accounts.map((a) => [String(a.id), a]));
        state.assets = assets;
        state.categories = categories;
        state.categoryById = new Map(state.categories.map((c) => [String(c.id), c]));

        refillFilterSelect("#fltAccount", state.accounts, "(all accounts)", (a) => accountLabel(a, false));
        refillFilterSelect("#fltCategory", state.categories, "(all categories)", (c) => categoryLabel(c, false));
      }

      async function loadRegister() {
        const entriesFilter = buildEntriesFilter();
        const entries = await listRecordsSafe("entries", {
          filter: entriesFilter,
          sort: "-date",
          perPage: 500
        });
        await ensureAccountsLoaded(entries.map((e) => e && e.account));
        await ensureCategoriesLoaded(entries.map((e) => e && e.category));

        const filtered = filteredClientSide(entries);
        state.entries = filtered;
        state.txns = new Map();
        const txnFilterParts = [];
        const from = $("#fltFrom").value;
        const to = $("#fltTo").value;
        if (from) txnFilterParts.push('date >= "' + normalizeDateToNoonUtc(from) + '"');
        if (to) txnFilterParts.push('date <= "' + normalizeDateToNoonUtc(to) + '"');
        const txns = await listRecordsSafe("txns", {
          filter: txnFilterParts.join(" && "),
          sort: "-date",
          perPage: 500
        });
        txns.forEach((t) => state.txns.set(t.id, t));
        await backfillMissingLinkedTxns(state.entries);

        renderRegister();
      }

      async function backfillMissingLinkedTxns(entries) {
        const missingIds = Array.from(new Set(
          (entries || [])
            .map((e) => String(e && e.txn ? e.txn : ""))
            .filter((txnId) => txnId && !state.txns.has(txnId))
        ));
        if (!missingIds.length) return;

        const batchSize = 25;
        for (let i = 0; i < missingIds.length; i += batchSize) {
          const batch = missingIds.slice(i, i + batchSize);
          const rows = await Promise.all(batch.map(async (txnId) => {
            try {
              return await getRecord("txns", txnId);
            } catch {
              return null;
            }
          }));
          rows.forEach((txn) => {
            if (txn && txn.id) state.txns.set(txn.id, txn);
          });
        }
      }

      function fieldOrNull(v) {
        const s = String(v == null ? "" : v).trim();
        return s ? s : null;
      }

      function accountLabel(account, includeArchivedTag) {
        const base = (account && (account.name || account.id)) || "";
        const type = (account && account.type) || "other";
        const archivedTag = includeArchivedTag && account && account.is_archived ? " [archived]" : "";
        return base + " (" + type + ")" + archivedTag;
      }

      function categoryLabel(category, includeArchivedTag) {
        const base = (category && (category.name || category.id)) || "";
        const kind = (category && category.kind) || "other";
        const archivedTag = includeArchivedTag && category && category.is_archived ? " [archived]" : "";
        return base + " [" + kind + "]" + archivedTag;
      }

      function getAccountById(accountId) {
        return state.accountById.get(String(accountId || "")) || null;
      }

      function accountDisplayName(accountId) {
        const a = getAccountById(accountId);
        return (a && (a.name || a.id)) || String(accountId || "");
      }

      function getCategoryById(categoryId) {
        return state.categoryById.get(String(categoryId || "")) || null;
      }

      function categoryDisplayName(categoryId) {
        const c = getCategoryById(categoryId);
        return (c && (c.name || c.id)) || String(categoryId || "");
      }

      function editableAccountOptions(selectedAccountId) {
        const selectedId = String(selectedAccountId || "");
        if (!selectedId) return state.accounts.slice();
        if (state.accounts.some((a) => String(a.id) === selectedId)) return state.accounts.slice();
        const selected = getAccountById(selectedId);
        if (!selected) return state.accounts.slice();
        return state.accounts.concat([selected]);
      }

      function editableCategoryOptions(selectedCategoryId) {
        const selectedId = String(selectedCategoryId || "");
        if (!selectedId) return state.categories.slice();
        if (state.categories.some((c) => String(c.id) === selectedId)) return state.categories.slice();
        const selected = getCategoryById(selectedId);
        if (!selected) return state.categories.slice();
        return state.categories.concat([selected]);
      }

      async function ensureAccountsLoaded(accountIds) {
        const missingIds = Array.from(new Set(
          (accountIds || [])
            .map((id) => String(id || ""))
            .filter((id) => id && !state.accountById.has(id))
        ));
        if (!missingIds.length) return;

        const batchSize = 25;
        for (let i = 0; i < missingIds.length; i += batchSize) {
          const batch = missingIds.slice(i, i + batchSize);
          const rows = await Promise.all(batch.map(async (accountId) => {
            try {
              return await getRecord("accounts", accountId);
            } catch {
              return null;
            }
          }));
          rows.forEach((account) => {
            if (account && account.id) state.accountById.set(String(account.id), account);
          });
        }
      }

      async function ensureCategoriesLoaded(categoryIds) {
        const missingIds = Array.from(new Set(
          (categoryIds || [])
            .map((id) => String(id || ""))
            .filter((id) => id && !state.categoryById.has(id))
        ));
        if (!missingIds.length) return;

        const batchSize = 25;
        for (let i = 0; i < missingIds.length; i += batchSize) {
          const batch = missingIds.slice(i, i + batchSize);
          const rows = await Promise.all(batch.map(async (categoryId) => {
            try {
              return await getRecord("categories", categoryId);
            } catch {
              return null;
            }
          }));
          rows.forEach((category) => {
            if (category && category.id) state.categoryById.set(String(category.id), category);
          });
        }
      }

      function optionList(items, selected, labelFn, includeBlank) {
        let html = "";
        if (includeBlank) html += '<option value=""></option>';
        html += items.map((item) => {
          const value = String(item.id);
          const isSel = String(selected || "") === value ? " selected" : "";
          return '<option value="' + escapeHtml(value) + '"' + isSel + '>' + escapeHtml(labelFn(item)) + "</option>";
        }).join("");
        return html;
      }

      function sortedCopyByLabel(items, labelFn) {
        return items.slice().sort((a, b) => labelFn(a).localeCompare(labelFn(b), undefined, { sensitivity: "base" }));
      }

      function localTodayYmd() {
        const now = new Date();
        return new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 10);
      }

      function getUsdAssetId() {
        const usd = state.assets.find((a) => String(a.symbol || "").toUpperCase() === "USD");
        return usd ? usd.id : "";
      }

      function focusKeyFromDblClickEvent(ev) {
        const td = ev && ev.target ? ev.target.closest("td") : null;
        const idx = td ? td.cellIndex : 0;
        if (idx === 0) return "txn-date";
        if (idx === 1) return "entry-account";
        if (idx === 2) return "txn-payee";
        if (idx === 3) return "entry-category";
        if (idx === 4) return "txn-memo";
        if (idx === 5) return "entry-qty";
        if (idx === 6) return "entry-status";
        return "txn-date";
      }

      function applyPendingInlineFocus() {
        if (!state.editingTxnId || !state.pendingFocusKey) return;
        const key = state.pendingFocusKey;
        const selector = '[data-edit="' + key + '"]';
        requestAnimationFrame(function() {
          const el = $("#registerBody " + selector);
          if (!el) return;
          try { el.focus({ preventScroll: true }); } catch { el.focus(); }
          if (el.tagName === "INPUT" && el.type !== "date") {
            try { el.select(); } catch {}
          }
          state.pendingFocusKey = "";
        });
      }

      async function startNewInlineEdit() {
        if (!SESSION.token) return;
        if (state.loading || state.saving || state.deleting) return;
        if (state.editingTxnId) {
          setStatus("warn", "Finish or cancel the current inline edit before creating a new transaction.");
          return;
        }

        let createdTxnId = "";
        let createdEntryId = "";
        try {
          state.loading = true;
          setBusy();

          if (!state.accounts.length || !state.assets.length || !state.categories.length) {
            await loadReferenceData();
          }

          const accountSorted = sortedCopyByLabel(state.accounts, (a) => (a.name || a.id || ""));
          const categorySorted = sortedCopyByLabel(state.categories, (c) => (c.name || c.id || ""));
          const usdAssetId = getUsdAssetId();

          const defaultAccount = accountSorted[0] ? accountSorted[0].id : "";
          const defaultCategory = categorySorted[0] ? categorySorted[0].id : "";
          if (!defaultAccount) throw new Error("No account available for default selection.");
          if (!usdAssetId) throw new Error("USD asset was not found.");

          const normalizedDate = normalizeDateToNoonUtc(localTodayYmd());
          const txn = await createRecord("txns", {
            date: normalizedDate,
            source: "manual"
          });
          createdTxnId = txn.id;
          const entry = await createRecord("entries", {
            txn: txn.id,
            date: normalizedDate,
            account: defaultAccount,
            category: defaultCategory || null,
            asset: usdAssetId,
            qty: 0,
            status: "pending"
          });
          createdEntryId = entry.id;

          state.selectedTxnIds = [txn.id];
          state.selectionAnchorTxnId = txn.id;
          state.editingTxnId = txn.id;
          state.editDraft = { txn: txn, entries: [entry] };
          state.pendingFocusKey = "txn-date";
          setStatus("warn", "Created new transaction and opened inline edit mode.");
          await loadRegister();
        } catch (err) {
          if (createdEntryId) {
            try { await deleteRecord("entries", createdEntryId); } catch {}
          }
          if (createdTxnId) {
            try { await deleteRecord("txns", createdTxnId); } catch {}
          }
          const info = classifyError(err);
          setStatus(info.kind, "New transaction failed: " + (err && err.message ? err.message : info.message));
        } finally {
          state.loading = false;
          setBusy();
        }
      }

      async function startInlineEdit(txnId, focusKey) {
        if (!SESSION.token || !txnId) return;
        if (state.loading || state.saving || state.deleting) return;
        if (state.editingTxnId && state.editingTxnId !== txnId) {
          const ok = await saveInlineEdit();
          if (!ok) return;
        }
        if (state.editingTxnId === txnId) {
          state.pendingFocusKey = focusKey || "txn-date";
          applyPendingInlineFocus();
          return;
        }
        try {
          state.loading = true;
          setBusy();
          const txn = await getRecord("txns", txnId);
          const entries = await listRecordsSafe("entries", {
            filter: 'txn = "' + txnId.replaceAll('"', '\\"') + '"',
            sort: "-date",
            perPage: 500
          });
          await ensureAccountsLoaded(entries.map((e) => e && e.account));
          await ensureCategoriesLoaded(entries.map((e) => e && e.category));
          state.editingTxnId = txnId;
          state.selectedTxnIds = [txnId];
          state.selectionAnchorTxnId = txnId;
          state.editDraft = { txn: txn, entries: entries };
          state.pendingFocusKey = focusKey || "txn-date";
          setStatus("warn", "Inline edit mode: update fields, then Save Edit or Cancel.");
          renderRegister();
        } catch (err) {
          const info = classifyError(err);
          setStatus(info.kind, "Failed to start edit: " + (err && err.message ? err.message : info.message));
        } finally {
          state.loading = false;
          setBusy();
        }
      }

      function cancelInlineEdit() {
        state.editingTxnId = "";
        state.editDraft = null;
        state.pendingFocusKey = "";
        setStatus("ok", "Edit canceled.");
        renderRegister();
        setBusy();
      }

      async function saveInlineEdit() {
        if (!state.editingTxnId || !state.editDraft || !SESSION.token) return false;
        if (state.saving) return false;
        const txnId = state.editingTxnId;
        const root = $('#registerBody tr[data-edit-root="1"]');
        if (!root) return false;
        let normalizedDate = "";
        let payee = null;
        let memo = null;
        const updates = [];

        try {
          const dateRaw = $('input[data-edit="txn-date"]', root).value.trim();
          payee = fieldOrNull($('input[data-edit="txn-payee"]', root).value);
          memo = fieldOrNull($('input[data-edit="txn-memo"]', root).value);
          if (!/^\d{4}-\d{2}-\d{2}$/.test(dateRaw)) throw new Error("Date must be in YYYY-MM-DD format.");
          normalizedDate = normalizeDateToNoonUtc(dateRaw);
          const usdAssetId = getUsdAssetId();
          if (!usdAssetId) throw new Error("USD asset was not found.");

          const entryRows = $$('tr[data-edit-entry="1"]', $("#registerBody"));
          for (const row of entryRows) {
            const entryId = row.getAttribute("data-entry-id") || "";
            const account = $('select[data-edit="entry-account"]', row).value;
            const category = $('select[data-edit="entry-category"]', row).value;
            const qtyRaw = $('input[data-edit="entry-qty"]', row).value.trim();
            const status = $('select[data-edit="entry-status"]', row).value;

            if (!entryId) throw new Error("Entry id missing in edit row.");
            if (!account) throw new Error("Account is required for all entries.");
            if (!status) throw new Error("Status is required for all entries.");
            if (!qtyRaw) throw new Error("Amount is required for all entries.");
            const qty = Number(qtyRaw);
            if (!Number.isFinite(qty)) throw new Error("Amount must be numeric for all entries.");

            const body = {
              date: normalizedDate,
              account: account,
              category: category || null,
              asset: usdAssetId,
              qty: qty,
              status: status
            };
            updates.push({ id: entryId, body: body });
          }
        } catch (err) {
          setStatus("bad", "Save failed: " + (err && err.message ? err.message : String(err)));
          return false;
        }

        try {
          state.saving = true;
          setBusy();
          await updateRecord("txns", txnId, {
            date: normalizedDate,
            payee: payee,
            memo: memo
          });
          for (const u of updates) {
            await updateRecord("entries", u.id, u.body);
          }
          state.editingTxnId = "";
          state.editDraft = null;
          state.pendingFocusKey = "";
          setStatus("ok", "Transaction " + txnId + " updated.");
          await refreshAll();
          return true;
        } catch (err) {
          const info = classifyError(err);
          setStatus(info.kind, "Save edit failed: " + (err && err.message ? err.message : info.message));
          return false;
        } finally {
          state.saving = false;
          setBusy();
        }
      }

      function renderRegister() {
        const body = $("#registerBody");

        body.innerHTML = "";
        const txnGroups = new Map();
        const txnOrder = [];
        state.entries.forEach((e) => {
          const key = e.txn || "";
          if (!txnGroups.has(key)) {
            txnGroups.set(key, []);
            txnOrder.push(key);
          }
          txnGroups.get(key).push(e);
        });
        state.visibleTxnOrder = txnOrder.slice();
        const orderSet = new Set(txnOrder);
        state.selectedTxnIds = state.selectedTxnIds.filter((id) => orderSet.has(id));
        if (state.selectionAnchorTxnId && !orderSet.has(state.selectionAnchorTxnId)) {
          state.selectionAnchorTxnId = state.selectedTxnIds[0] || "";
        }
        const selectedSet = new Set(state.selectedTxnIds);

        function selectTxn(txnId, ev) {
          if (state.editingTxnId) return;
          const order = state.visibleTxnOrder || [];
          const selected = new Set(state.selectedTxnIds);
          const isToggle = !!(ev && (ev.metaKey || ev.ctrlKey));
          const isRange = !!(ev && ev.shiftKey);

          if (isRange && state.selectionAnchorTxnId) {
            const a = order.indexOf(state.selectionAnchorTxnId);
            const b = order.indexOf(txnId);
            if (a !== -1 && b !== -1) {
              const start = Math.min(a, b);
              const end = Math.max(a, b);
              const range = order.slice(start, end + 1);
              if (!isToggle) selected.clear();
              range.forEach((id) => selected.add(id));
            } else {
              if (!isToggle) selected.clear();
              selected.add(txnId);
            }
          } else if (isToggle) {
            if (selected.has(txnId)) selected.delete(txnId);
            else selected.add(txnId);
            state.selectionAnchorTxnId = txnId;
          } else {
            selected.clear();
            selected.add(txnId);
            state.selectionAnchorTxnId = txnId;
          }

          if (!state.selectionAnchorTxnId && txnId) state.selectionAnchorTxnId = txnId;
          state.selectedTxnIds = Array.from(selected);
          setBusy();
          renderRegister();
        }

        txnOrder.forEach((txnId) => {
          const group = txnGroups.get(txnId) || [];
          const txn = state.txns.get(txnId) || {};
          const isSelected = selectedSet.has(txnId);

          if (state.editingTxnId && state.editingTxnId === txnId && state.editDraft) {
            const draftTxn = state.editDraft.txn || {};
            const draftEntries = state.editDraft.entries || [];
            const isSingle = draftEntries.length <= 1;

            if (isSingle) {
              const e = draftEntries[0] || {};
              const trSingle = document.createElement("tr");
              trSingle.className = "txn-edit txn-edit-end";
              trSingle.setAttribute("data-edit-root", "1");
              trSingle.setAttribute("data-edit-entry", "1");
              trSingle.setAttribute("data-entry-id", String(e.id || ""));
              trSingle.innerHTML = [
                '<td><input class="inlineInput" data-edit="txn-date" type="text" inputmode="numeric" placeholder="YYYY-MM-DD" value="' + escapeHtml(fmtDate(draftTxn.date || e.date)) + '" /></td>',
                '<td><select class="inlineSelect" data-edit="entry-account">' + optionList(editableAccountOptions(e.account), e.account, (a) => accountLabel(a, true), false) + "</select></td>",
                '<td><input class="inlineInput" data-edit="txn-payee" type="text" value="' + escapeHtml(draftTxn.payee || "") + '" /></td>',
                '<td><select class="inlineSelect" data-edit="entry-category">' + optionList(editableCategoryOptions(e.category), e.category, (c) => categoryLabel(c, true), true) + "</select></td>",
                '<td><input class="inlineInput" data-edit="txn-memo" type="text" value="' + escapeHtml(draftTxn.memo || "") + '" /></td>',
                '<td><input class="inlineInput" data-edit="entry-qty" type="text" value="' + escapeHtml(e.qty == null ? "" : String(e.qty)) + '" /></td>',
                '<td><select class="inlineSelect" data-edit="entry-status"><option value="pending"' + (e.status === "pending" ? " selected" : "") + '>pending</option><option value="cleared"' + (e.status === "cleared" ? " selected" : "") + '>cleared</option></select></td>'
              ].join("");
              body.appendChild(trSingle);
              return;
            }

            const trTxn = document.createElement("tr");
            trTxn.className = "txn-edit";
            trTxn.setAttribute("data-edit-root", "1");
            trTxn.innerHTML = [
              '<td><input class="inlineInput" data-edit="txn-date" type="text" inputmode="numeric" placeholder="YYYY-MM-DD" value="' + escapeHtml(fmtDate(draftTxn.date)) + '" /></td>',
              "<td></td>",
              '<td><input class="inlineInput" data-edit="txn-payee" type="text" value="' + escapeHtml(draftTxn.payee || "") + '" /></td>',
              "<td></td>",
              '<td><input class="inlineInput" data-edit="txn-memo" type="text" value="' + escapeHtml(draftTxn.memo || "") + '" /></td>',
              "<td></td>",
              "<td></td>"
            ].join("");
            body.appendChild(trTxn);

            draftEntries.forEach((e, idx) => {
              const trE = document.createElement("tr");
              trE.className = "txn-edit" + (idx === draftEntries.length - 1 ? " txn-edit-end" : "");
              trE.setAttribute("data-edit-entry", "1");
              trE.setAttribute("data-entry-id", String(e.id || ""));
              trE.innerHTML = [
                "<td></td>",
                '<td><select class="inlineSelect" data-edit="entry-account">' + optionList(editableAccountOptions(e.account), e.account, (a) => accountLabel(a, true), false) + "</select></td>",
                "<td></td>",
                '<td><select class="inlineSelect" data-edit="entry-category">' + optionList(editableCategoryOptions(e.category), e.category, (c) => categoryLabel(c, true), true) + "</select></td>",
                "<td></td>",
                '<td><input class="inlineInput" data-edit="entry-qty" type="text" value="' + escapeHtml(e.qty == null ? "" : String(e.qty)) + '" /></td>',
                '<td><select class="inlineSelect" data-edit="entry-status"><option value="pending"' + (e.status === "pending" ? " selected" : "") + '>pending</option><option value="cleared"' + (e.status === "cleared" ? " selected" : "") + '>cleared</option></select></td>'
              ].join("");
              body.appendChild(trE);
            });
            return;
          }

          if (group.length <= 1) {
            const e = group[0];
            if (!e) return;

            const tr = document.createElement("tr");
            if (isSelected) tr.classList.add("selected");

            const qty = Number(e.qty);
            const qtyTxt = Number.isFinite(qty) ? qty.toLocaleString(undefined, { maximumFractionDigits: 8 }) : (e.qty == null ? "" : String(e.qty));

            tr.innerHTML = [
              "<td>" + escapeHtml(fmtDate(e.date)) + "</td>",
              "<td>" + escapeHtml(accountDisplayName(e.account)) + "</td>",
              "<td>" + escapeHtml(txn.payee || "") + "</td>",
              "<td><span class=\"pill\">" + escapeHtml(categoryDisplayName(e.category)) + "</span></td>",
              "<td>" + escapeHtml(txn.memo || "") + "</td>",
              "<td>" + escapeHtml(qtyTxt) + "</td>",
              "<td>" + escapeHtml(e.status || "") + "</td>"
            ].join("");

            tr.addEventListener("click", function(ev) { selectTxn(e.txn || "", ev); });
            tr.addEventListener("dblclick", function(ev) { startInlineEdit(e.txn || "", focusKeyFromDblClickEvent(ev)); });
            body.appendChild(tr);
            return;
          }

          const totalQty = group.reduce((sum, e) => {
            const q = Number(e.qty);
            return Number.isFinite(q) ? (sum + q) : sum;
          }, 0);
          const totalTxt = totalQty.toLocaleString(undefined, { maximumFractionDigits: 8 });

          const parentRow = document.createElement("tr");
          parentRow.className = "txn-parent";
          if (isSelected) parentRow.classList.add("selected");
          parentRow.innerHTML = [
            "<td>" + escapeHtml(fmtDate(txn.date || group[0].date)) + "</td>",
            "<td></td>",
            "<td>" + escapeHtml(txn.payee || "") + "</td>",
            "<td></td>",
            "<td>" + escapeHtml(txn.memo || "") + "</td>",
            "<td>" + escapeHtml(totalTxt) + "</td>",
            "<td></td>"
          ].join("");
          parentRow.addEventListener("click", function(ev) { selectTxn(txnId, ev); });
          parentRow.addEventListener("dblclick", function(ev) { startInlineEdit(txnId, focusKeyFromDblClickEvent(ev)); });
          body.appendChild(parentRow);

          group.forEach((e, idx) => {
            const tr = document.createElement("tr");
            tr.className = "txn-sub" + (idx === group.length - 1 ? " txn-sub-end" : "");
            if (isSelected) tr.classList.add("selected");

            const qty = Number(e.qty);
            const qtyTxt = Number.isFinite(qty) ? qty.toLocaleString(undefined, { maximumFractionDigits: 8 }) : (e.qty == null ? "" : String(e.qty));
            tr.innerHTML = [
              "<td></td>",
              "<td>" + escapeHtml(accountDisplayName(e.account)) + "</td>",
              "<td></td>",
              "<td><span class=\"pill\">" + escapeHtml(categoryDisplayName(e.category)) + "</span></td>",
              "<td></td>",
              "<td>" + escapeHtml(qtyTxt) + "</td>",
              "<td>" + escapeHtml(e.status || "") + "</td>"
            ].join("");

            tr.addEventListener("click", function(ev) { selectTxn(txnId, ev); });
            tr.addEventListener("dblclick", function(ev) { startInlineEdit(txnId, focusKeyFromDblClickEvent(ev)); });
            body.appendChild(tr);
          });
        });

        applyPendingInlineFocus();
        $("#resultCount").textContent = state.entries.length + " entries shown across " + txnOrder.length + " transactions. Double-click a transaction row to edit inline.";
      }

      async function deleteSelectedTransaction() {
        if (!SESSION.token || state.selectedTxnIds.length < 1 || state.deleting) return;
        const txnIds = state.selectedTxnIds.slice();
        const yes = confirm("Delete " + txnIds.length + " selected transaction(s) and their entries? This cannot be undone.");
        if (!yes) return;

        state.deleting = true;
        setBusy();

        let deletedTxns = 0;
        let deletedEntries = 0;
        const failed = [];
        try {
          for (const txnId of txnIds) {
            try {
              const rows = await listRecordsSafe("entries", { filter: 'txn = "' + txnId.replaceAll('"', '\\"') + '"', perPage: 500, sort: "-date" });
              for (const row of rows) {
                await deleteRecord("entries", row.id);
                deletedEntries += 1;
              }
              await deleteRecord("txns", txnId);
              deletedTxns += 1;
            } catch {
              failed.push(txnId);
            }
          }
          state.selectedTxnIds = failed.slice();
          state.selectionAnchorTxnId = state.selectedTxnIds[0] || "";
          if (failed.length > 0) {
            setStatus("warn", "Deleted " + deletedTxns + " txn(s), " + deletedEntries + " entries. Failed: " + failed.join(", "));
          } else {
            setStatus("ok", "Deleted " + deletedTxns + " txn(s) and " + deletedEntries + " related entries.");
          }
          await refreshAll();
        } catch (err) {
          const info = classifyError(err);
          setStatus(info.kind, "Delete failed: " + (err && err.message ? err.message : info.message));
        } finally {
          state.deleting = false;
          setBusy();
        }
      }

      async function refreshAll() {
        if (!SESSION.token) return;
        state.loading = true;
        setBusy();

        try {
          await loadReferenceData();

          await loadRegister();

          setStatus("ok", "Loaded accounts/assets/categories and register entries.");
        } catch (err) {
          const info = classifyError(err);
          setStatus(info.kind, "Load failed: " + (err && err.message ? err.message : info.message));
          if (err && err.kind === "auth") {
            SESSION.token = "";
            store.del("pbToken");
            state.editingTxnId = "";
            state.editDraft = null;
            setAuthenticatedUI(false);
          }
        } finally {
          state.loading = false;
          setBusy();
        }
      }

      async function validateCachedSession() {
        if (!SESSION.base || !SESSION.token) return false;
        try {
          const res = await authRefresh();
          if (res && res.token) {
            SESSION.token = res.token;
            store.set("pbToken", res.token);
          }
          return true;
        } catch {
          return false;
        }
      }

      $("#btnLogin").addEventListener("click", async function() {
        const base = $("#pbUrl").value.trim().replace(/\/+$/, "");
        const email = $("#pbEmail").value.trim();
        const password = $("#pbPass").value;

        if (!base || !email || !password) {
          setStatus("bad", "Login failed: URL, email, and password are required.");
          return;
        }

        store.set("pbUrl", base);
        store.set("pbEmail", email);

        try {
          $("#btnLogin").disabled = true;
          SESSION.base = base;
          SESSION.token = "";

          const res = await authWithPassword(email, password);
          if (!res || !res.token) throw new Error("No token returned by PocketBase.");

          SESSION.token = res.token;
          store.set("pbToken", res.token);
          setAuthenticatedUI(true);
          setStatus("ok", "Login succeeded. Session saved in localStorage.");
          await refreshAll();
        } catch (err) {
          SESSION.token = "";
          store.del("pbToken");
          setAuthenticatedUI(false);
          const info = classifyError(err);
          setStatus(info.kind, "Login failed: " + (err && err.message ? err.message : info.message));
        } finally {
          $("#btnLogin").disabled = false;
          $("#pbPass").value = "";
        }
      });

      $("#logoutLink").addEventListener("click", function(ev) {
        ev.preventDefault();
        SESSION.base = "";
        SESSION.token = "";
        store.del("pbUrl");
        store.del("pbEmail");
        store.del("pbToken");
        $("#pbUrl").value = "";
        $("#pbEmail").value = "";
        $("#pbPass").value = "";
        state.entries = [];
        state.accounts = [];
        state.accountById = new Map();
        state.assets = [];
        state.categories = [];
        state.categoryById = new Map();
        state.txns = new Map();
        state.selectedTxnIds = [];
        state.selectionAnchorTxnId = "";
        state.visibleTxnOrder = [];
        state.editingTxnId = "";
        state.editDraft = null;
        $("#registerBody").innerHTML = "";
        $("#resultCount").textContent = "";
        setAuthenticatedUI(false);
        setStatus("ok", "Logged out. Local session cleared.");
        setBusy();
      });

      $("#btnRefresh").addEventListener("click", refreshAll);
      $("#btnNewTxn").addEventListener("click", startNewInlineEdit);
      $("#btnDeleteTxn").addEventListener("click", deleteSelectedTransaction);
      $("#btnEditSave").addEventListener("click", saveInlineEdit);
      $("#btnEditCancel").addEventListener("click", cancelInlineEdit);

      ["#fltFrom", "#fltTo", "#fltAccount", "#fltCategory", "#fltStatus", "#fltBudgetOnly"].forEach((sel) => {
        $(sel).addEventListener("change", refreshAll);
      });

      $("#registerBody").addEventListener("keydown", function(e) {
        if (!state.editingTxnId) return;
        if (e.key === "Escape") {
          e.preventDefault();
          cancelInlineEdit();
          return;
        }
        if (e.key !== "Enter") return;
        const t = e.target;
        if (!t || !(t.matches("input") || t.matches("select"))) return;
        e.preventDefault();
        saveInlineEdit();
      });

      $("#pbUrl").value = store.get("pbUrl", "");
      $("#pbEmail").value = store.get("pbEmail", "");

      (async function init() {
        SESSION.base = ($("#pbUrl").value || "").trim().replace(/\/+$/, "");
        SESSION.token = (store.get("pbToken", "") || "").trim();

        if (SESSION.base && SESSION.token) {
          const ok = await validateCachedSession();
          if (ok) {
            setAuthenticatedUI(true);
            setStatus("ok", "Session restored via auth-refresh.");
            await refreshAll();
            return;
          }
          SESSION.token = "";
          store.del("pbToken");
        }

        setAuthenticatedUI(false);
        setStatus("warn", "Not logged in. Enter URL, email, and password.");
        setBusy();
      })();
    })();
  </script>
</body>
</html>
