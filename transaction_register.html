<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BudgetKit - Core Transaction Register</title>
  <style>
    :root {
      --bg: #0a0f16;
      --panel: #111a26;
      --panel2: #172335;
      --text: #e7edf6;
      --muted: #a8b7ca;
      --line: #2a3a52;
      --accent: #6ec1ff;
      --ok: #3ed598;
      --warn: #ffd479;
      --bad: #ff7f7f;
      --radius: 12px;
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--sans);
      color: var(--text);
      background: radial-gradient(circle at top right, #17263b 0%, #0a0f16 45%, #070b10 100%);
      min-height: 100vh;
    }
    .wrap { max-width: 1260px; margin: 0 auto; padding: 16px; }
    .topbar, .panel {
      border: 1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(17, 26, 38, 0.92);
      box-shadow: var(--shadow);
    }
    .topbar {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 12px;
      flex-wrap: wrap;
      padding: 12px;
    }
    h1 { margin: 0; font-size: 18px; }
    .sub { margin-top: 4px; color: var(--muted); font-size: 12px; }
    .auth {
      display: flex;
      gap: 8px;
      align-items: flex-end;
      flex-wrap: wrap;
    }
    .field { display: flex; flex-direction: column; gap: 5px; }
    label { color: var(--muted); font-size: 12px; }
    input[type="text"], input[type="password"], input[type="date"], select, textarea {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(23, 35, 53, 0.95);
      color: var(--text);
      padding: 8px 10px;
      outline: none;
    }
    input:focus, select:focus, textarea:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(110, 193, 255, 0.15); }
    textarea { min-height: 68px; resize: vertical; }
    .btn {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 12px;
      background: rgba(23, 35, 53, 0.95);
      color: var(--text);
      cursor: pointer;
      font-weight: 600;
    }
    .btn:hover { border-color: var(--accent); }
    .btn.primary { border-color: rgba(110, 193, 255, 0.55); background: rgba(110, 193, 255, 0.18); }
    .btn.danger { border-color: rgba(255, 127, 127, 0.55); background: rgba(255, 127, 127, 0.16); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .logout {
      display: none;
      color: var(--muted);
      text-decoration: none;
      font-size: 12px;
      margin-left: 8px;
    }
    .status {
      margin-top: 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 9px 10px;
      font-size: 13px;
      background: rgba(14, 22, 33, 0.75);
      color: var(--muted);
    }
    .status.ok { border-color: rgba(62, 213, 152, 0.45); color: #bdf7df; }
    .status.warn { border-color: rgba(255, 212, 121, 0.45); color: #ffeabc; }
    .status.bad { border-color: rgba(255, 127, 127, 0.45); color: #ffd1d1; }
    #app { display: none; margin-top: 12px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    .panel { padding: 12px; }
    .panel h2 { margin: 0 0 10px; font-size: 14px; }
    .line { display: flex; gap: 8px; flex-wrap: wrap; align-items: flex-end; }
    .line .field { min-width: 110px; }
    .mono { font-family: var(--mono); font-size: 12px; color: var(--muted); }
    .toolbar {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 10px;
    }
    table { width: 100%; border-collapse: collapse; table-layout: fixed; }
    #registerTable {
      min-width: 598px;
    }
    #registerTable col.col-date { width: 88px; min-width: 88px; }
    #registerTable col.col-account { width: 88px; min-width: 88px; }
    #registerTable col.col-payee { width: 50%; min-width: 100px; }
    #registerTable col.col-category { width: 150px; min-width: 150px; }
    #registerTable col.col-memo { width: 50%; min-width: 20px; }
    #registerTable col.col-amount { width: 110px; min-width: 110px; }
    #registerTable col.col-status { width: 42px; min-width: 42px; }
    th, td {
      border-bottom: 1px solid rgba(42, 58, 82, 0.75);
      padding: 9px 8px;
      font-size: 12px;
      text-align: left;
      vertical-align: top;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #registerTable th:nth-child(4),
    #registerTable td:nth-child(4) {
      text-overflow: clip;
    }
    th { color: var(--muted); font-size: 11px; text-transform: uppercase; letter-spacing: 0.2px; }
    th.sortable { cursor: pointer; user-select: none; }
    th.sortable:hover { color: var(--text); }
    th.sorted-asc::after { content: " \2191"; color: var(--accent); }
    th.sorted-desc::after { content: " \2193"; color: var(--accent); }
    th.amountHead { text-align: right; }
    tr.selected { background: rgba(110, 193, 255, 0.08); }
    tr.txn-parent td {
      background: rgba(110, 193, 255, 0.06);
      border-bottom: 0;
      font-weight: 600;
    }
    tr.txn-sub td {
      background: rgba(110, 193, 255, 0.03);
      border-bottom: 0;
    }
    tr.txn-sub td:nth-child(3),
    tr.txn-sub td:nth-child(4) { padding-left: 20px; }
    tr.txn-sub-end td { border-bottom: 1px solid rgba(42, 58, 82, 0.75); }
    tr.txn-edit td {
      background: rgba(255, 212, 121, 0.08);
      border-bottom: 0;
      vertical-align: middle;
      overflow: visible;
    }
    tr.txn-edit-end td { border-bottom: 1px solid rgba(42, 58, 82, 0.75); }
    .inlineInput, .inlineSelect {
      width: 100%;
      min-width: 0;
      height: 30px;
      border: 1px solid var(--line);
      border-radius: 8px;
      background: rgba(23, 35, 53, 0.95);
      color: var(--text);
      padding: 5px 8px;
      margin: 0;
      font-size: 12px;
      line-height: 1.2;
      box-sizing: border-box;
      display: block;
    }
    .inlineSelect {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }
    .statusCycleBtn {
      border: 0;
      background: transparent;
      color: inherit;
      padding: 0;
      cursor: pointer;
      font-size: 15px;
      line-height: 1;
    }
    .statusCycleBtn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }
    .entryRowBtn {
      width: 24px;
      height: 24px;
      min-width: 24px;
      border: 1px solid var(--line);
      border-radius: 7px;
      background: rgba(23, 35, 53, 0.95);
      color: var(--text);
      font-size: 14px;
      line-height: 1;
      font-weight: 700;
      cursor: pointer;
      padding: 0;
    }
    .entryRowBtn:hover {
      border-color: var(--accent);
    }
    .entryRowBtn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }
    .amountCell {
      display: flex;
      justify-content: flex-end;
      width: 100%;
      font-family: var(--mono);
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum" 1;
    }
    .amountParts {
      display: inline-grid;
      grid-template-columns: 1ch auto 1ch var(--frac-width, 2ch) 1ch;
      align-items: baseline;
      min-width: 0;
    }
    .amountWhole { text-align: right; }
    .amountSign, .amountDot, .amountFrac, .amountClose { text-align: center; }
    .inlineLookup {
      position: relative;
      width: 100%;
    }
    .inlineLookupMenu {
      position: absolute;
      left: 0;
      right: 0;
      top: calc(100% + 2px);
      max-height: 180px;
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 8px;
      background: rgba(17, 26, 38, 0.98);
      box-shadow: var(--shadow);
      z-index: 40;
      display: none;
    }
    .inlineLookup.open .inlineLookupMenu {
      display: block;
    }
    .inlineLookupOption {
      display: block;
      width: 100%;
      border: 0;
      border-bottom: 1px solid rgba(42, 58, 82, 0.6);
      background: transparent;
      color: var(--text);
      text-align: left;
      padding: 7px 8px;
      font-size: 12px;
      cursor: pointer;
    }
    .inlineLookupOption:last-child {
      border-bottom: 0;
    }
    .inlineLookupOption:hover,
    .inlineLookupOption:focus {
      background: rgba(110, 193, 255, 0.14);
      outline: none;
    }
    .inlineLookupOption.active {
      background: rgba(110, 193, 255, 0.2);
    }
    .inlineLookupEmpty {
      padding: 7px 8px;
      color: var(--muted);
      font-size: 11px;
      display: none;
    }
    .pill {
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 2px 7px;
      font-size: 11px;
      display: inline-flex;
      align-items: center;
    }
    .help { color: var(--muted); font-size: 12px; line-height: 1.35; }
    .pager {
      margin-top: 10px;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .pager .spacer { flex: 1 1 auto; }
    .modalBackdrop {
      position: fixed;
      inset: 0;
      background: rgba(7, 11, 16, 0.78);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 1200;
    }
    .modalCard {
      width: min(520px, 100%);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(17, 26, 38, 0.98);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .modalHead {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 10px;
    }
    .modalTitle {
      margin: 0;
      font-size: 15px;
    }
    .recurrenceTag {
      border: 1px solid rgba(110, 193, 255, 0.45);
      border-radius: 999px;
      padding: 1px 7px;
      font-size: 10px;
      color: #d7ecff;
      background: rgba(110, 193, 255, 0.12);
      margin-left: 6px;
      display: inline-flex;
      align-items: center;
      vertical-align: middle;
    }
    @media (max-width: 1080px) {
      .grid { grid-template-columns: 1fr; }
    }
    @media (max-width: 760px) {
      .auth input[type="text"], .auth input[type="password"] { width: 100%; }
      .auth .field { min-width: 100%; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1>Core Transaction Register <a class="logout" id="logoutLink" href="#">logout</a></h1>
        <div class="sub">Transactions (`txns`) and entries (`entries`) with multi-entry support.</div>
      </div>
      <div class="auth" id="authPanel">
        <div class="field">
          <label for="pbUrl">URL</label>
          <input id="pbUrl" type="text" placeholder="http://127.0.0.1:8090" />
        </div>
        <div class="field">
          <label for="pbEmail">Email</label>
          <input id="pbEmail" type="text" placeholder="you@example.com" />
        </div>
        <div class="field">
          <label for="pbPass">Password</label>
          <input id="pbPass" type="password" placeholder="password" />
        </div>
        <button class="btn primary" id="btnLogin">Login</button>
      </div>
    </div>

    <div class="status" id="statusBox">Not authenticated.</div>

    <div id="app">
      <div class="grid">
        <section class="panel">
          <div class="toolbar">
            <h2 style="margin:0;">Register</h2>
            <div class="line">
              <button class="btn primary" id="btnNewTxn" type="button">New Transaction</button>
              <button class="btn" id="btnRecurrence" type="button" disabled>Recurrence</button>
              <button class="btn" id="btnEditAddEntry" type="button" style="display:none;">Add Entry</button>
              <button class="btn primary" id="btnEditSave" type="button" style="display:none;">Save Edit</button>
              <button class="btn" id="btnEditCancel" type="button" style="display:none;">Cancel</button>
              <button class="btn" id="btnRefresh">Refresh</button>
              <button class="btn danger" id="btnDeleteTxn" disabled>Delete selected txn</button>
            </div>
          </div>

          <div class="line" style="margin-bottom:8px;">
            <div class="field">
              <label for="fltFrom">From</label>
              <input id="fltFrom" type="date" />
            </div>
            <div class="field">
              <label for="fltTo">To</label>
              <input id="fltTo" type="date" />
            </div>
            <div class="field">
              <label for="fltAccount">Account</label>
              <select id="fltAccount"></select>
            </div>
            <div class="field">
              <label for="fltPayee">Payee</label>
              <input id="fltPayee" type="text" list="payeeFilterSuggestions" placeholder="Search payee name" />
              <datalist id="payeeFilterSuggestions"></datalist>
            </div>
            <div class="field">
              <label for="fltCategory">Category</label>
              <select id="fltCategory"></select>
            </div>
            <div class="field">
              <label for="fltStatus">Status</label>
              <select id="fltStatus"></select>
            </div>
            <div class="field">
              <label for="fltBudgetOnly">Budget kinds</label>
              <select id="fltBudgetOnly">
                <option value="0">All entries</option>
                <option value="1">Income/Expense only</option>
              </select>
            </div>
          </div>

          <div class="registerTableWrap" style="overflow:auto;">
            <table id="registerTable">
              <colgroup>
                <col class="col-date" />
                <col class="col-account" />
                <col class="col-payee" />
                <col class="col-category" />
                <col class="col-memo" />
                <col class="col-amount" />
                <col class="col-status" />
              </colgroup>
              <thead>
                <tr>
                  <th data-sort="date">Date</th>
                  <th data-sort="account">Account</th>
                  <th data-sort="payee">Payee</th>
                  <th data-sort="category">Category</th>
                  <th data-sort="memo">Memo</th>
                  <th data-sort="amount" class="amountHead">Amount</th>
                  <th data-sort="status"></th>
                </tr>
              </thead>
              <tbody id="registerBody"></tbody>
            </table>
          </div>
          <div class="help" id="resultCount" style="margin-top:10px;"></div>
          <div class="pager">
            <button class="btn" id="btnPrevPage" type="button">Prev</button>
            <button class="btn" id="btnNextPage" type="button">Next</button>
            <span class="mono" id="pageInfo">Page 1 of 1</span>
            <div class="spacer"></div>
            <label class="mono" for="perPage">Rows/page</label>
            <select id="perPage">
              <option value="50">50</option>
              <option value="100" selected>100</option>
              <option value="200">200</option>
            </select>
          </div>
        </section>
      </div>
    </div>
  </div>
  <div class="modalBackdrop" id="recurrenceModal" aria-hidden="true">
    <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="recurrenceModalTitle">
      <div class="modalHead">
        <h2 class="modalTitle" id="recurrenceModalTitle">Scheduled Recurrence</h2>
      </div>
      <div class="help" id="recurrenceTxnLabel" style="margin-bottom:10px;"></div>
      <div class="line" style="margin-bottom:10px;">
        <div class="field">
          <label for="recFreq">Frequency</label>
          <select id="recFreq">
            <option value="DAILY">Every N day(s)</option>
            <option value="MONTHLY">Every N month(s)</option>
          </select>
        </div>
        <div class="field">
          <label for="recInterval">Interval</label>
          <input id="recInterval" type="number" min="1" step="1" value="1" />
        </div>
        <div class="field">
          <label for="recUntil">Until (optional)</label>
          <input id="recUntil" type="date" />
        </div>
      </div>
      <div class="help" id="recurrencePreview" style="margin-bottom:10px;">RRULE preview: FREQ=DAILY;INTERVAL=1</div>
      <div class="line">
        <button class="btn primary" id="btnRecurrenceSave" type="button">Save recurrence</button>
        <button class="btn" id="btnRecurrenceClear" type="button">Clear recurrence</button>
        <button class="btn" id="btnRecurrenceCancel" type="button">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    (function() {
      const $ = (s, el) => (el || document).querySelector(s);
      const $$ = (s, el) => Array.from((el || document).querySelectorAll(s));

      const store = {
        get(k, d) { try { const v = localStorage.getItem(k); return v == null ? d : v; } catch { return d; } },
        set(k, v) { try { localStorage.setItem(k, v); } catch {} },
        del(k) { try { localStorage.removeItem(k); } catch {} }
      };
      const ENTRY_STATUS_OPTIONS = [
        { value: "scheduled", emoji: "\u23F3", label: "scheduled" },
        { value: "pending", emoji: "\u2610", label: "pending" },
        { value: "cleared", emoji: "\u2611", label: "cleared" }
      ];

      const SESSION = { base: "", token: "" };
      const state = {
        loading: false,
        saving: false,
        deleting: false,
        accounts: [],
        accountById: new Map(),
        assets: [],
        assetPrecisionById: new Map(),
        categories: [],
        categoryById: new Map(),
        payees: [],
        payeeById: new Map(),
        txns: new Map(),
        entries: [],
        selectedTxnIds: [],
        selectionAnchorTxnId: "",
        visibleTxnOrder: [],
        editingTxnId: "",
        editDraft: null,
        pendingFocusKey: "",
        recurrenceModalOpen: false,
        recurrenceModalTxnId: "",
        recurrenceModalHasExisting: false,
        modalBusy: false,
        sort: { column: "date", direction: "desc" },
        page: 1,
        perPage: 100,
        totalPages: 1,
        totalItems: 0
      };

      function escapeHtml(v) {
        return String(v == null ? "" : v)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      function normalizeDateToNoonUtc(dateStr) {
        return dateStr + "T12:00:00Z";
      }

      function fmtDate(dateValue) {
        if (!dateValue) return "";
        const d = new Date(dateValue);
        if (isNaN(d.getTime())) return String(dateValue);
        return d.toISOString().slice(0, 10);
      }

      function validYmd(raw) {
        return /^\d{4}-\d{2}-\d{2}$/.test(String(raw || ""));
      }

      function normalizePrecision(raw) {
        const n = Number(raw);
        if (Number.isInteger(n) && n >= 0 && n <= 9) return n;
        return 2;
      }

      function assetPrecision(assetId) {
        return state.assetPrecisionById.get(String(assetId || "")) ?? 2;
      }

      function parseMinorInt(raw, fieldName) {
        const n = Number(raw);
        if (!Number.isFinite(n) || !Number.isSafeInteger(n)) {
          throw new Error(fieldName + " must be a fixed-precision integer in minor units.");
        }
        return n;
      }

      function parseMajorToMinor(raw, precision) {
        let s = String(raw == null ? "" : raw).trim();
        if (!s) throw new Error("Amount is required.");
        s = s.replaceAll(",", "").replaceAll("$", "").trim();
        if (/^\(.*\)$/.test(s)) s = "-" + s.slice(1, -1);
        if (!/^-?\d+(\.\d+)?$/.test(s)) throw new Error("Amount must be numeric.");

        const neg = s.startsWith("-");
        const unsigned = neg ? s.slice(1) : s;
        const parts = unsigned.split(".");
        const whole = parts[0] || "0";
        const frac = parts[1] || "";
        if (frac.length > precision) throw new Error("Amount has more than " + precision + " decimal places.");

        const scale = 10 ** precision;
        const wholeNum = Number(whole);
        const fracNum = frac ? Number(frac.padEnd(precision, "0")) : 0;
        if (!Number.isFinite(wholeNum) || !Number.isFinite(fracNum)) throw new Error("Amount must be numeric.");
        const minor = wholeNum * scale + fracNum;
        if (!Number.isSafeInteger(minor)) throw new Error("Amount is too large.");
        return neg ? -minor : minor;
      }

      function minorToMajor(minor, precision) {
        const n = Number(minor || 0);
        if (!Number.isFinite(n)) return 0;
        return n / (10 ** precision);
      }

      function fmtMinor(minor, precision) {
        const n = Number(minor || 0);
        if (!Number.isFinite(n)) return "";
        const scale = 10 ** precision;
        const sign = n < 0 ? "-" : "";
        const abs = Math.abs(Math.trunc(n));
        const whole = Math.floor(abs / scale);
        if (precision === 0) return sign + whole.toLocaleString();
        const frac = String(abs % scale).padStart(precision, "0");
        return sign + whole.toLocaleString() + "." + frac;
      }

      function accountingPartsFromMinor(minor, precision) {
        if (minor == null || minor === "") return null;
        const n = Number(minor);
        if (!Number.isFinite(n)) return null;
        const safePrecision = normalizePrecision(precision);
        const scale = 10 ** safePrecision;
        const absMinor = Math.abs(Math.trunc(n));
        const whole = Math.floor(absMinor / scale).toLocaleString();
        const frac = safePrecision > 0 ? String(absMinor % scale).padStart(safePrecision, "0") : "";
        return { negative: n < 0, whole: whole, frac: frac, precision: safePrecision };
      }

      function accountingPartsFromMajor(major, precision) {
        const n = Number(major);
        if (!Number.isFinite(n)) return null;
        const safePrecision = normalizePrecision(precision);
        const absFixed = Math.abs(n).toFixed(safePrecision);
        const parts = absFixed.split(".");
        const wholeNum = Number(parts[0] || "0");
        return { negative: n < 0, whole: wholeNum.toLocaleString(), frac: parts[1] || "", precision: safePrecision };
      }

      function amountCellMarkupFromParts(parts, titleText) {
        if (!parts) return "";
        const signLeft = parts.negative ? "(" : "\u00A0";
        const signRight = parts.negative ? ")" : "\u00A0";
        const dot = parts.precision > 0 ? "." : "\u00A0";
        const frac = parts.precision > 0 ? parts.frac : "";
        return '<span class="amountCell" title="' + escapeHtml(titleText || "") + '"><span class="amountParts" style="--frac-width:' + parts.precision + 'ch;"><span class="amountSign">' + escapeHtml(signLeft) + '</span><span class="amountWhole">' + escapeHtml(parts.whole) + '</span><span class="amountDot">' + escapeHtml(dot) + '</span><span class="amountFrac">' + escapeHtml(frac) + '</span><span class="amountClose">' + escapeHtml(signRight) + "</span></span></span>";
      }

      function amountCellMarkupFromMinor(minor, precision) {
        const parts = accountingPartsFromMinor(minor, precision);
        return amountCellMarkupFromParts(parts, fmtMinor(minor, precision));
      }

      function amountCellMarkupFromMajor(major, precision) {
        const parts = accountingPartsFromMajor(major, precision);
        if (!parts) return "";
        const title = (parts.negative ? "-" : "") + parts.whole + (parts.precision > 0 ? "." + parts.frac : "");
        return amountCellMarkupFromParts(parts, title);
      }

      function parseTxnMeta(metaRaw) {
        if (!metaRaw || typeof metaRaw !== "object" || Array.isArray(metaRaw)) return {};
        return Object.assign({}, metaRaw);
      }

      function parseRecurrenceRuleSubset(ruleRaw) {
        const raw = String(ruleRaw || "").trim();
        if (!raw) return null;
        const parts = raw.split(";").map((p) => p.trim()).filter(Boolean);
        const fields = {};
        parts.forEach((part) => {
          const idx = part.indexOf("=");
          if (idx < 1) return;
          const key = part.slice(0, idx).trim().toUpperCase();
          const value = part.slice(idx + 1).trim();
          if (!key) return;
          fields[key] = value;
        });
        const freq = String(fields.FREQ || "").toUpperCase();
        if (freq !== "DAILY" && freq !== "MONTHLY") return null;
        const interval = Number(fields.INTERVAL);
        if (!Number.isInteger(interval) || interval < 1) return null;
        const untilRaw = String(fields.UNTIL || "").trim();
        const until = untilRaw ? untilRaw.slice(0, 10) : "";
        if (until && !validYmd(until)) return null;
        return {
          freq: freq,
          interval: interval,
          until: until,
          rrule: buildRecurrenceRuleSubset(freq, interval, until)
        };
      }

      function buildRecurrenceRuleSubset(freq, interval, until) {
        const safeFreq = String(freq || "").toUpperCase() === "MONTHLY" ? "MONTHLY" : "DAILY";
        const rawInterval = Number(interval);
        const safeInterval = Number.isInteger(rawInterval) && rawInterval > 0 ? rawInterval : 1;
        const safeUntil = String(until || "").trim();
        const out = ["FREQ=" + safeFreq, "INTERVAL=" + safeInterval];
        if (safeUntil) out.push("UNTIL=" + safeUntil);
        return out.join(";");
      }

      function recurrenceFromTxnMeta(metaRaw) {
        const meta = parseTxnMeta(metaRaw);
        const recObj = meta.recurrence && typeof meta.recurrence === "object" && !Array.isArray(meta.recurrence)
          ? meta.recurrence
          : null;

        const ruleCandidates = [
          recObj && recObj.rrule,
          meta.recurrence_rrule,
          meta.rrule
        ];
        for (const candidate of ruleCandidates) {
          const parsed = parseRecurrenceRuleSubset(candidate);
          if (parsed) return parsed;
        }

        if (!recObj) return null;
        const freq = String(recObj.freq || "").toUpperCase();
        const interval = Number(recObj.interval);
        const untilRaw = String(recObj.until || "").trim();
        const until = untilRaw ? untilRaw.slice(0, 10) : "";
        if ((freq !== "DAILY" && freq !== "MONTHLY") || !Number.isInteger(interval) || interval < 1) return null;
        if (until && !validYmd(until)) return null;
        return {
          freq: freq,
          interval: interval,
          until: until,
          rrule: buildRecurrenceRuleSubset(freq, interval, until)
        };
      }

      function recurrenceLabel(rec) {
        if (!rec) return "";
        const unit = rec.freq === "MONTHLY" ? "month" : "day";
        const n = Number(rec.interval || 1);
        const every = "every " + n + " " + unit + (n === 1 ? "" : "s");
        return rec.until ? (every + " until " + rec.until) : every;
      }

      function recurrenceTagMarkupFromTxn(txn) {
        const rec = recurrenceFromTxnMeta(txn && txn.meta);
        if (!rec) return "";
        const shortUnit = rec.freq === "MONTHLY" ? "mo" : "d";
        const short = "R q" + rec.interval + shortUnit + (rec.until ? " to " + rec.until : "");
        const title = "Recurs " + recurrenceLabel(rec) + " (" + rec.rrule + ")";
        return '<span class="recurrenceTag" title="' + escapeHtml(title) + '">' + escapeHtml(short) + "</span>";
      }

      function memoCellMarkup(txn) {
        const memo = escapeHtml((txn && txn.memo) || "");
        const recurrenceTag = recurrenceTagMarkupFromTxn(txn);
        if (!recurrenceTag) return memo;
        return memo ? (memo + " " + recurrenceTag) : recurrenceTag;
      }

      function txnEntriesInView(txnId) {
        const id = String(txnId || "");
        if (!id) return [];
        return state.entries.filter((e) => String((e && e.txn) || "") === id);
      }

      function isScheduledTxnInView(txnId) {
        const rows = txnEntriesInView(txnId);
        return rows.length > 0 && rows.every((e) => String((e && e.status) || "") === "scheduled");
      }

      function setStatus(kind, message) {
        const box = $("#statusBox");
        box.className = "status" + (kind ? " " + kind : "");
        box.textContent = message;
      }

      function classifyError(err) {
        if (!err || typeof err !== "object") return { kind: "bad", message: String(err || "Unknown error") };
        if (err.kind === "network") return { kind: "bad", message: "Network error: check URL, protocol (http/https), host, and CORS." };
        if (err.kind === "auth") return { kind: "bad", message: "Auth failure: session expired or credentials/token were rejected." };
        if (err.kind === "query") return { kind: "warn", message: "Query/schema mismatch (HTTP 400): fallback query was used." };
        return { kind: "bad", message: err.message || "Request failed." };
      }

      async function pbFetch(path, options) {
        if (!SESSION.base) {
          const e = new Error("PocketBase URL is required.");
          e.kind = "auth";
          throw e;
        }

        const headers = Object.assign({ "Content-Type": "application/json" }, (options && options.headers) || {});
        if (SESSION.token) headers["Authorization"] = /^Bearer\s+/i.test(SESSION.token) ? SESSION.token : ("Bearer " + SESSION.token);

        let res;
        try {
          res = await fetch(SESSION.base + path, Object.assign({}, options || {}, { headers }));
        } catch (error) {
          const e = new Error("Network error (fetch failed): " + (error && error.message ? error.message : String(error)));
          e.kind = "network";
          throw e;
        }

        const text = await res.text();
        let data = null;
        try { data = text ? JSON.parse(text) : null; } catch { data = text; }

        if (!res.ok) {
          const e = new Error("HTTP " + res.status + ": " + (typeof data === "string" ? data : JSON.stringify(data || {})));
          e.status = res.status;
          if (res.status === 401 || res.status === 403) e.kind = "auth";
          else if (res.status === 400) e.kind = "query";
          else e.kind = "bad";
          throw e;
        }

        return data;
      }

      function toQS(params) {
        return Object.keys(params)
          .filter((k) => params[k] !== "" && params[k] != null)
          .map((k) => encodeURIComponent(k) + "=" + encodeURIComponent(params[k]))
          .join("&");
      }

      async function listRecordsPageSafe(collection, opts) {
        const options = opts || {};
        const perPage = options.perPage || 200;
        const page = options.page || 1;

        const attemptOne = {
          page: page,
          perPage: perPage,
          filter: options.filter || "",
          sort: options.sort || "",
          expand: options.expand || ""
        };
        const attemptTwo = {
          page: page,
          perPage: perPage,
          sort: options.sort || "",
          expand: options.expand || ""
        };
        const attemptThree = { page: page, perPage: perPage };

        async function runAttempt(q) {
          const qs = toQS(q);
          const data = await pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records?" + qs, { method: "GET" });
          return {
            items: (data && data.items) ? data.items : [],
            page: Math.max(1, Number((data && data.page) || page)),
            perPage: Math.max(1, Number((data && data.perPage) || perPage)),
            totalPages: Math.max(1, Number((data && data.totalPages) || 1)),
            totalItems: Math.max(0, Number((data && data.totalItems) || 0))
          };
        }

        try {
          return await runAttempt(attemptOne);
        } catch (e1) {
          if (e1 && e1.status === 400) {
            try {
              setStatus("warn", "Adjusted listing query after HTTP 400 (schema/filter mismatch). Loaded with fewer filters.");
              return await runAttempt(attemptTwo);
            } catch (e2) {
              if (e2 && e2.status === 400) {
                setStatus("warn", "Adjusted listing query again after HTTP 400. Loaded with no filter/sort constraints.");
                return await runAttempt(attemptThree);
              }
              throw e2;
            }
          }
          throw e1;
        }
      }

      async function listRecordsSafe(collection, opts) {
        const options = Object.assign({}, opts || {});
        const perPage = options.perPage || 200;
        const first = await listRecordsPageSafe(collection, Object.assign({}, options, { page: 1, perPage: perPage }));
        const all = (first.items || []).slice();
        let page = 2;
        while (page <= first.totalPages) {
          const next = await listRecordsPageSafe(collection, Object.assign({}, options, { page: page, perPage: perPage }));
          all.push(...(next.items || []));
          page += 1;
        }
        return all;
      }

      async function createRecord(collection, body) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records", {
          method: "POST",
          body: JSON.stringify(body)
        });
      }

      async function updateRecord(collection, id, body) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records/" + encodeURIComponent(id), {
          method: "PATCH",
          body: JSON.stringify(body)
        });
      }

      async function getRecord(collection, id) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records/" + encodeURIComponent(id), { method: "GET" });
      }

      async function deleteRecord(collection, id) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records/" + encodeURIComponent(id), { method: "DELETE" });
      }

      async function authWithPassword(email, password) {
        return pbFetch("/api/collections/users/auth-with-password", {
          method: "POST",
          body: JSON.stringify({ identity: email, password: password })
        });
      }

      async function authRefresh() {
        return pbFetch("/api/collections/users/auth-refresh", { method: "POST" });
      }

      function setAuthenticatedUI(isLoggedIn) {
        $("#authPanel").style.display = isLoggedIn ? "none" : "flex";
        $("#logoutLink").style.display = isLoggedIn ? "inline" : "none";
        $("#app").style.display = isLoggedIn ? "block" : "none";
      }

      function setBusy() {
        const editing = !!state.editingTxnId;
        const modalOpen = !!state.recurrenceModalOpen;
        const disabled = !SESSION.token || state.loading || state.saving || state.deleting || state.modalBusy || editing || modalOpen;
        ["#btnRefresh", "#btnNewTxn", "#btnLogin"].forEach((sel) => {
          const el = $(sel);
          if (el) el.disabled = disabled && sel !== "#btnLogin";
        });
        ["#fltFrom", "#fltTo", "#fltAccount", "#fltCategory", "#fltPayee", "#fltStatus", "#fltBudgetOnly"].forEach((sel) => {
          const el = $(sel);
          if (el) el.disabled = disabled;
        });
        const canDelete = !!SESSION.token
          && state.selectedTxnIds.length > 0
          && !state.loading
          && !state.saving
          && !state.deleting
          && !state.modalBusy
          && !editing
          && !modalOpen;
        $("#btnDeleteTxn").disabled = !canDelete;
        const recurrenceBtn = $("#btnRecurrence");
        if (recurrenceBtn) {
          const selectedTxnId = state.selectedTxnIds.length === 1 ? state.selectedTxnIds[0] : "";
          const canEditRecurrence = !!SESSION.token
            && !!selectedTxnId
            && !state.loading
            && !state.saving
            && !state.deleting
            && !state.modalBusy
            && !editing
            && !modalOpen
            && isScheduledTxnInView(selectedTxnId);
          recurrenceBtn.disabled = !canEditRecurrence;
        }
        const btnEditSave = $("#btnEditSave");
        const btnEditCancel = $("#btnEditCancel");
        const btnEditAddEntry = $("#btnEditAddEntry");
        const canAddSplitFromTop = editing
          && state.editDraft
          && Array.isArray(state.editDraft.entries)
          && state.editDraft.entries.length <= 1;
        if (btnEditAddEntry) btnEditAddEntry.style.display = canAddSplitFromTop ? "inline-flex" : "none";
        if (btnEditAddEntry) btnEditAddEntry.disabled = !canAddSplitFromTop || state.saving || state.loading || state.deleting;
        if (btnEditSave) btnEditSave.style.display = editing ? "inline-flex" : "none";
        if (btnEditCancel) btnEditCancel.style.display = editing ? "inline-flex" : "none";
        if (btnEditSave) btnEditSave.disabled = !editing || state.saving || state.loading || state.deleting;
        if (btnEditCancel) btnEditCancel.disabled = !editing || state.saving || state.loading || state.deleting;
        $("#btnPrevPage").disabled = disabled || state.page <= 1;
        $("#btnNextPage").disabled = disabled || state.page >= state.totalPages;
        $("#perPage").disabled = disabled;

        const modalHidden = !state.recurrenceModalOpen;
        const modalDisabled = modalHidden || state.modalBusy;
        if ($("#recFreq")) $("#recFreq").disabled = modalDisabled;
        if ($("#recInterval")) $("#recInterval").disabled = modalDisabled;
        if ($("#recUntil")) $("#recUntil").disabled = modalDisabled;
        if ($("#btnRecurrenceSave")) $("#btnRecurrenceSave").disabled = modalDisabled;
        if ($("#btnRecurrenceCancel")) $("#btnRecurrenceCancel").disabled = modalDisabled;
        if ($("#btnRecurrenceClear")) $("#btnRecurrenceClear").disabled = modalDisabled || !state.recurrenceModalHasExisting;
      }

      function recurrencePreviewText() {
        const freqSel = $("#recFreq");
        const intervalInput = $("#recInterval");
        const untilInput = $("#recUntil");
        if (!freqSel || !intervalInput || !untilInput) return "";
        const freq = String(freqSel.value || "DAILY").toUpperCase() === "MONTHLY" ? "MONTHLY" : "DAILY";
        const n = Number(intervalInput.value);
        const interval = Number.isInteger(n) && n > 0 ? n : 1;
        const until = String(untilInput.value || "").trim();
        return buildRecurrenceRuleSubset(freq, interval, until);
      }

      function updateRecurrencePreview() {
        const box = $("#recurrencePreview");
        if (!box) return;
        box.textContent = "RRULE preview: " + recurrencePreviewText();
      }

      function closeRecurrenceModal() {
        state.recurrenceModalOpen = false;
        state.recurrenceModalTxnId = "";
        state.recurrenceModalHasExisting = false;
        const modal = $("#recurrenceModal");
        if (modal) {
          modal.style.display = "none";
          modal.setAttribute("aria-hidden", "true");
        }
        setBusy();
      }

      async function openRecurrenceModalForSelection() {
        if (!SESSION.token) return;
        if (state.loading || state.saving || state.deleting || state.modalBusy || state.editingTxnId) return;
        if (state.selectedTxnIds.length !== 1) {
          setStatus("warn", "Select exactly one transaction to edit recurrence.");
          return;
        }
        const txnId = String(state.selectedTxnIds[0] || "");
        if (!txnId) return;
        if (!isScheduledTxnInView(txnId)) {
          setStatus("warn", "Recurrence is only available for transactions where all visible entries are scheduled.");
          return;
        }

        const modal = $("#recurrenceModal");
        if (!modal) return;

        try {
          state.modalBusy = true;
          setBusy();
          const txn = await getRecord("txns", txnId);
          if (txn && txn.id) state.txns.set(String(txn.id), txn);
          const txnEntries = await listRecordsSafe("entries", {
            filter: 'txn = "' + txnId.replaceAll('"', '\\"') + '"',
            perPage: 500,
            sort: "-date"
          });
          if (!txnEntries.length || txnEntries.some((e) => String((e && e.status) || "") !== "scheduled")) {
            throw new Error("Recurrence is only available when all entries in the transaction are scheduled.");
          }
          const rec = recurrenceFromTxnMeta(txn && txn.meta);
          const txnDate = fmtDate(txn && txn.date);
          const payee = payeeDisplayName(txn && txn.payee);
          $("#recurrenceTxnLabel").textContent = "Transaction " + txnId + (txnDate ? (" | " + txnDate) : "") + (payee ? (" | " + payee) : "");
          $("#recFreq").value = rec ? rec.freq : "DAILY";
          $("#recInterval").value = String(rec ? rec.interval : 1);
          $("#recUntil").value = rec && rec.until ? rec.until : "";
          state.recurrenceModalTxnId = txnId;
          state.recurrenceModalOpen = true;
          state.recurrenceModalHasExisting = !!rec;
          modal.style.display = "flex";
          modal.setAttribute("aria-hidden", "false");
          updateRecurrencePreview();
          setStatus("warn", "Set recurrence for scheduled transaction " + txnId + ".");
        } catch (err) {
          const info = classifyError(err);
          setStatus(info.kind, "Failed to open recurrence editor: " + (err && err.message ? err.message : info.message));
        } finally {
          state.modalBusy = false;
          setBusy();
        }
      }

      async function saveRecurrenceFromModal() {
        const txnId = String(state.recurrenceModalTxnId || "");
        if (!SESSION.token || !txnId || !state.recurrenceModalOpen) return;
        const freq = String(($("#recFreq") && $("#recFreq").value) || "").toUpperCase();
        const intervalRaw = Number(($("#recInterval") && $("#recInterval").value) || "");
        const until = String(($("#recUntil") && $("#recUntil").value) || "").trim();
        if (freq !== "DAILY" && freq !== "MONTHLY") {
          setStatus("bad", "Recurrence save failed: frequency must be DAILY or MONTHLY.");
          return;
        }
        if (!Number.isInteger(intervalRaw) || intervalRaw < 1) {
          setStatus("bad", "Recurrence save failed: interval must be a whole number >= 1.");
          return;
        }
        if (until && !validYmd(until)) {
          setStatus("bad", "Recurrence save failed: UNTIL must be YYYY-MM-DD.");
          return;
        }
        const recurrence = {
          freq: freq,
          interval: intervalRaw,
          until: until,
          rrule: buildRecurrenceRuleSubset(freq, intervalRaw, until)
        };

        try {
          state.modalBusy = true;
          setBusy();
          const currentTxn = state.txns.get(txnId) || await getRecord("txns", txnId);
          const meta = parseTxnMeta(currentTxn && currentTxn.meta);
          meta.recurrence = {
            freq: recurrence.freq,
            interval: recurrence.interval,
            until: recurrence.until || null,
            rrule: recurrence.rrule
          };
          delete meta.recurrence_rrule;
          delete meta.rrule;
          await updateRecord("txns", txnId, { meta: meta });
          if (currentTxn && currentTxn.id) {
            state.txns.set(txnId, Object.assign({}, currentTxn, { meta: meta }));
          }
          closeRecurrenceModal();
          renderRegister();
          setStatus("ok", "Recurrence saved: " + recurrence.rrule);
        } catch (err) {
          const info = classifyError(err);
          setStatus(info.kind, "Recurrence save failed: " + (err && err.message ? err.message : info.message));
        } finally {
          state.modalBusy = false;
          setBusy();
        }
      }

      async function clearRecurrenceFromModal() {
        const txnId = String(state.recurrenceModalTxnId || "");
        if (!SESSION.token || !txnId || !state.recurrenceModalOpen) return;

        try {
          state.modalBusy = true;
          setBusy();
          const currentTxn = state.txns.get(txnId) || await getRecord("txns", txnId);
          const meta = parseTxnMeta(currentTxn && currentTxn.meta);
          delete meta.recurrence;
          delete meta.recurrence_rrule;
          delete meta.rrule;
          await updateRecord("txns", txnId, { meta: meta });
          if (currentTxn && currentTxn.id) {
            state.txns.set(txnId, Object.assign({}, currentTxn, { meta: meta }));
          }
          closeRecurrenceModal();
          renderRegister();
          setStatus("ok", "Recurrence cleared for transaction " + txnId + ".");
        } catch (err) {
          const info = classifyError(err);
          setStatus(info.kind, "Failed to clear recurrence: " + (err && err.message ? err.message : info.message));
        } finally {
          state.modalBusy = false;
          setBusy();
        }
      }

      function refillFilterSelect(selId, list, placeholder, labelFn) {
        const sel = $(selId);
        const current = sel.value;
        sel.innerHTML = '<option value="">' + escapeHtml(placeholder) + '</option>' + list.map((item) => '<option value="' + escapeHtml(item.id) + '">' + escapeHtml(labelFn(item)) + '</option>').join("");
        sel.value = current;
      }

      function refillPayeeFilterSuggestions() {
        const datalist = $("#payeeFilterSuggestions");
        if (!datalist) return;
        datalist.innerHTML = state.payees
          .map((p) => String((p && p.name) || "").trim())
          .filter(Boolean)
          .sort((a, b) => a.localeCompare(b))
          .map((name) => '<option value="' + escapeHtml(name) + '"></option>')
          .join("");
      }

      function findPayeeIdsByName(rawQuery) {
        const q = String(rawQuery == null ? "" : rawQuery).trim().toLowerCase();
        if (!q) return [];
        return state.payees
          .filter((p) => String((p && p.name) || "").toLowerCase().includes(q))
          .map((p) => String((p && p.id) || ""))
          .filter(Boolean);
      }

      function buildEntriesFilter() {
        const out = [];
        const account = $("#fltAccount").value;
        const payee = $("#fltPayee").value;
        const category = $("#fltCategory").value;
        const status = $("#fltStatus").value;
        const from = $("#fltFrom").value;
        const to = $("#fltTo").value;

        if (account) out.push('account = "' + account.replaceAll('"', '\\"') + '"');
        if (payee) {
          const payeeIds = findPayeeIdsByName(payee);
          if (!payeeIds.length) {
            out.push('txn.payee = "__no_payee_name_match__"');
          } else {
            out.push("(" + payeeIds.map((id) => 'txn.payee = "' + id.replaceAll('"', '\\"') + '"').join(" || ") + ")");
          }
        }
        if (category) out.push('category = "' + category.replaceAll('"', '\\"') + '"');
        if (status) out.push('status = "' + status.replaceAll('"', '\\"') + '"');
        if (from) out.push('date >= "' + normalizeDateToNoonUtc(from) + '"');
        if (to) out.push('date <= "' + normalizeDateToNoonUtc(to) + '"');
        return out.join(" && ");
      }

      function filteredClientSide(entries) {
        const budgetOnly = $("#fltBudgetOnly").value === "1";
        if (!budgetOnly) return entries;

        return entries.filter((e) => {
          const c = getCategoryById(e.category);
          const a = getAccountById(e.account);
          if (!c || !a) return false;
          return (c.kind === "income" || c.kind === "expense") && a.type !== "virtual";
        });
      }

      async function loadReferenceData() {
        const [accounts, assets, categories, payees] = await Promise.all([
          listRecordsSafe("accounts", { filter: "is_archived = false", sort: "name", perPage: 500 }),
          listRecordsSafe("assets", { sort: "symbol", perPage: 500 }),
          listRecordsSafe("categories", { filter: "is_archived = false", sort: "name", perPage: 500 }),
          listRecordsSafe("payees", { filter: "is_archived = false", sort: "name", perPage: 500 })
        ]);
        state.accounts = accounts;
        state.accountById = new Map(state.accounts.map((a) => [String(a.id), a]));
        state.assets = assets;
        state.assetPrecisionById = new Map(state.assets.map((a) => [String(a.id), normalizePrecision(a.precision)]));
        state.categories = categories;
        state.categoryById = new Map(state.categories.map((c) => [String(c.id), c]));
        state.payees = payees;
        state.payeeById = new Map(state.payees.map((p) => [String(p.id), p]));

        refillFilterSelect("#fltAccount", state.accounts, "(all accounts)", (a) => accountLabel(a, false));
        refillFilterSelect("#fltCategory", state.categories, "(all categories)", (c) => categoryLabel(c, false));
        refillPayeeFilterSuggestions();
      }

      async function loadRegister() {
        const entriesFilter = buildEntriesFilter();
        let entriesRes = await listRecordsPageSafe("entries", {
          filter: entriesFilter,
          sort: registerServerSortExpr(),
          perPage: state.perPage,
          page: state.page
        });
        if (state.page > entriesRes.totalPages) {
          state.page = entriesRes.totalPages;
          entriesRes = await listRecordsPageSafe("entries", {
            filter: entriesFilter,
            sort: registerServerSortExpr(),
            perPage: state.perPage,
            page: state.page
          });
        }
        state.totalPages = entriesRes.totalPages;
        state.totalItems = entriesRes.totalItems;
        updateRegisterPageInfo();

        const entries = entriesRes.items || [];
        await ensureAccountsLoaded(entries.map((e) => e && e.account));
        await ensureCategoriesLoaded(entries.map((e) => e && e.category));

        const filtered = filteredClientSide(entries);
        filtered.forEach((e) => {
          parseMinorInt(e && e.qty, "entries.qty");
        });
        state.entries = filtered;
        state.txns = new Map();
        await backfillMissingLinkedTxns(state.entries);
        await ensurePayeesLoaded(Array.from(state.txns.values()).map((t) => t && t.payee));

        renderRegister();
      }

      async function backfillMissingLinkedTxns(entries) {
        const missingIds = Array.from(new Set(
          (entries || [])
            .map((e) => String(e && e.txn ? e.txn : ""))
            .filter((txnId) => txnId && !state.txns.has(txnId))
        ));
        if (!missingIds.length) return;

        const batchSize = 25;
        for (let i = 0; i < missingIds.length; i += batchSize) {
          const batch = missingIds.slice(i, i + batchSize);
          const rows = await Promise.all(batch.map(async (txnId) => {
            try {
              return await getRecord("txns", txnId);
            } catch {
              return null;
            }
          }));
          rows.forEach((txn) => {
            if (txn && txn.id) state.txns.set(txn.id, txn);
          });
        }
      }

      function fieldOrNull(v) {
        const s = String(v == null ? "" : v).trim();
        return s ? s : null;
      }

      function accountLabel(account, includeArchivedTag) {
        const base = (account && (account.name || account.id)) || "";
        const type = (account && account.type) || "other";
        const archivedTag = includeArchivedTag && account && account.is_archived ? " [archived]" : "";
        return base + " (" + type + ")" + archivedTag;
      }

      function categoryLabel(category, includeArchivedTag) {
        const base = (category && (category.name || category.id)) || "";
        const kind = (category && category.kind) || "other";
        const archivedTag = includeArchivedTag && category && category.is_archived ? " [archived]" : "";
        return base + " [" + kind + "]" + archivedTag;
      }

      function payeeLabel(payee, includeArchivedTag) {
        const base = (payee && (payee.name || payee.id)) || "";
        const card = payee && payee.card_category ? " {" + payee.card_category + "}" : "";
        const archivedTag = includeArchivedTag && payee && payee.is_archived ? " [archived]" : "";
        return base + card + archivedTag;
      }

      function getAccountById(accountId) {
        return state.accountById.get(String(accountId || "")) || null;
      }

      function accountDisplayName(accountId) {
        const a = getAccountById(accountId);
        return (a && (a.name || a.id)) || String(accountId || "");
      }

      function getCategoryById(categoryId) {
        return state.categoryById.get(String(categoryId || "")) || null;
      }

      function categoryDisplayName(categoryId) {
        const c = getCategoryById(categoryId);
        return (c && (c.name || c.id)) || String(categoryId || "");
      }

      function getPayeeById(payeeId) {
        return state.payeeById.get(String(payeeId || "")) || null;
      }

      function payeeDisplayName(payeeId) {
        const p = getPayeeById(payeeId);
        return (p && (p.name || p.id)) || String(payeeId || "");
      }

      function getEntryAssetId(entry) {
        return String((entry && entry.asset) || "");
      }

      function qtyMajorForEntry(entry) {
        const precision = assetPrecision(getEntryAssetId(entry));
        return minorToMajor(parseMinorInt(entry && entry.qty, "entries.qty"), precision);
      }

      function entryStatusValues() {
        return ENTRY_STATUS_OPTIONS.map((s) => s.value);
      }

      function entryStatusOptionByValue(value) {
        const key = String(value || "");
        return ENTRY_STATUS_OPTIONS.find((s) => s.value === key) || null;
      }

      function entryStatusEmoji(value) {
        const found = entryStatusOptionByValue(value);
        return found ? found.emoji : "\u2753";
      }

      function entryStatusLabel(value) {
        const found = entryStatusOptionByValue(value);
        return found ? found.label : (String(value || "") || "unknown");
      }

      function nextEntryStatusValue(currentValue) {
        const current = String(currentValue || "");
        if (current === "scheduled") return "pending";
        if (current === "pending") return "cleared";
        if (current === "cleared") return "pending";
        const values = entryStatusValues();
        return values.length ? values[0] : current;
      }

      function parseYmdToUtcDate(ymd) {
        if (!validYmd(ymd)) return null;
        const d = new Date(ymd + "T00:00:00Z");
        if (isNaN(d.getTime())) return null;
        return d;
      }

      function ymdFromUtcDate(dateObj) {
        if (!(dateObj instanceof Date) || isNaN(dateObj.getTime())) return "";
        return dateObj.toISOString().slice(0, 10);
      }

      function addMonthsClamped(ymd, monthsToAdd) {
        const src = parseYmdToUtcDate(ymd);
        const delta = Number(monthsToAdd || 0);
        if (!src || !Number.isInteger(delta)) return "";
        const year = src.getUTCFullYear();
        const month = src.getUTCMonth();
        const day = src.getUTCDate();
        const firstOfTarget = new Date(Date.UTC(year, month + delta, 1));
        const targetYear = firstOfTarget.getUTCFullYear();
        const targetMonth = firstOfTarget.getUTCMonth();
        const lastOfTarget = new Date(Date.UTC(targetYear, targetMonth + 1, 0)).getUTCDate();
        const clampedDay = Math.min(day, lastOfTarget);
        return ymdFromUtcDate(new Date(Date.UTC(targetYear, targetMonth, clampedDay)));
      }

      function nextRecurrenceDateYmd(currentYmd, rec) {
        const safeCurrent = String(currentYmd || "").slice(0, 10);
        if (!validYmd(safeCurrent) || !rec) return "";
        const interval = Number(rec.interval || 1);
        if (!Number.isInteger(interval) || interval < 1) return "";
        if (String(rec.freq || "").toUpperCase() === "MONTHLY") {
          return addMonthsClamped(safeCurrent, interval);
        }
        const src = parseYmdToUtcDate(safeCurrent);
        if (!src) return "";
        src.setUTCDate(src.getUTCDate() + interval);
        return ymdFromUtcDate(src);
      }

      function stripTxnRecurrenceMeta(metaRaw) {
        const meta = parseTxnMeta(metaRaw);
        delete meta.recurrence;
        delete meta.recurrence_rrule;
        delete meta.rrule;
        return meta;
      }

      async function applyScheduledRecurrenceForTxn(txnId) {
        const id = String(txnId || "");
        if (!id) return;
        const txn = state.txns.get(id);
        if (!txn) throw new Error("Transaction not found in current view.");
        const rec = recurrenceFromTxnMeta(txn.meta);
        if (!rec) throw new Error("No recurrence rule found on scheduled transaction.");
        const txnDateYmd = fmtDate(txn.date);
        if (!validYmd(txnDateYmd)) throw new Error("Scheduled transaction has an invalid date.");

        const txnEntries = txnEntriesInView(id);
        if (!txnEntries.length) throw new Error("Scheduled transaction has no entries.");

        const newTxn = await createRecord("txns", {
          date: txn.date,
          payee: txn.payee || null,
          memo: txn.memo || "",
          source: txn.source || "",
          meta: stripTxnRecurrenceMeta(txn.meta)
        });

        for (const entry of txnEntries) {
          await createRecord("entries", {
            txn: newTxn.id,
            date: txn.date,
            account: entry.account,
            category: entry.category || null,
            asset: entry.asset,
            qty: entry.qty,
            memo: entry.memo || "",
            status: "pending",
            meta: parseTxnMeta(entry.meta)
          });
        }

        const nextDateYmd = nextRecurrenceDateYmd(txnDateYmd, rec);
        if (!validYmd(nextDateYmd)) throw new Error("Failed to compute the next recurrence date.");
        const until = String(rec.until || "").trim();
        if (until && nextDateYmd > until) {
          for (const entry of txnEntries) {
            await deleteRecord("entries", entry.id);
          }
          await deleteRecord("txns", id);
          return "Applied recurrence and removed template transaction (next date past UNTIL).";
        }

        const nextDateIso = normalizeDateToNoonUtc(nextDateYmd);
        await updateRecord("txns", id, { date: nextDateIso });
        for (const entry of txnEntries) {
          await updateRecord("entries", entry.id, {
            date: nextDateIso,
            status: "scheduled"
          });
        }
        return "Applied recurrence; created pending copy and advanced scheduled template.";
      }

      function statusSelectOptionsMarkup(selectedValue) {
        const selected = String(selectedValue || "");
        const knownValues = new Set(entryStatusValues());
        const options = [];
        if (selected && !knownValues.has(selected)) {
          options.push('<option value="' + escapeHtml(selected) + '" selected>' + escapeHtml(selected) + "</option>");
        }
        options.push(...ENTRY_STATUS_OPTIONS.map((s) => {
          return '<option value="' + escapeHtml(s.value) + '"' + (s.value === selected ? " selected" : "") + ">" + escapeHtml(s.label) + "</option>";
        }));
        return options.join("");
      }

      function refillStatusFilterSelect() {
        const sel = $("#fltStatus");
        if (!sel) return;
        const current = String(sel.value || "");
        sel.innerHTML = '<option value="">(any)</option>' + ENTRY_STATUS_OPTIONS
          .map((s) => '<option value="' + escapeHtml(s.value) + '">' + escapeHtml(s.emoji + " " + s.label) + "</option>")
          .join("");
        sel.value = entryStatusValues().includes(current) ? current : "";
      }

      function statusCellButtonMarkup(entryId, statusValue) {
        const current = String(statusValue || "");
        const title = entryStatusLabel(current);
        return '<button type="button" class="statusCycleBtn" data-status-cycle="1" data-entry-id="' + escapeHtml(String(entryId || "")) + '" title="' + escapeHtml(title + " (click to cycle)") + '" aria-label="' + escapeHtml("Status: " + title + ". Click to cycle.") + '">' + escapeHtml(entryStatusEmoji(current)) + "</button>";
      }

      function editableAccountOptions(selectedAccountId) {
        const selectedId = String(selectedAccountId || "");
        if (!selectedId) return state.accounts.slice();
        if (state.accounts.some((a) => String(a.id) === selectedId)) return state.accounts.slice();
        const selected = getAccountById(selectedId);
        if (!selected) return state.accounts.slice();
        return state.accounts.concat([selected]);
      }

      function editableCategoryOptions(selectedCategoryId) {
        const selectedId = String(selectedCategoryId || "");
        if (!selectedId) return state.categories.slice();
        if (state.categories.some((c) => String(c.id) === selectedId)) return state.categories.slice();
        const selected = getCategoryById(selectedId);
        if (!selected) return state.categories.slice();
        return state.categories.concat([selected]);
      }

      function editablePayeeOptions(selectedPayeeId) {
        const selectedId = String(selectedPayeeId || "");
        if (!selectedId) return state.payees.slice();
        if (state.payees.some((p) => String(p.id) === selectedId)) return state.payees.slice();
        const selected = getPayeeById(selectedId);
        if (!selected) return state.payees.slice();
        return state.payees.concat([selected]);
      }

      async function ensureAccountsLoaded(accountIds) {
        const missingIds = Array.from(new Set(
          (accountIds || [])
            .map((id) => String(id || ""))
            .filter((id) => id && !state.accountById.has(id))
        ));
        if (!missingIds.length) return;

        const batchSize = 25;
        for (let i = 0; i < missingIds.length; i += batchSize) {
          const batch = missingIds.slice(i, i + batchSize);
          const rows = await Promise.all(batch.map(async (accountId) => {
            try {
              return await getRecord("accounts", accountId);
            } catch {
              return null;
            }
          }));
          rows.forEach((account) => {
            if (account && account.id) state.accountById.set(String(account.id), account);
          });
        }
      }

      async function ensureCategoriesLoaded(categoryIds) {
        const missingIds = Array.from(new Set(
          (categoryIds || [])
            .map((id) => String(id || ""))
            .filter((id) => id && !state.categoryById.has(id))
        ));
        if (!missingIds.length) return;

        const batchSize = 25;
        for (let i = 0; i < missingIds.length; i += batchSize) {
          const batch = missingIds.slice(i, i + batchSize);
          const rows = await Promise.all(batch.map(async (categoryId) => {
            try {
              return await getRecord("categories", categoryId);
            } catch {
              return null;
            }
          }));
          rows.forEach((category) => {
            if (category && category.id) state.categoryById.set(String(category.id), category);
          });
        }
      }

      async function ensurePayeesLoaded(payeeIds) {
        const missingIds = Array.from(new Set(
          (payeeIds || [])
            .map((id) => String(id || ""))
            .filter((id) => id && !state.payeeById.has(id))
        ));
        if (!missingIds.length) return;

        const batchSize = 25;
        for (let i = 0; i < missingIds.length; i += batchSize) {
          const batch = missingIds.slice(i, i + batchSize);
          const rows = await Promise.all(batch.map(async (payeeId) => {
            try {
              return await getRecord("payees", payeeId);
            } catch {
              return null;
            }
          }));
          rows.forEach((payee) => {
            if (payee && payee.id) state.payeeById.set(String(payee.id), payee);
          });
        }
      }

      function optionList(items, selected, labelFn, includeBlank) {
        let html = "";
        if (includeBlank) html += '<option value=""></option>';
        html += items.map((item) => {
          const value = String(item.id);
          const isSel = String(selected || "") === value ? " selected" : "";
          return '<option value="' + escapeHtml(value) + '"' + isSel + '>' + escapeHtml(labelFn(item)) + "</option>";
        }).join("");
        return html;
      }

      function inlineLookupMarkup(items, selectedId, labelFn, dataEditKey, includeBlank, placeholder) {
        const normalizedSelectedId = String(selectedId || "");
        const options = [];
        if (includeBlank) options.push({ value: "", label: "" });
        (items || []).forEach((item) => {
          options.push({ value: String(item.id), label: labelFn(item) });
        });

        let selectedLabel = "";
        const selectedOpt = options.find((opt) => opt.value === normalizedSelectedId);
        if (selectedOpt) selectedLabel = selectedOpt.label;

        const optionHtml = options.map((opt) => {
          const display = opt.label || "(none)";
          const lower = display.toLocaleLowerCase();
          return '<button type="button" class="inlineLookupOption" data-lookup-static="1" data-lookup-value="' + escapeHtml(opt.value) + '" data-lookup-label="' + escapeHtml(lower) + '">' + escapeHtml(display) + "</button>";
        }).join("");
        const collection = dataEditKey === "entry-account"
          ? "accounts"
          : (dataEditKey === "entry-category"
            ? "categories"
            : (dataEditKey === "txn-payee" ? "payees" : ""));

        return [
          '<div class="inlineLookup" data-lookup-root="1" data-lookup-collection="' + escapeHtml(collection) + '">',
          '<input class="inlineInput" type="text" data-lookup-input="1" data-lookup-for="' + escapeHtml(dataEditKey) + '" value="' + escapeHtml(selectedLabel) + '" placeholder="' + escapeHtml(placeholder || "") + '" autocomplete="off" />',
          '<input type="hidden" data-edit="' + escapeHtml(dataEditKey) + '" value="' + escapeHtml(normalizedSelectedId) + '" />',
          '<div class="inlineLookupMenu" data-lookup-menu="1">',
          optionHtml,
          '<div class="inlineLookupEmpty">No matches</div>',
          "</div>",
          "</div>"
        ].join("");
      }

      function closeInlineLookups(except) {
        $$(".inlineLookup.open", $("#registerBody")).forEach((el) => {
          if (except && (el === except || el.contains(except))) return;
          el.classList.remove("open");
          el.removeAttribute("data-lookup-nav-ready");
        });
      }

      function normalizeLookupText(raw) {
        return String(raw == null ? "" : raw).trim().toLocaleLowerCase();
      }

      function encodeLookupCreateToken(collection, name) {
        return "__create__|" + String(collection || "") + "|" + encodeURIComponent(String(name || ""));
      }

      function parseLookupCreateToken(value) {
        const raw = String(value || "");
        if (!raw.startsWith("__create__|")) return null;
        const parts = raw.split("|");
        if (parts.length < 3) return null;
        return {
          collection: parts[1] || "",
          name: decodeURIComponent(parts.slice(2).join("|") || "")
        };
      }

      function fuzzyLookupScore(label, query) {
        if (!query) return 0;
        const text = normalizeLookupText(label);
        const term = normalizeLookupText(query);
        if (!text || !term) return 0;

        let qi = 0;
        let score = 0;
        let lastMatchAt = -2;
        let firstMatchAt = -1;
        let lastMatchPos = -1;

        for (let i = 0; i < text.length && qi < term.length; i += 1) {
          if (text[i] !== term[qi]) continue;
          if (firstMatchAt === -1) firstMatchAt = i;
          if (i === lastMatchAt + 1) score += 6;
          else score += 3;
          if (i === 0 || text[i - 1] === " " || text[i - 1] === "-" || text[i - 1] === "[" || text[i - 1] === "(") score += 2;
          lastMatchAt = i;
          lastMatchPos = i;
          qi += 1;
        }

        if (qi < term.length) return -1;
        const span = Math.max(0, lastMatchPos - firstMatchAt);
        score -= span * 0.08;
        score -= firstMatchAt * 0.12;
        return score;
      }

      function firstVisibleLookupOption(lookup) {
        return $$(".inlineLookupOption", lookup).find((btn) => btn.style.display !== "none") || null;
      }

      function visibleLookupOptions(lookup) {
        return $$(".inlineLookupOption", lookup).filter((btn) => btn.style.display !== "none");
      }

      function activeLookupOption(lookup) {
        const visible = visibleLookupOptions(lookup);
        return visible.find((btn) => btn.classList.contains("active")) || null;
      }

      function setActiveLookupOption(lookup, optionBtn) {
        const visible = visibleLookupOptions(lookup);
        visible.forEach((btn) => btn.classList.remove("active"));
        if (!optionBtn) return;
        optionBtn.classList.add("active");
        try { optionBtn.scrollIntoView({ block: "nearest" }); } catch {}
      }

      function moveActiveLookupOption(lookup, direction) {
        const visible = visibleLookupOptions(lookup);
        if (!visible.length) return null;
        const current = activeLookupOption(lookup);
        const idx = current ? visible.indexOf(current) : -1;
        let nextIdx = 0;
        if (idx === -1) nextIdx = direction > 0 ? 0 : visible.length - 1;
        else if (direction > 0) nextIdx = Math.min(visible.length - 1, idx + 1);
        else nextIdx = Math.max(0, idx - 1);
        const next = visible[nextIdx];
        setActiveLookupOption(lookup, next);
        return next;
      }

      function syncInlineLookupValue(lookup, rawOverride) {
        if (!lookup) return;
        const textInput = $('[data-lookup-input="1"]', lookup);
        const hidden = $('input[type="hidden"][data-edit]', lookup);
        if (!textInput || !hidden) return;
        const raw = normalizeLookupText(rawOverride == null ? textInput.value : rawOverride);
        if (!raw) {
          hidden.value = "";
          return;
        }
        const exact = $$(".inlineLookupOption[data-lookup-static=\"1\"]", lookup).find((btn) => (btn.getAttribute("data-lookup-label") || "") === raw);
        hidden.value = exact ? (exact.getAttribute("data-lookup-value") || "") : "";
      }

      function filterInlineLookupMenu(lookup, queryOverride) {
        if (!lookup) return;
        const textInput = $('[data-lookup-input="1"]', lookup);
        if (!textInput) return;
        const menu = $('[data-lookup-menu="1"]', lookup);
        if (!menu) return;
        const term = String(queryOverride == null ? textInput.value : queryOverride);
        const termNorm = normalizeLookupText(term);
        const collection = lookup.getAttribute("data-lookup-collection") || "";
        const existingCreate = $(".inlineLookupOption[data-lookup-create=\"1\"]", lookup);
        if (existingCreate) existingCreate.remove();
        const ranked = [];
        $$(".inlineLookupOption[data-lookup-static=\"1\"]", lookup).forEach((btn) => {
          const label = btn.getAttribute("data-lookup-label") || "";
          const score = fuzzyLookupScore(label, term);
          if (score < 0) {
            btn.style.display = "none";
            btn.classList.remove("active");
            return;
          }
          ranked.push({ btn: btn, score: score, label: label });
        });
        ranked.sort((a, b) => {
          if (b.score !== a.score) return b.score - a.score;
          return a.label.localeCompare(b.label, undefined, { sensitivity: "base", numeric: true });
        });
        const wantCreate = !!termNorm && !!collection;
        const maxMatches = Math.max(0, 50 - (wantCreate ? 1 : 0));
        const limited = ranked.slice(0, maxMatches);
        limited.forEach((item, idx) => {
          item.btn.style.display = "block";
          item.btn.classList.toggle("active", idx === 0);
          menu.appendChild(item.btn);
        });
        if (ranked.length > maxMatches) {
          ranked.slice(maxMatches).forEach((item) => {
            item.btn.style.display = "none";
            item.btn.classList.remove("active");
          });
        }
        if (wantCreate) {
          const createBtn = document.createElement("button");
          createBtn.type = "button";
          createBtn.className = "inlineLookupOption";
          createBtn.setAttribute("data-lookup-create", "1");
          createBtn.setAttribute("data-lookup-create-name", term);
          createBtn.setAttribute("data-lookup-value", encodeLookupCreateToken(collection, term));
          createBtn.setAttribute("data-lookup-label", normalizeLookupText(term));
          createBtn.textContent = '+ Add "' + term + '"';
          if (!limited.length) createBtn.classList.add("active");
          menu.appendChild(createBtn);
        }
        const empty = $(".inlineLookupEmpty", lookup);
        const visibleCount = limited.length + (wantCreate ? 1 : 0);
        if (empty) empty.style.display = visibleCount ? "none" : "block";
      }

      function applyInlineLookupPhantomFill(lookup, rawTyped) {
        if (!lookup) return;
        const textInput = $('[data-lookup-input="1"]', lookup);
        if (!textInput) return;
        const top = firstVisibleLookupOption(lookup);
        const typed = String(rawTyped == null ? "" : rawTyped);
        if (!top || !typed) return;
        if (top.getAttribute("data-lookup-create") === "1") return;
        const candidate = top.textContent === "(none)" ? "" : String(top.textContent || "");
        if (!candidate) return;
        if (!normalizeLookupText(candidate).startsWith(normalizeLookupText(typed))) return;
        textInput.value = candidate;
        try { textInput.setSelectionRange(typed.length, candidate.length); } catch {}
      }

      function previewInlineLookupOption(lookup, optionBtn, rawTyped) {
        if (!lookup || !optionBtn) return;
        const textInput = $('[data-lookup-input="1"]', lookup);
        if (!textInput) return;
        const typed = String(rawTyped == null ? "" : rawTyped);
        if (optionBtn.getAttribute("data-lookup-create") === "1") {
          textInput.value = typed;
          try { textInput.setSelectionRange(typed.length, typed.length); } catch {}
          return;
        }
        const candidate = optionBtn.textContent === "(none)" ? "" : String(optionBtn.textContent || "");
        if (!candidate) {
          textInput.value = "";
          return;
        }
        textInput.value = candidate;
        const typedNorm = normalizeLookupText(typed);
        const candNorm = normalizeLookupText(candidate);
        if (typed && candNorm.startsWith(typedNorm)) {
          try { textInput.setSelectionRange(typed.length, candidate.length); } catch {}
          return;
        }
        try { textInput.setSelectionRange(candidate.length, candidate.length); } catch {}
      }

      function chooseInlineLookupOption(lookup, optionBtn) {
        if (!lookup || !optionBtn) return;
        const textInput = $('[data-lookup-input="1"]', lookup);
        const hidden = $('input[type="hidden"][data-edit]', lookup);
        if (!textInput || !hidden) return;
        const value = optionBtn.getAttribute("data-lookup-value") || "";
        const display = optionBtn.getAttribute("data-lookup-create") === "1"
          ? (optionBtn.getAttribute("data-lookup-create-name") || "")
          : (optionBtn.textContent === "(none)" ? "" : optionBtn.textContent);
        hidden.value = value;
        textInput.value = display;
        lookup.setAttribute("data-lookup-typed", display);
        lookup.setAttribute("data-lookup-searching", "0");
        lookup.classList.remove("open");
        lookup.removeAttribute("data-lookup-nav-ready");
      }

      function restoreInlineLookupOriginal(lookup) {
        if (!lookup) return;
        const textInput = $('[data-lookup-input="1"]', lookup);
        const hidden = $('input[type="hidden"][data-edit]', lookup);
        if (!textInput || !hidden) return;
        const originalValue = lookup.getAttribute("data-lookup-original-value") || "";
        const originalText = lookup.getAttribute("data-lookup-original-text") || "";
        hidden.value = originalValue;
        textInput.value = originalText;
        lookup.setAttribute("data-lookup-typed", originalText);
        lookup.setAttribute("data-lookup-searching", "0");
        lookup.classList.remove("open");
        lookup.removeAttribute("data-lookup-nav-ready");
        try { textInput.focus({ preventScroll: true }); } catch { textInput.focus(); }
      }

      async function resolveLookupValue(value, createdLookupByToken) {
        const raw = String(value || "").trim();
        if (!raw) return "";
        const token = parseLookupCreateToken(raw);
        if (!token) return raw;
        const key = raw;
        if (createdLookupByToken.has(key)) return createdLookupByToken.get(key);

        const collection = token.collection;
        const name = String(token.name || "").trim();
        if (!collection || !name) throw new Error("New lookup value is missing collection/name.");

        if (collection === "payees") {
          const existing = state.payees.find((p) => normalizeLookupText(p && p.name) === normalizeLookupText(name));
          if (existing && existing.id) {
            const existingId = String(existing.id);
            createdLookupByToken.set(key, existingId);
            return existingId;
          }
        }

        const body = collection === "accounts"
          ? { name: name, type: "bank", is_archived: false }
          : (collection === "categories"
            ? { name: name, kind: "expense", is_archived: false }
            : (collection === "payees"
              ? { name: name, is_archived: false }
              : null));
        if (!body) throw new Error("Unsupported create-lookup collection: " + collection);

        const created = await createRecord(collection, body);
        const id = String((created && created.id) || "");
        if (!id) throw new Error("Failed to create new " + collection + " entry for \"" + name + "\".");
        createdLookupByToken.set(key, id);
        return id;
      }

      function sortedCopyByLabel(items, labelFn) {
        return items.slice().sort((a, b) => labelFn(a).localeCompare(labelFn(b), undefined, { sensitivity: "base" }));
      }

      function compareSortValues(a, b, direction) {
        const dir = direction === "asc" ? 1 : -1;
        const aNum = typeof a === "number" ? a : NaN;
        const bNum = typeof b === "number" ? b : NaN;
        if (Number.isFinite(aNum) && Number.isFinite(bNum)) {
          if (aNum < bNum) return -1 * dir;
          if (aNum > bNum) return 1 * dir;
          return 0;
        }
        const aStr = String(a == null ? "" : a).toLocaleLowerCase();
        const bStr = String(b == null ? "" : b).toLocaleLowerCase();
        const cmp = aStr.localeCompare(bStr, undefined, { sensitivity: "base", numeric: true });
        return cmp * dir;
      }

      function summarizeGroupText(group, valueFn) {
        return Array.from(new Set((group || []).map(valueFn).map((v) => String(v || "").trim()).filter(Boolean)))
          .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: "base" }))
          .join(" | ");
      }

      function txnSortValue(txnId, group, txn, column) {
        if (column === "date") {
          const dateSource = txn.date || ((group && group[0]) ? group[0].date : "");
          const ts = Date.parse(dateSource || "");
          return Number.isFinite(ts) ? ts : -Infinity;
        }
        if (column === "account") {
          if ((group || []).length <= 1) return accountDisplayName(group[0] && group[0].account);
          return summarizeGroupText(group, (e) => accountDisplayName(e && e.account));
        }
        if (column === "payee") return payeeDisplayName(txn.payee);
        if (column === "category") {
          if ((group || []).length <= 1) return categoryDisplayName(group[0] && group[0].category);
          return summarizeGroupText(group, (e) => categoryDisplayName(e && e.category));
        }
        if (column === "memo") return txn.memo || "";
        if (column === "amount") {
          return (group || []).reduce((sum, e) => {
            try {
              return sum + qtyMajorForEntry(e);
            } catch {
              return sum;
            }
          }, 0);
        }
        if (column === "status") {
          if ((group || []).length <= 1) return (group[0] && group[0].status) || "";
          return summarizeGroupText(group, (e) => (e && e.status) || "");
        }
        return String(txnId || "");
      }

      function updateRegisterSortHeaders() {
        const headers = $$("th[data-sort]", $("#registerTable thead"));
        headers.forEach((th) => {
          const key = th.getAttribute("data-sort") || "";
          const isActive = key === state.sort.column;
          th.classList.toggle("sorted-asc", isActive && state.sort.direction === "asc");
          th.classList.toggle("sorted-desc", isActive && state.sort.direction === "desc");
          th.setAttribute("aria-sort", isActive ? (state.sort.direction === "asc" ? "ascending" : "descending") : "none");
        });
      }

      function toggleRegisterSort(column) {
        if (!column) return;
        if (state.editingTxnId) {
          setStatus("warn", "Finish or cancel inline edit before sorting.");
          return;
        }
        if (state.sort.column === column) {
          state.sort.direction = state.sort.direction === "asc" ? "desc" : "asc";
        } else {
          state.sort.column = column;
          state.sort.direction = (column === "date" || column === "amount") ? "desc" : "asc";
        }
        state.page = 1;
        updateRegisterSortHeaders();
        if (column === "payee" || column === "memo") {
          setStatus("warn", "Payee/Memo sorting uses current page only; PocketBase sort is applied on entries fields.");
        }
        refreshAll();
      }

      function setupRegisterSortHeaders() {
        const headers = $$("th[data-sort]", $("#registerTable thead"));
        headers.forEach((th) => {
          th.classList.add("sortable");
          if (th.getAttribute("data-sort-bound") === "1") return;
          th.setAttribute("data-sort-bound", "1");
          th.addEventListener("click", function() {
            toggleRegisterSort(th.getAttribute("data-sort") || "");
          });
        });
        updateRegisterSortHeaders();
      }

      function registerServerSortKey(column) {
        if (column === "date") return "date";
        if (column === "account") return "account";
        if (column === "category") return "category";
        if (column === "amount") return "qty";
        if (column === "status") return "status";
        return "date";
      }

      function registerServerSortExpr() {
        const key = registerServerSortKey(state.sort.column);
        return (state.sort.direction === "desc" ? "-" : "") + key;
      }

      function updateRegisterPageInfo() {
        const current = Math.max(1, state.page || 1);
        const totalPages = Math.max(1, state.totalPages || 1);
        const totalItems = Math.max(0, state.totalItems || 0);
        $("#pageInfo").textContent = "Page " + current + " of " + totalPages + " (" + totalItems + " rows)";
      }

      function localTodayYmd() {
        const now = new Date();
        return new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 10);
      }

      function nextDraftTempEntryId() {
        return "tmp_entry_" + Date.now() + "_" + Math.random().toString(36).slice(2, 9);
      }

      function draftEntryFromTemplate(templateEntry, txnDateIso) {
        const src = templateEntry || {};
        const fallbackAssetId = String(src.asset || getUsdAssetId() || "");
        return {
          id: nextDraftTempEntryId(),
          txn: String(src.txn || state.editingTxnId || ""),
          date: txnDateIso || src.date || normalizeDateToNoonUtc(localTodayYmd()),
          account: src.account || "",
          category: src.category || null,
          asset: fallbackAssetId,
          qty: 0,
          memo: src.memo || "",
          status: src.status || "pending",
          meta: parseTxnMeta(src.meta),
          _isNew: true
        };
      }

      function addEntryToEditDraft(sourceEntryId) {
        if (!state.editingTxnId || !state.editDraft) return;
        const entries = Array.isArray(state.editDraft.entries) ? state.editDraft.entries : [];
        const templateById = sourceEntryId
          ? entries.find((e) => String((e && e.id) || "") === String(sourceEntryId))
          : null;
        const template = templateById || entries[entries.length - 1] || entries[0] || null;
        const txn = state.editDraft.txn || {};
        const txnDateIso = txn.date || normalizeDateToNoonUtc(localTodayYmd());
        const nextEntry = draftEntryFromTemplate(template, txnDateIso);
        state.editDraft.entries = entries.concat([nextEntry]);
        renderRegister();
        setBusy();
        setStatus("warn", "Added a draft entry. Save Edit to persist it.");
      }

      function removeEntryFromEditDraft(entryId) {
        if (!state.editingTxnId || !state.editDraft) return;
        const entries = Array.isArray(state.editDraft.entries) ? state.editDraft.entries : [];
        const id = String(entryId || "");
        if (!id) return;
        if (entries.length <= 1) {
          setStatus("warn", "A transaction must keep at least one entry.");
          return;
        }
        const target = entries.find((e) => String((e && e.id) || "") === id);
        if (!target) return;
        state.editDraft.entries = entries.filter((e) => String((e && e.id) || "") !== id);
        if (!target._isNew) {
          const deleted = Array.isArray(state.editDraft.deletedEntryIds) ? state.editDraft.deletedEntryIds : [];
          if (!deleted.includes(id)) deleted.push(id);
          state.editDraft.deletedEntryIds = deleted;
        }
        renderRegister();
        setBusy();
        setStatus("warn", "Removed draft entry. Save Edit to persist this change.");
      }

      function getUsdAssetId() {
        const usd = state.assets.find((a) => String(a.symbol || "").toUpperCase() === "USD");
        return usd ? usd.id : "";
      }

      function focusKeyFromDblClickEvent(ev) {
        const td = ev && ev.target ? ev.target.closest("td") : null;
        const idx = td ? td.cellIndex : 0;
        if (idx === 0) return "txn-date";
        if (idx === 1) return "entry-account";
        if (idx === 2) return "txn-payee";
        if (idx === 3) return "entry-category";
        if (idx === 4) return "txn-memo";
        if (idx === 5) return "entry-qty";
        if (idx === 6) return "entry-status";
        return "txn-date";
      }

      function applyPendingInlineFocus() {
        if (!state.editingTxnId || !state.pendingFocusKey) return;
        const key = state.pendingFocusKey;
        const selector = (key === "entry-account" || key === "entry-category" || key === "txn-payee")
          ? '[data-lookup-for="' + key + '"]'
          : '[data-edit="' + key + '"]';
        requestAnimationFrame(function() {
          const el = $("#registerBody " + selector);
          if (!el) return;
          try { el.focus({ preventScroll: true }); } catch { el.focus(); }
          if (el.tagName === "INPUT" && el.type !== "date") {
            try { el.select(); } catch {}
          }
          state.pendingFocusKey = "";
        });
      }

      async function startNewInlineEdit() {
        if (!SESSION.token) return;
        if (state.loading || state.saving || state.deleting) return;
        if (state.editingTxnId) {
          setStatus("warn", "Finish or cancel the current inline edit before creating a new transaction.");
          return;
        }

        let createdTxnId = "";
        let createdEntryId = "";
        try {
          state.loading = true;
          setBusy();

          if (!state.accounts.length || !state.assets.length || !state.categories.length || !state.payees.length) {
            await loadReferenceData();
          }

          const accountSorted = sortedCopyByLabel(state.accounts, (a) => (a.name || a.id || ""));
          const categorySorted = sortedCopyByLabel(state.categories, (c) => (c.name || c.id || ""));
          const usdAssetId = getUsdAssetId();

          const defaultAccount = accountSorted[0] ? accountSorted[0].id : "";
          const defaultCategory = categorySorted[0] ? categorySorted[0].id : "";
          if (!defaultAccount) throw new Error("No account available for default selection.");
          if (!usdAssetId) throw new Error("USD asset was not found.");

          const normalizedDate = normalizeDateToNoonUtc(localTodayYmd());
          const txn = await createRecord("txns", {
            date: normalizedDate,
            source: "manual"
          });
          createdTxnId = txn.id;
          const entry = await createRecord("entries", {
            txn: txn.id,
            date: normalizedDate,
            account: defaultAccount,
            category: defaultCategory || null,
            asset: usdAssetId,
            qty: 0,
            status: "pending"
          });
          createdEntryId = entry.id;

          state.selectedTxnIds = [txn.id];
          state.selectionAnchorTxnId = txn.id;
          state.editingTxnId = txn.id;
          state.editDraft = { txn: txn, entries: [entry], deletedEntryIds: [] };
          state.pendingFocusKey = "txn-date";
          setStatus("warn", "Created new transaction and opened inline edit mode.");
          await loadRegister();
        } catch (err) {
          if (createdEntryId) {
            try { await deleteRecord("entries", createdEntryId); } catch {}
          }
          if (createdTxnId) {
            try { await deleteRecord("txns", createdTxnId); } catch {}
          }
          const info = classifyError(err);
          setStatus(info.kind, "New transaction failed: " + (err && err.message ? err.message : info.message));
        } finally {
          state.loading = false;
          setBusy();
        }
      }

      async function startInlineEdit(txnId, focusKey) {
        if (!SESSION.token || !txnId) return;
        if (state.loading || state.saving || state.deleting) return;
        if (state.editingTxnId && state.editingTxnId !== txnId) {
          const ok = await saveInlineEdit();
          if (!ok) return;
        }
        if (state.editingTxnId === txnId) {
          state.pendingFocusKey = focusKey || "txn-date";
          applyPendingInlineFocus();
          return;
        }
        try {
          state.loading = true;
          setBusy();
          const txn = await getRecord("txns", txnId);
          const entries = await listRecordsSafe("entries", {
            filter: 'txn = "' + txnId.replaceAll('"', '\\"') + '"',
            sort: "-date",
            perPage: 500
          });
          await ensureAccountsLoaded(entries.map((e) => e && e.account));
          await ensureCategoriesLoaded(entries.map((e) => e && e.category));
          await ensurePayeesLoaded([txn && txn.payee]);
          state.editingTxnId = txnId;
          state.selectedTxnIds = [txnId];
          state.selectionAnchorTxnId = txnId;
          state.editDraft = { txn: txn, entries: entries, deletedEntryIds: [] };
          state.pendingFocusKey = focusKey || "txn-date";
          setStatus("warn", "Inline edit mode: update fields, then Save Edit or Cancel.");
          renderRegister();
        } catch (err) {
          const info = classifyError(err);
          setStatus(info.kind, "Failed to start edit: " + (err && err.message ? err.message : info.message));
        } finally {
          state.loading = false;
          setBusy();
        }
      }

      function cancelInlineEdit() {
        state.editingTxnId = "";
        state.editDraft = null;
        state.pendingFocusKey = "";
        setStatus("ok", "Edit canceled.");
        renderRegister();
        setBusy();
      }

      async function saveInlineEdit() {
        if (!state.editingTxnId || !state.editDraft || !SESSION.token) return false;
        if (state.saving) return false;
        const txnId = state.editingTxnId;
        const root = $('#registerBody tr[data-edit-root="1"]');
        if (!root) return false;
        let normalizedDate = "";
        let payee = null;
        let memo = null;
        const updates = [];
        const creates = [];
        const createdLookupByToken = new Map();

        try {
          const dateRaw = $('input[data-edit="txn-date"]', root).value.trim();
          payee = fieldOrNull($('input[data-edit="txn-payee"]', root).value);
          memo = fieldOrNull($('input[data-edit="txn-memo"]', root).value);
          if (!/^\d{4}-\d{2}-\d{2}$/.test(dateRaw)) throw new Error("Date must be in YYYY-MM-DD format.");
          normalizedDate = normalizeDateToNoonUtc(dateRaw);
          payee = payee ? await resolveLookupValue(payee, createdLookupByToken) : null;

          const entryRows = $$('tr[data-edit-entry="1"]', $("#registerBody"));
          for (const row of entryRows) {
            const entryId = row.getAttribute("data-entry-id") || "";
            const accountRaw = $('input[data-edit="entry-account"]', row).value;
            const categoryRaw = $('input[data-edit="entry-category"]', row).value;
            const qtyRaw = $('input[data-edit="entry-qty"]', row).value.trim();
            const status = $('select[data-edit="entry-status"]', row).value;

            if (!entryId) throw new Error("Entry id missing in edit row.");
            const account = await resolveLookupValue(accountRaw, createdLookupByToken);
            const categoryResolved = categoryRaw ? await resolveLookupValue(categoryRaw, createdLookupByToken) : "";
            if (!account) throw new Error("Account is required for all entries.");
            if (!status) throw new Error("Status is required for all entries.");
            if (!qtyRaw) throw new Error("Amount is required for all entries.");
            const sourceEntry = (state.editDraft.entries || []).find((e) => String(e.id || "") === entryId);
            if (!sourceEntry) throw new Error("Entry " + entryId + " is missing from edit draft.");
            const entryAssetId = String(sourceEntry.asset || getUsdAssetId() || "");
            if (!entryAssetId) throw new Error("Entry asset is required.");
            const precision = assetPrecision(entryAssetId);
            const qty = parseMajorToMinor(qtyRaw, precision);

            const body = {
              date: normalizedDate,
              account: account,
              category: categoryResolved || null,
              asset: entryAssetId,
              qty: qty,
              status: status
            };
            if (sourceEntry._isNew || entryId.startsWith("tmp_entry_")) {
              creates.push({
                body: {
                  txn: txnId,
                  date: normalizedDate,
                  account: body.account,
                  category: body.category,
                  asset: body.asset,
                  qty: body.qty,
                  memo: sourceEntry.memo || "",
                  status: body.status,
                  meta: parseTxnMeta(sourceEntry.meta)
                }
              });
            } else {
              updates.push({ id: entryId, body: body });
            }
          }
        } catch (err) {
          setStatus("bad", "Save failed: " + (err && err.message ? err.message : String(err)));
          return false;
        }

        try {
          state.saving = true;
          setBusy();
          await updateRecord("txns", txnId, {
            date: normalizedDate,
            payee: payee,
            memo: memo
          });
          for (const u of updates) {
            await updateRecord("entries", u.id, u.body);
          }
          for (const c of creates) {
            await createRecord("entries", c.body);
          }
          const deletedEntryIds = (state.editDraft && Array.isArray(state.editDraft.deletedEntryIds))
            ? state.editDraft.deletedEntryIds.slice()
            : [];
          for (const entryId of deletedEntryIds) {
            await deleteRecord("entries", entryId);
          }
          state.editingTxnId = "";
          state.editDraft = null;
          state.pendingFocusKey = "";
          setStatus("ok", "Transaction " + txnId + " updated.");
          await refreshAll();
          return true;
        } catch (err) {
          const info = classifyError(err);
          setStatus(info.kind, "Save edit failed: " + (err && err.message ? err.message : info.message));
          return false;
        } finally {
          state.saving = false;
          setBusy();
        }
      }

      async function cycleEntryStatus(entryId) {
        const id = String(entryId || "");
        if (!SESSION.token || !id) return;
        if (state.loading || state.saving || state.deleting || state.editingTxnId) return;

        const idx = state.entries.findIndex((e) => String((e && e.id) || "") === id);
        if (idx < 0) return;
        const current = String((state.entries[idx] && state.entries[idx].status) || "");
        const txnId = String((state.entries[idx] && state.entries[idx].txn) || "");
        const txn = txnId ? state.txns.get(txnId) : null;
        const rec = txn ? recurrenceFromTxnMeta(txn.meta) : null;
        if (current === "scheduled" && txnId && rec) {
          try {
            state.saving = true;
            setBusy();
            const message = await applyScheduledRecurrenceForTxn(txnId);
            setStatus("ok", message);
            await refreshAll();
          } catch (err) {
            const info = classifyError(err);
            setStatus(info.kind, "Scheduled recurrence apply failed: " + (err && err.message ? err.message : info.message));
          } finally {
            state.saving = false;
            setBusy();
          }
          return;
        }
        const next = nextEntryStatusValue(current);
        if (!next || next === current) return;

        try {
          state.saving = true;
          setBusy();
          await updateRecord("entries", id, { status: next });
          state.entries[idx] = Object.assign({}, state.entries[idx], { status: next });
          renderRegister();
        } catch (err) {
          const info = classifyError(err);
          setStatus(info.kind, "Status update failed: " + (err && err.message ? err.message : info.message));
        } finally {
          state.saving = false;
          setBusy();
        }
      }

      function renderRegister() {
        const body = $("#registerBody");

        body.innerHTML = "";
        const txnGroups = new Map();
        const txnOrder = [];
        state.entries.forEach((e) => {
          const key = e.txn || "";
          if (!txnGroups.has(key)) {
            txnGroups.set(key, []);
            txnOrder.push(key);
          }
          txnGroups.get(key).push(e);
        });
        if (state.sort.column === "payee" || state.sort.column === "memo") {
          txnOrder.sort((a, b) => {
            const groupA = txnGroups.get(a) || [];
            const groupB = txnGroups.get(b) || [];
            const txnA = state.txns.get(a) || {};
            const txnB = state.txns.get(b) || {};
            const valA = txnSortValue(a, groupA, txnA, state.sort.column);
            const valB = txnSortValue(b, groupB, txnB, state.sort.column);
            const cmp = compareSortValues(valA, valB, state.sort.direction);
            if (cmp !== 0) return cmp;
            return String(a || "").localeCompare(String(b || ""), undefined, { sensitivity: "base", numeric: true });
          });
        }
        state.visibleTxnOrder = txnOrder.slice();
        const orderSet = new Set(txnOrder);
        state.selectedTxnIds = state.selectedTxnIds.filter((id) => orderSet.has(id));
        if (state.selectionAnchorTxnId && !orderSet.has(state.selectionAnchorTxnId)) {
          state.selectionAnchorTxnId = state.selectedTxnIds[0] || "";
        }
        const selectedSet = new Set(state.selectedTxnIds);

        function selectTxn(txnId, ev) {
          if (state.editingTxnId) return;
          const order = state.visibleTxnOrder || [];
          const selected = new Set(state.selectedTxnIds);
          const isToggle = !!(ev && (ev.metaKey || ev.ctrlKey));
          const isRange = !!(ev && ev.shiftKey);

          if (isRange && state.selectionAnchorTxnId) {
            const a = order.indexOf(state.selectionAnchorTxnId);
            const b = order.indexOf(txnId);
            if (a !== -1 && b !== -1) {
              const start = Math.min(a, b);
              const end = Math.max(a, b);
              const range = order.slice(start, end + 1);
              if (!isToggle) selected.clear();
              range.forEach((id) => selected.add(id));
            } else {
              if (!isToggle) selected.clear();
              selected.add(txnId);
            }
          } else if (isToggle) {
            if (selected.has(txnId)) selected.delete(txnId);
            else selected.add(txnId);
            state.selectionAnchorTxnId = txnId;
          } else {
            selected.clear();
            selected.add(txnId);
            state.selectionAnchorTxnId = txnId;
          }

          if (!state.selectionAnchorTxnId && txnId) state.selectionAnchorTxnId = txnId;
          state.selectedTxnIds = Array.from(selected);
          setBusy();
          renderRegister();
        }

        txnOrder.forEach((txnId) => {
          const group = txnGroups.get(txnId) || [];
          const txn = state.txns.get(txnId) || {};
          const isSelected = selectedSet.has(txnId);

          if (state.editingTxnId && state.editingTxnId === txnId && state.editDraft) {
            const draftTxn = state.editDraft.txn || {};
            const draftEntries = state.editDraft.entries || [];
            const isSingle = draftEntries.length <= 1;

            if (isSingle) {
              const e = draftEntries[0] || {};
              const trSingle = document.createElement("tr");
              trSingle.className = "txn-edit txn-edit-end";
              trSingle.setAttribute("data-edit-root", "1");
              trSingle.setAttribute("data-edit-entry", "1");
              trSingle.setAttribute("data-entry-id", String(e.id || ""));
              trSingle.innerHTML = [
                '<td><input class="inlineInput" data-edit="txn-date" type="text" inputmode="numeric" placeholder="YYYY-MM-DD" value="' + escapeHtml(fmtDate(draftTxn.date || e.date)) + '" /></td>',
                '<td>' + inlineLookupMarkup(editableAccountOptions(e.account), e.account, (a) => accountLabel(a, true), "entry-account", false, "Select account") + "</td>",
                '<td>' + inlineLookupMarkup(editablePayeeOptions(draftTxn.payee), draftTxn.payee, (p) => payeeLabel(p, true), "txn-payee", true, "Optional payee") + "</td>",
                '<td>' + inlineLookupMarkup(editableCategoryOptions(e.category), e.category, (c) => categoryLabel(c, true), "entry-category", true, "Optional category") + "</td>",
                '<td><input class="inlineInput" data-edit="txn-memo" type="text" value="' + escapeHtml(draftTxn.memo || "") + '" /></td>',
                '<td><input class="inlineInput" data-edit="entry-qty" type="text" value="' + escapeHtml(e.qty == null ? "" : fmtMinor(e.qty, assetPrecision(e.asset))) + '" /></td>',
                '<td><select class="inlineSelect" data-edit="entry-status">' + statusSelectOptionsMarkup(e.status) + "</select></td>"
              ].join("");
              body.appendChild(trSingle);
              return;
            }

            const trTxn = document.createElement("tr");
            trTxn.className = "txn-edit";
            trTxn.setAttribute("data-edit-root", "1");
            trTxn.innerHTML = [
              '<td><input class="inlineInput" data-edit="txn-date" type="text" inputmode="numeric" placeholder="YYYY-MM-DD" value="' + escapeHtml(fmtDate(draftTxn.date)) + '" /></td>',
              "<td></td>",
              '<td>' + inlineLookupMarkup(editablePayeeOptions(draftTxn.payee), draftTxn.payee, (p) => payeeLabel(p, true), "txn-payee", true, "Optional payee") + "</td>",
              "<td></td>",
              '<td><input class="inlineInput" data-edit="txn-memo" type="text" value="' + escapeHtml(draftTxn.memo || "") + '" /></td>',
              "<td></td>",
              '<td><button type="button" class="entryRowBtn" data-edit-add-entry="1" title="Add entry" aria-label="Add entry">+</button></td>'
            ].join("");
            body.appendChild(trTxn);

            draftEntries.forEach((e, idx) => {
              const trE = document.createElement("tr");
              trE.className = "txn-edit" + (idx === draftEntries.length - 1 ? " txn-edit-end" : "");
              trE.setAttribute("data-edit-entry", "1");
              trE.setAttribute("data-entry-id", String(e.id || ""));
              trE.innerHTML = [
                '<td><button type="button" class="entryRowBtn" data-edit-remove-entry="1" data-entry-id="' + escapeHtml(String(e.id || "")) + '" title="Remove entry" aria-label="Remove entry">-</button></td>',
                '<td>' + inlineLookupMarkup(editableAccountOptions(e.account), e.account, (a) => accountLabel(a, true), "entry-account", false, "Select account") + "</td>",
                "<td></td>",
                '<td>' + inlineLookupMarkup(editableCategoryOptions(e.category), e.category, (c) => categoryLabel(c, true), "entry-category", true, "Optional category") + "</td>",
                "<td></td>",
                '<td><input class="inlineInput" data-edit="entry-qty" type="text" value="' + escapeHtml(e.qty == null ? "" : fmtMinor(e.qty, assetPrecision(e.asset))) + '" /></td>',
                '<td><select class="inlineSelect" data-edit="entry-status">' + statusSelectOptionsMarkup(e.status) + "</select></td>"
              ].join("");
              body.appendChild(trE);
            });
            return;
          }

          if (group.length <= 1) {
            const e = group[0];
            if (!e) return;

            const tr = document.createElement("tr");
            if (isSelected) tr.classList.add("selected");

            tr.innerHTML = [
              "<td>" + escapeHtml(fmtDate(e.date)) + "</td>",
              "<td>" + escapeHtml(accountDisplayName(e.account)) + "</td>",
              "<td>" + escapeHtml(payeeDisplayName(txn.payee)) + "</td>",
              "<td><span class=\"pill\">" + escapeHtml(categoryDisplayName(e.category)) + "</span></td>",
              "<td>" + memoCellMarkup(txn) + "</td>",
              "<td>" + amountCellMarkupFromMinor(e.qty, assetPrecision(e.asset)) + "</td>",
              "<td>" + statusCellButtonMarkup(e.id, e.status) + "</td>"
            ].join("");

            tr.addEventListener("click", function(ev) { selectTxn(e.txn || "", ev); });
            tr.addEventListener("dblclick", function(ev) { startInlineEdit(e.txn || "", focusKeyFromDblClickEvent(ev)); });
            body.appendChild(tr);
            return;
          }

          const totalQty = group.reduce((sum, e) => {
            try {
              return sum + qtyMajorForEntry(e);
            } catch {
              return sum;
            }
          }, 0);
          const groupPrecisions = Array.from(new Set(group.map((e) => assetPrecision(e.asset))));
          const totalPrecision = groupPrecisions.length === 1 ? groupPrecisions[0] : 2;

          const parentRow = document.createElement("tr");
          parentRow.className = "txn-parent";
          if (isSelected) parentRow.classList.add("selected");
          parentRow.innerHTML = [
            "<td>" + escapeHtml(fmtDate(txn.date || group[0].date)) + "</td>",
            "<td></td>",
            "<td>" + escapeHtml(payeeDisplayName(txn.payee)) + "</td>",
            "<td></td>",
            "<td>" + memoCellMarkup(txn) + "</td>",
            "<td>" + amountCellMarkupFromMajor(totalQty, totalPrecision) + "</td>",
            "<td></td>"
          ].join("");
          parentRow.addEventListener("click", function(ev) { selectTxn(txnId, ev); });
          parentRow.addEventListener("dblclick", function(ev) { startInlineEdit(txnId, focusKeyFromDblClickEvent(ev)); });
          body.appendChild(parentRow);

          group.forEach((e, idx) => {
            const tr = document.createElement("tr");
            tr.className = "txn-sub" + (idx === group.length - 1 ? " txn-sub-end" : "");
            if (isSelected) tr.classList.add("selected");
            tr.innerHTML = [
              "<td></td>",
              "<td>" + escapeHtml(accountDisplayName(e.account)) + "</td>",
              "<td></td>",
              "<td><span class=\"pill\">" + escapeHtml(categoryDisplayName(e.category)) + "</span></td>",
              "<td></td>",
              "<td>" + amountCellMarkupFromMinor(e.qty, assetPrecision(e.asset)) + "</td>",
              "<td>" + statusCellButtonMarkup(e.id, e.status) + "</td>"
            ].join("");

            tr.addEventListener("click", function(ev) { selectTxn(txnId, ev); });
            tr.addEventListener("dblclick", function(ev) { startInlineEdit(txnId, focusKeyFromDblClickEvent(ev)); });
            body.appendChild(tr);
          });
        });

        applyPendingInlineFocus();
        $("#resultCount").textContent = state.entries.length + " entries shown across " + txnOrder.length + " transactions. Double-click a transaction row to edit inline.";
      }

      async function deleteSelectedTransaction() {
        if (!SESSION.token || state.selectedTxnIds.length < 1 || state.deleting) return;
        const txnIds = state.selectedTxnIds.slice();
        const yes = confirm("Delete " + txnIds.length + " selected transaction(s) and their entries? This cannot be undone.");
        if (!yes) return;

        state.deleting = true;
        setBusy();

        let deletedTxns = 0;
        let deletedEntries = 0;
        const failed = [];
        try {
          for (const txnId of txnIds) {
            try {
              const rows = await listRecordsSafe("entries", { filter: 'txn = "' + txnId.replaceAll('"', '\\"') + '"', perPage: 500, sort: "-date" });
              for (const row of rows) {
                await deleteRecord("entries", row.id);
                deletedEntries += 1;
              }
              await deleteRecord("txns", txnId);
              deletedTxns += 1;
            } catch {
              failed.push(txnId);
            }
          }
          state.selectedTxnIds = failed.slice();
          state.selectionAnchorTxnId = state.selectedTxnIds[0] || "";
          if (failed.length > 0) {
            setStatus("warn", "Deleted " + deletedTxns + " txn(s), " + deletedEntries + " entries. Failed: " + failed.join(", "));
          } else {
            setStatus("ok", "Deleted " + deletedTxns + " txn(s) and " + deletedEntries + " related entries.");
          }
          await refreshAll();
        } catch (err) {
          const info = classifyError(err);
          setStatus(info.kind, "Delete failed: " + (err && err.message ? err.message : info.message));
        } finally {
          state.deleting = false;
          setBusy();
        }
      }

      async function refreshAll() {
        if (!SESSION.token) return;
        state.loading = true;
        setBusy();

        try {
          await loadReferenceData();

          await loadRegister();

          setStatus("ok", "Loaded accounts/assets/categories/payees and register entries.");
        } catch (err) {
          const info = classifyError(err);
          setStatus(info.kind, "Load failed: " + (err && err.message ? err.message : info.message));
          if (err && err.kind === "auth") {
            SESSION.token = "";
            store.del("pbToken");
            state.editingTxnId = "";
            state.editDraft = null;
            setAuthenticatedUI(false);
          }
        } finally {
          state.loading = false;
          setBusy();
        }
      }

      async function validateCachedSession() {
        if (!SESSION.base || !SESSION.token) return false;
        try {
          const res = await authRefresh();
          if (res && res.token) {
            SESSION.token = res.token;
            store.set("pbToken", res.token);
          }
          return true;
        } catch {
          return false;
        }
      }

      $("#btnLogin").addEventListener("click", async function() {
        const base = $("#pbUrl").value.trim().replace(/\/+$/, "");
        const email = $("#pbEmail").value.trim();
        const password = $("#pbPass").value;

        if (!base || !email || !password) {
          setStatus("bad", "Login failed: URL, email, and password are required.");
          return;
        }

        store.set("pbUrl", base);
        store.set("pbEmail", email);

        try {
          $("#btnLogin").disabled = true;
          SESSION.base = base;
          SESSION.token = "";

          const res = await authWithPassword(email, password);
          if (!res || !res.token) throw new Error("No token returned by PocketBase.");

          SESSION.token = res.token;
          store.set("pbToken", res.token);
          setAuthenticatedUI(true);
          setStatus("ok", "Login succeeded. Session saved in localStorage.");
          await refreshAll();
        } catch (err) {
          SESSION.token = "";
          store.del("pbToken");
          setAuthenticatedUI(false);
          const info = classifyError(err);
          setStatus(info.kind, "Login failed: " + (err && err.message ? err.message : info.message));
        } finally {
          $("#btnLogin").disabled = false;
          $("#pbPass").value = "";
        }
      });

      $("#logoutLink").addEventListener("click", function(ev) {
        ev.preventDefault();
        SESSION.base = "";
        SESSION.token = "";
        store.del("pbUrl");
        store.del("pbEmail");
        store.del("pbToken");
        $("#pbUrl").value = "";
        $("#pbEmail").value = "";
        $("#pbPass").value = "";
        state.entries = [];
        state.accounts = [];
        state.accountById = new Map();
        state.assets = [];
        state.assetPrecisionById = new Map();
        state.categories = [];
        state.categoryById = new Map();
        state.payees = [];
        state.payeeById = new Map();
        state.txns = new Map();
        state.selectedTxnIds = [];
        state.selectionAnchorTxnId = "";
        state.visibleTxnOrder = [];
        state.editingTxnId = "";
        state.editDraft = null;
        closeRecurrenceModal();
        state.page = 1;
        state.totalPages = 1;
        state.totalItems = 0;
        $("#registerBody").innerHTML = "";
        $("#resultCount").textContent = "";
        updateRegisterPageInfo();
        setAuthenticatedUI(false);
        setStatus("ok", "Logged out. Local session cleared.");
        setBusy();
      });

      $("#btnRefresh").addEventListener("click", refreshAll);
      $("#btnNewTxn").addEventListener("click", startNewInlineEdit);
      $("#btnRecurrence").addEventListener("click", openRecurrenceModalForSelection);
      $("#btnDeleteTxn").addEventListener("click", deleteSelectedTransaction);
      $("#btnEditAddEntry").addEventListener("click", function() {
        addEntryToEditDraft("");
      });
      $("#btnEditSave").addEventListener("click", saveInlineEdit);
      $("#btnEditCancel").addEventListener("click", cancelInlineEdit);
      $("#btnRecurrenceSave").addEventListener("click", saveRecurrenceFromModal);
      $("#btnRecurrenceClear").addEventListener("click", clearRecurrenceFromModal);
      $("#btnRecurrenceCancel").addEventListener("click", function() {
        closeRecurrenceModal();
        setStatus("ok", "Recurrence editor canceled.");
      });
      ["#recFreq", "#recInterval", "#recUntil"].forEach((sel) => {
        $(sel).addEventListener("input", updateRecurrencePreview);
        $(sel).addEventListener("change", updateRecurrencePreview);
      });
      $("#recurrenceModal").addEventListener("click", function(e) {
        if (e.target !== $("#recurrenceModal")) return;
        closeRecurrenceModal();
      });

      ["#fltFrom", "#fltTo", "#fltAccount", "#fltCategory", "#fltPayee", "#fltStatus", "#fltBudgetOnly"].forEach((sel) => {
        $(sel).addEventListener("change", function() {
          state.page = 1;
          refreshAll();
        });
      });
      let payeeFilterInputTimer = 0;
      $("#fltPayee").addEventListener("input", function() {
        clearTimeout(payeeFilterInputTimer);
        payeeFilterInputTimer = setTimeout(function() {
          state.page = 1;
          refreshAll();
        }, 1000);
      });

      $("#btnPrevPage").addEventListener("click", function() {
        if (state.page <= 1 || state.loading || state.saving || state.deleting) return;
        state.page -= 1;
        refreshAll();
      });
      $("#btnNextPage").addEventListener("click", function() {
        if (state.page >= state.totalPages || state.loading || state.saving || state.deleting) return;
        state.page += 1;
        refreshAll();
      });
      $("#perPage").addEventListener("change", function() {
        const v = Number($("#perPage").value);
        if (!Number.isFinite(v) || v < 1) return;
        state.perPage = v;
        state.page = 1;
        refreshAll();
      });

      $("#registerBody").addEventListener("keydown", function(e) {
        if (!state.editingTxnId) return;
        const t = e.target;
        if (t && t.matches('input[data-lookup-input="1"]')) {
          const lookup = t.closest(".inlineLookup");
          const isSearching = lookup && lookup.getAttribute("data-lookup-searching") === "1";
          if (e.key === "ArrowDown" || e.key === "ArrowUp") {
            e.preventDefault();
            if (!lookup) return;
            lookup.classList.add("open");
            const typed = lookup.getAttribute("data-lookup-typed");
            if (!lookup.getAttribute("data-lookup-nav-ready")) {
              filterInlineLookupMenu(lookup, typed == null ? t.value : typed);
              lookup.setAttribute("data-lookup-nav-ready", "1");
            }
            const next = moveActiveLookupOption(lookup, e.key === "ArrowDown" ? 1 : -1);
            if (next) lookup.setAttribute("data-lookup-searching", "1");
            previewInlineLookupOption(lookup, next, typed == null ? t.value : typed);
            return;
          }
          if (e.key === "Escape") {
            e.preventDefault();
            if (lookup && isSearching) {
              restoreInlineLookupOriginal(lookup);
              return;
            }
            cancelInlineEdit();
            return;
          }
          if (e.key === "Tab") {
            if (lookup && isSearching) {
              const top = activeLookupOption(lookup) || firstVisibleLookupOption(lookup);
              if (top) chooseInlineLookupOption(lookup, top);
            }
            return;
          }
          if (e.key === "Enter") {
            if (lookup) {
              if (isSearching) {
                const top = activeLookupOption(lookup) || firstVisibleLookupOption(lookup);
                if (top) chooseInlineLookupOption(lookup, top);
                e.preventDefault();
                return;
              }
            }
          }
        }
        if (e.key === "Escape") {
          e.preventDefault();
          cancelInlineEdit();
          return;
        }
        if (e.key !== "Enter") return;
        if (!t || !(t.matches("input") || t.matches("select"))) return;
        e.preventDefault();
        saveInlineEdit();
      });

      $("#registerBody").addEventListener("focusin", function(e) {
        const input = e.target && e.target.matches('input[data-lookup-input="1"]') ? e.target : null;
        if (!input) return;
        const lookup = input.closest(".inlineLookup");
        if (!lookup) return;
        const hidden = $('input[type="hidden"][data-edit]', lookup);
        closeInlineLookups(lookup);
        lookup.classList.add("open");
        lookup.setAttribute("data-lookup-original-text", input.value || "");
        lookup.setAttribute("data-lookup-original-value", hidden ? (hidden.value || "") : "");
        lookup.setAttribute("data-lookup-searching", "0");
        lookup.setAttribute("data-lookup-typed", "");
        lookup.removeAttribute("data-lookup-nav-ready");
        filterInlineLookupMenu(lookup, "");
      });

      $("#registerBody").addEventListener("input", function(e) {
        const input = e.target && e.target.matches('input[data-lookup-input="1"]') ? e.target : null;
        if (!input) return;
        const lookup = input.closest(".inlineLookup");
        if (!lookup) return;
        const rawTyped = input.value;
        lookup.classList.add("open");
        lookup.setAttribute("data-lookup-searching", rawTyped.trim() ? "1" : "0");
        lookup.setAttribute("data-lookup-typed", rawTyped);
        lookup.removeAttribute("data-lookup-nav-ready");
        filterInlineLookupMenu(lookup, rawTyped);
        applyInlineLookupPhantomFill(lookup, rawTyped);
        syncInlineLookupValue(lookup, rawTyped);
      });

      $("#registerBody").addEventListener("click", function(e) {
        const addBtn = e.target ? e.target.closest('button[data-edit-add-entry="1"]') : null;
        if (addBtn) {
          e.preventDefault();
          e.stopPropagation();
          addEntryToEditDraft("");
          return;
        }
        const removeBtn = e.target ? e.target.closest('button[data-edit-remove-entry="1"]') : null;
        if (removeBtn) {
          e.preventDefault();
          e.stopPropagation();
          removeEntryFromEditDraft(removeBtn.getAttribute("data-entry-id") || "");
          return;
        }
        const toggleBtn = e.target ? e.target.closest('button[data-status-cycle="1"]') : null;
        if (toggleBtn) {
          e.preventDefault();
          e.stopPropagation();
          cycleEntryStatus(toggleBtn.getAttribute("data-entry-id") || "");
          return;
        }
        const option = e.target ? e.target.closest(".inlineLookupOption") : null;
        if (!option) return;
        const lookup = option.closest(".inlineLookup");
        if (!lookup) return;
        chooseInlineLookupOption(lookup, option);
      });
      $("#registerBody").addEventListener("dblclick", function(e) {
        const toggleBtn = e.target ? e.target.closest('button[data-status-cycle="1"]') : null;
        if (!toggleBtn) return;
        e.preventDefault();
        e.stopPropagation();
      });

      document.addEventListener("click", function(e) {
        if (e.target && e.target.closest("#registerBody .inlineLookup")) return;
        closeInlineLookups();
      });
      document.addEventListener("keydown", function(e) {
        if (e.key !== "Escape") return;
        if (!state.recurrenceModalOpen) return;
        e.preventDefault();
        closeRecurrenceModal();
      });

      $("#pbUrl").value = store.get("pbUrl", "");
      $("#pbEmail").value = store.get("pbEmail", "");
      refillStatusFilterSelect();
      $("#perPage").value = String(state.perPage);
      updateRegisterPageInfo();

      (async function init() {
        setupRegisterSortHeaders();
        SESSION.base = ($("#pbUrl").value || "").trim().replace(/\/+$/, "");
        SESSION.token = (store.get("pbToken", "") || "").trim();

        if (SESSION.base && SESSION.token) {
          const ok = await validateCachedSession();
          if (ok) {
            setAuthenticatedUI(true);
            setStatus("ok", "Session restored via auth-refresh.");
            await refreshAll();
            return;
          }
          SESSION.token = "";
          store.del("pbToken");
        }

        setAuthenticatedUI(false);
        setStatus("warn", "Not logged in. Enter URL, email, and password.");
        setBusy();
      })();
    })();
  </script>
</body>
</html>
