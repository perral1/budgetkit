<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BudgetKit - Core Transaction Register</title>
  <style>
    :root {
      --bg: #0a0f16;
      --panel: #111a26;
      --panel2: #172335;
      --text: #e7edf6;
      --muted: #a8b7ca;
      --line: #2a3a52;
      --accent: #6ec1ff;
      --ok: #3ed598;
      --warn: #ffd479;
      --bad: #ff7f7f;
      --radius: 12px;
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--sans);
      color: var(--text);
      background: radial-gradient(circle at top right, #17263b 0%, #0a0f16 45%, #070b10 100%);
      min-height: 100vh;
    }
    .wrap { max-width: 1260px; margin: 0 auto; padding: 16px; }
    .topbar, .panel {
      border: 1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(17, 26, 38, 0.92);
      box-shadow: var(--shadow);
    }
    .topbar {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 12px;
      flex-wrap: wrap;
      padding: 12px;
    }
    h1 { margin: 0; font-size: 18px; }
    .sub { margin-top: 4px; color: var(--muted); font-size: 12px; }
    .auth {
      display: flex;
      gap: 8px;
      align-items: flex-end;
      flex-wrap: wrap;
    }
    .field { display: flex; flex-direction: column; gap: 5px; }
    label { color: var(--muted); font-size: 12px; }
    input[type="text"], input[type="password"], input[type="date"], select, textarea {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(23, 35, 53, 0.95);
      color: var(--text);
      padding: 8px 10px;
      outline: none;
    }
    input:focus, select:focus, textarea:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(110, 193, 255, 0.15); }
    textarea { min-height: 68px; resize: vertical; }
    .btn {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 12px;
      background: rgba(23, 35, 53, 0.95);
      color: var(--text);
      cursor: pointer;
      font-weight: 600;
    }
    .btn:hover { border-color: var(--accent); }
    .btn.primary { border-color: rgba(110, 193, 255, 0.55); background: rgba(110, 193, 255, 0.18); }
    .btn.danger { border-color: rgba(255, 127, 127, 0.55); background: rgba(255, 127, 127, 0.16); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .logout {
      display: none;
      color: var(--muted);
      text-decoration: none;
      font-size: 12px;
      margin-left: 8px;
    }
    .status {
      margin-top: 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 9px 10px;
      font-size: 13px;
      background: rgba(14, 22, 33, 0.75);
      color: var(--muted);
    }
    .status.ok { border-color: rgba(62, 213, 152, 0.45); color: #bdf7df; }
    .status.warn { border-color: rgba(255, 212, 121, 0.45); color: #ffeabc; }
    .status.bad { border-color: rgba(255, 127, 127, 0.45); color: #ffd1d1; }
    #app { display: none; margin-top: 12px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    .panel { padding: 12px; }
    .panel h2 { margin: 0 0 10px; font-size: 14px; }
    .line { display: flex; gap: 8px; flex-wrap: wrap; align-items: flex-end; }
    .line .field { min-width: 110px; }
    .mono { font-family: var(--mono); font-size: 12px; color: var(--muted); }
    .toolbar {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 10px;
    }
    table { width: 100%; border-collapse: collapse; table-layout: fixed; }
    th, td {
      border-bottom: 1px solid rgba(42, 58, 82, 0.75);
      padding: 9px 8px;
      font-size: 12px;
      text-align: left;
      vertical-align: top;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    th { color: var(--muted); font-size: 11px; text-transform: uppercase; letter-spacing: 0.2px; }
    th.sortable { cursor: pointer; user-select: none; }
    th.sortable:hover { color: var(--text); }
    th.sorted-asc::after { content: " \2191"; color: var(--accent); }
    th.sorted-desc::after { content: " \2193"; color: var(--accent); }
    tr.selected { background: rgba(110, 193, 255, 0.08); }
    tr.txn-parent td {
      background: rgba(110, 193, 255, 0.06);
      border-bottom: 0;
      font-weight: 600;
    }
    tr.txn-sub td {
      background: rgba(110, 193, 255, 0.03);
      border-bottom: 0;
    }
    tr.txn-sub td:nth-child(3),
    tr.txn-sub td:nth-child(4) { padding-left: 20px; }
    tr.txn-sub-end td { border-bottom: 1px solid rgba(42, 58, 82, 0.75); }
    tr.txn-edit td {
      background: rgba(255, 212, 121, 0.08);
      border-bottom: 0;
      vertical-align: middle;
      overflow: visible;
    }
    tr.txn-edit-end td { border-bottom: 1px solid rgba(42, 58, 82, 0.75); }
    .inlineInput, .inlineSelect {
      width: 100%;
      min-width: 0;
      height: 30px;
      border: 1px solid var(--line);
      border-radius: 8px;
      background: rgba(23, 35, 53, 0.95);
      color: var(--text);
      padding: 5px 8px;
      margin: 0;
      font-size: 12px;
      line-height: 1.2;
      box-sizing: border-box;
      display: block;
    }
    .inlineSelect {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }
    .inlineLookup {
      position: relative;
      width: 100%;
    }
    .inlineLookupMenu {
      position: absolute;
      left: 0;
      right: 0;
      top: calc(100% + 2px);
      max-height: 180px;
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 8px;
      background: rgba(17, 26, 38, 0.98);
      box-shadow: var(--shadow);
      z-index: 40;
      display: none;
    }
    .inlineLookup.open .inlineLookupMenu {
      display: block;
    }
    .inlineLookupOption {
      display: block;
      width: 100%;
      border: 0;
      border-bottom: 1px solid rgba(42, 58, 82, 0.6);
      background: transparent;
      color: var(--text);
      text-align: left;
      padding: 7px 8px;
      font-size: 12px;
      cursor: pointer;
    }
    .inlineLookupOption:last-child {
      border-bottom: 0;
    }
    .inlineLookupOption:hover,
    .inlineLookupOption:focus {
      background: rgba(110, 193, 255, 0.14);
      outline: none;
    }
    .inlineLookupOption.active {
      background: rgba(110, 193, 255, 0.2);
    }
    .inlineLookupEmpty {
      padding: 7px 8px;
      color: var(--muted);
      font-size: 11px;
      display: none;
    }
    .pill {
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 2px 7px;
      font-size: 11px;
      display: inline-flex;
      align-items: center;
    }
    .help { color: var(--muted); font-size: 12px; line-height: 1.35; }
    .pager {
      margin-top: 10px;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .pager .spacer { flex: 1 1 auto; }
    @media (max-width: 1080px) {
      .grid { grid-template-columns: 1fr; }
    }
    @media (max-width: 760px) {
      .auth input[type="text"], .auth input[type="password"] { width: 100%; }
      .auth .field { min-width: 100%; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1>Core Transaction Register <a class="logout" id="logoutLink" href="#">logout</a></h1>
        <div class="sub">Transactions (`txns`) and entries (`entries`) with multi-entry support.</div>
      </div>
      <div class="auth" id="authPanel">
        <div class="field">
          <label for="pbUrl">URL</label>
          <input id="pbUrl" type="text" placeholder="http://127.0.0.1:8090" />
        </div>
        <div class="field">
          <label for="pbEmail">Email</label>
          <input id="pbEmail" type="text" placeholder="you@example.com" />
        </div>
        <div class="field">
          <label for="pbPass">Password</label>
          <input id="pbPass" type="password" placeholder="password" />
        </div>
        <button class="btn primary" id="btnLogin">Login</button>
      </div>
    </div>

    <div class="status" id="statusBox">Not authenticated.</div>

    <div id="app">
      <div class="grid">
        <section class="panel">
          <div class="toolbar">
            <h2 style="margin:0;">Register</h2>
            <div class="line">
              <button class="btn primary" id="btnNewTxn" type="button">New Transaction</button>
              <button class="btn primary" id="btnEditSave" type="button" style="display:none;">Save Edit</button>
              <button class="btn" id="btnEditCancel" type="button" style="display:none;">Cancel</button>
              <button class="btn" id="btnRefresh">Refresh</button>
              <button class="btn danger" id="btnDeleteTxn" disabled>Delete selected txn</button>
            </div>
          </div>

          <div class="line" style="margin-bottom:8px;">
            <div class="field">
              <label for="fltFrom">From</label>
              <input id="fltFrom" type="date" />
            </div>
            <div class="field">
              <label for="fltTo">To</label>
              <input id="fltTo" type="date" />
            </div>
            <div class="field">
              <label for="fltAccount">Account</label>
              <select id="fltAccount"></select>
            </div>
            <div class="field">
              <label for="fltCategory">Category</label>
              <select id="fltCategory"></select>
            </div>
            <div class="field">
              <label for="fltStatus">Status</label>
              <select id="fltStatus">
                <option value="">(any)</option>
                <option value="pending">pending</option>
                <option value="cleared">cleared</option>
              </select>
            </div>
            <div class="field">
              <label for="fltBudgetOnly">Budget kinds</label>
              <select id="fltBudgetOnly">
                <option value="0">All entries</option>
                <option value="1">Income/Expense only</option>
              </select>
            </div>
          </div>

          <div style="overflow:auto;">
            <table id="registerTable">
              <colgroup>
                <col style="width:11%;" />
                <col style="width:18%;" />
                <col style="width:14%;" />
                <col style="width:16%;" />
                <col style="width:17%;" />
                <col style="width:13%;" />
                <col style="width:9%;" />
              </colgroup>
              <thead>
                <tr>
                  <th data-sort="date">Date</th>
                  <th data-sort="account">Account</th>
                  <th data-sort="payee">Payee</th>
                  <th data-sort="category">Category</th>
                  <th data-sort="memo">Memo</th>
                  <th data-sort="amount">Amount</th>
                  <th data-sort="status">Status</th>
                </tr>
              </thead>
              <tbody id="registerBody"></tbody>
            </table>
          </div>
          <div class="help" id="resultCount" style="margin-top:10px;"></div>
          <div class="pager">
            <button class="btn" id="btnPrevPage" type="button">Prev</button>
            <button class="btn" id="btnNextPage" type="button">Next</button>
            <span class="mono" id="pageInfo">Page 1 of 1</span>
            <div class="spacer"></div>
            <label class="mono" for="perPage">Rows/page</label>
            <select id="perPage">
              <option value="50">50</option>
              <option value="100" selected>100</option>
              <option value="200">200</option>
            </select>
          </div>
        </section>
      </div>
    </div>
  </div>

  <script>
    (function() {
      const $ = (s, el) => (el || document).querySelector(s);
      const $$ = (s, el) => Array.from((el || document).querySelectorAll(s));

      const store = {
        get(k, d) { try { const v = localStorage.getItem(k); return v == null ? d : v; } catch { return d; } },
        set(k, v) { try { localStorage.setItem(k, v); } catch {} },
        del(k) { try { localStorage.removeItem(k); } catch {} }
      };

      const SESSION = { base: "", token: "" };
      const state = {
        loading: false,
        saving: false,
        deleting: false,
        accounts: [],
        accountById: new Map(),
        assets: [],
        assetPrecisionById: new Map(),
        categories: [],
        categoryById: new Map(),
        payees: [],
        payeeById: new Map(),
        txns: new Map(),
        entries: [],
        selectedTxnIds: [],
        selectionAnchorTxnId: "",
        visibleTxnOrder: [],
        editingTxnId: "",
        editDraft: null,
        pendingFocusKey: "",
        sort: { column: "date", direction: "desc" },
        page: 1,
        perPage: 100,
        totalPages: 1,
        totalItems: 0
      };

      function escapeHtml(v) {
        return String(v == null ? "" : v)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      function normalizeDateToNoonUtc(dateStr) {
        return dateStr + "T12:00:00Z";
      }

      function fmtDate(dateValue) {
        if (!dateValue) return "";
        const d = new Date(dateValue);
        if (isNaN(d.getTime())) return String(dateValue);
        return d.toISOString().slice(0, 10);
      }

      function normalizePrecision(raw) {
        const n = Number(raw);
        if (Number.isInteger(n) && n >= 0 && n <= 9) return n;
        return 2;
      }

      function assetPrecision(assetId) {
        return state.assetPrecisionById.get(String(assetId || "")) ?? 2;
      }

      function parseMinorInt(raw, fieldName) {
        const n = Number(raw);
        if (!Number.isFinite(n) || !Number.isSafeInteger(n)) {
          throw new Error(fieldName + " must be a fixed-precision integer in minor units.");
        }
        return n;
      }

      function parseMajorToMinor(raw, precision) {
        let s = String(raw == null ? "" : raw).trim();
        if (!s) throw new Error("Amount is required.");
        s = s.replaceAll(",", "").replaceAll("$", "").trim();
        if (/^\(.*\)$/.test(s)) s = "-" + s.slice(1, -1);
        if (!/^-?\d+(\.\d+)?$/.test(s)) throw new Error("Amount must be numeric.");

        const neg = s.startsWith("-");
        const unsigned = neg ? s.slice(1) : s;
        const parts = unsigned.split(".");
        const whole = parts[0] || "0";
        const frac = parts[1] || "";
        if (frac.length > precision) throw new Error("Amount has more than " + precision + " decimal places.");

        const scale = 10 ** precision;
        const wholeNum = Number(whole);
        const fracNum = frac ? Number(frac.padEnd(precision, "0")) : 0;
        if (!Number.isFinite(wholeNum) || !Number.isFinite(fracNum)) throw new Error("Amount must be numeric.");
        const minor = wholeNum * scale + fracNum;
        if (!Number.isSafeInteger(minor)) throw new Error("Amount is too large.");
        return neg ? -minor : minor;
      }

      function minorToMajor(minor, precision) {
        const n = Number(minor || 0);
        if (!Number.isFinite(n)) return 0;
        return n / (10 ** precision);
      }

      function fmtMinor(minor, precision) {
        const n = Number(minor || 0);
        if (!Number.isFinite(n)) return "";
        const scale = 10 ** precision;
        const sign = n < 0 ? "-" : "";
        const abs = Math.abs(Math.trunc(n));
        const whole = Math.floor(abs / scale);
        if (precision === 0) return sign + whole.toLocaleString();
        const frac = String(abs % scale).padStart(precision, "0");
        return sign + whole.toLocaleString() + "." + frac;
      }

      function setStatus(kind, message) {
        const box = $("#statusBox");
        box.className = "status" + (kind ? " " + kind : "");
        box.textContent = message;
      }

      function classifyError(err) {
        if (!err || typeof err !== "object") return { kind: "bad", message: String(err || "Unknown error") };
        if (err.kind === "network") return { kind: "bad", message: "Network error: check URL, protocol (http/https), host, and CORS." };
        if (err.kind === "auth") return { kind: "bad", message: "Auth failure: session expired or credentials/token were rejected." };
        if (err.kind === "query") return { kind: "warn", message: "Query/schema mismatch (HTTP 400): fallback query was used." };
        return { kind: "bad", message: err.message || "Request failed." };
      }

      async function pbFetch(path, options) {
        if (!SESSION.base) {
          const e = new Error("PocketBase URL is required.");
          e.kind = "auth";
          throw e;
        }

        const headers = Object.assign({ "Content-Type": "application/json" }, (options && options.headers) || {});
        if (SESSION.token) headers["Authorization"] = /^Bearer\s+/i.test(SESSION.token) ? SESSION.token : ("Bearer " + SESSION.token);

        let res;
        try {
          res = await fetch(SESSION.base + path, Object.assign({}, options || {}, { headers }));
        } catch (error) {
          const e = new Error("Network error (fetch failed): " + (error && error.message ? error.message : String(error)));
          e.kind = "network";
          throw e;
        }

        const text = await res.text();
        let data = null;
        try { data = text ? JSON.parse(text) : null; } catch { data = text; }

        if (!res.ok) {
          const e = new Error("HTTP " + res.status + ": " + (typeof data === "string" ? data : JSON.stringify(data || {})));
          e.status = res.status;
          if (res.status === 401 || res.status === 403) e.kind = "auth";
          else if (res.status === 400) e.kind = "query";
          else e.kind = "bad";
          throw e;
        }

        return data;
      }

      function toQS(params) {
        return Object.keys(params)
          .filter((k) => params[k] !== "" && params[k] != null)
          .map((k) => encodeURIComponent(k) + "=" + encodeURIComponent(params[k]))
          .join("&");
      }

      async function listRecordsPageSafe(collection, opts) {
        const options = opts || {};
        const perPage = options.perPage || 200;
        const page = options.page || 1;

        const attemptOne = {
          page: page,
          perPage: perPage,
          filter: options.filter || "",
          sort: options.sort || "",
          expand: options.expand || ""
        };
        const attemptTwo = {
          page: page,
          perPage: perPage,
          sort: options.sort || "",
          expand: options.expand || ""
        };
        const attemptThree = { page: page, perPage: perPage };

        async function runAttempt(q) {
          const qs = toQS(q);
          const data = await pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records?" + qs, { method: "GET" });
          return {
            items: (data && data.items) ? data.items : [],
            page: Math.max(1, Number((data && data.page) || page)),
            perPage: Math.max(1, Number((data && data.perPage) || perPage)),
            totalPages: Math.max(1, Number((data && data.totalPages) || 1)),
            totalItems: Math.max(0, Number((data && data.totalItems) || 0))
          };
        }

        try {
          return await runAttempt(attemptOne);
        } catch (e1) {
          if (e1 && e1.status === 400) {
            try {
              setStatus("warn", "Adjusted listing query after HTTP 400 (schema/filter mismatch). Loaded with fewer filters.");
              return await runAttempt(attemptTwo);
            } catch (e2) {
              if (e2 && e2.status === 400) {
                setStatus("warn", "Adjusted listing query again after HTTP 400. Loaded with no filter/sort constraints.");
                return await runAttempt(attemptThree);
              }
              throw e2;
            }
          }
          throw e1;
        }
      }

      async function listRecordsSafe(collection, opts) {
        const options = Object.assign({}, opts || {});
        const perPage = options.perPage || 200;
        const first = await listRecordsPageSafe(collection, Object.assign({}, options, { page: 1, perPage: perPage }));
        const all = (first.items || []).slice();
        let page = 2;
        while (page <= first.totalPages) {
          const next = await listRecordsPageSafe(collection, Object.assign({}, options, { page: page, perPage: perPage }));
          all.push(...(next.items || []));
          page += 1;
        }
        return all;
      }

      async function createRecord(collection, body) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records", {
          method: "POST",
          body: JSON.stringify(body)
        });
      }

      async function updateRecord(collection, id, body) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records/" + encodeURIComponent(id), {
          method: "PATCH",
          body: JSON.stringify(body)
        });
      }

      async function getRecord(collection, id) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records/" + encodeURIComponent(id), { method: "GET" });
      }

      async function deleteRecord(collection, id) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records/" + encodeURIComponent(id), { method: "DELETE" });
      }

      async function authWithPassword(email, password) {
        return pbFetch("/api/collections/users/auth-with-password", {
          method: "POST",
          body: JSON.stringify({ identity: email, password: password })
        });
      }

      async function authRefresh() {
        return pbFetch("/api/collections/users/auth-refresh", { method: "POST" });
      }

      function setAuthenticatedUI(isLoggedIn) {
        $("#authPanel").style.display = isLoggedIn ? "none" : "flex";
        $("#logoutLink").style.display = isLoggedIn ? "inline" : "none";
        $("#app").style.display = isLoggedIn ? "block" : "none";
      }

      function setBusy() {
        const editing = !!state.editingTxnId;
        const disabled = !SESSION.token || state.loading || state.saving || state.deleting || editing;
        ["#btnRefresh", "#btnNewTxn", "#btnLogin"].forEach((sel) => {
          const el = $(sel);
          if (el) el.disabled = disabled && sel !== "#btnLogin";
        });
        ["#fltFrom", "#fltTo", "#fltAccount", "#fltCategory", "#fltStatus", "#fltBudgetOnly"].forEach((sel) => {
          const el = $(sel);
          if (el) el.disabled = disabled;
        });
        const canDelete = !!SESSION.token && state.selectedTxnIds.length > 0 && !state.loading && !state.saving && !state.deleting && !editing;
        $("#btnDeleteTxn").disabled = !canDelete;
        const btnEditSave = $("#btnEditSave");
        const btnEditCancel = $("#btnEditCancel");
        if (btnEditSave) btnEditSave.style.display = editing ? "inline-flex" : "none";
        if (btnEditCancel) btnEditCancel.style.display = editing ? "inline-flex" : "none";
        if (btnEditSave) btnEditSave.disabled = !editing || state.saving || state.loading || state.deleting;
        if (btnEditCancel) btnEditCancel.disabled = !editing || state.saving || state.loading || state.deleting;
        $("#btnPrevPage").disabled = disabled || state.page <= 1;
        $("#btnNextPage").disabled = disabled || state.page >= state.totalPages;
        $("#perPage").disabled = disabled;
      }

      function refillFilterSelect(selId, list, placeholder, labelFn) {
        const sel = $(selId);
        const current = sel.value;
        sel.innerHTML = '<option value="">' + escapeHtml(placeholder) + '</option>' + list.map((item) => '<option value="' + escapeHtml(item.id) + '">' + escapeHtml(labelFn(item)) + '</option>').join("");
        sel.value = current;
      }

      function buildEntriesFilter() {
        const out = [];
        const account = $("#fltAccount").value;
        const category = $("#fltCategory").value;
        const status = $("#fltStatus").value;
        const from = $("#fltFrom").value;
        const to = $("#fltTo").value;

        if (account) out.push('account = "' + account.replaceAll('"', '\\"') + '"');
        if (category) out.push('category = "' + category.replaceAll('"', '\\"') + '"');
        if (status) out.push('status = "' + status.replaceAll('"', '\\"') + '"');
        if (from) out.push('date >= "' + normalizeDateToNoonUtc(from) + '"');
        if (to) out.push('date <= "' + normalizeDateToNoonUtc(to) + '"');
        return out.join(" && ");
      }

      function filteredClientSide(entries) {
        const budgetOnly = $("#fltBudgetOnly").value === "1";
        if (!budgetOnly) return entries;

        return entries.filter((e) => {
          const c = getCategoryById(e.category);
          const a = getAccountById(e.account);
          if (!c || !a) return false;
          return (c.kind === "income" || c.kind === "expense") && a.type !== "virtual";
        });
      }

      async function loadReferenceData() {
        const [accounts, assets, categories, payees] = await Promise.all([
          listRecordsSafe("accounts", { filter: "is_archived = false", sort: "name", perPage: 500 }),
          listRecordsSafe("assets", { sort: "symbol", perPage: 500 }),
          listRecordsSafe("categories", { filter: "is_archived = false", sort: "name", perPage: 500 }),
          listRecordsSafe("payees", { filter: "is_archived = false", sort: "name", perPage: 500 })
        ]);
        state.accounts = accounts;
        state.accountById = new Map(state.accounts.map((a) => [String(a.id), a]));
        state.assets = assets;
        state.assetPrecisionById = new Map(state.assets.map((a) => [String(a.id), normalizePrecision(a.precision)]));
        state.categories = categories;
        state.categoryById = new Map(state.categories.map((c) => [String(c.id), c]));
        state.payees = payees;
        state.payeeById = new Map(state.payees.map((p) => [String(p.id), p]));

        refillFilterSelect("#fltAccount", state.accounts, "(all accounts)", (a) => accountLabel(a, false));
        refillFilterSelect("#fltCategory", state.categories, "(all categories)", (c) => categoryLabel(c, false));
      }

      async function loadRegister() {
        const entriesFilter = buildEntriesFilter();
        let entriesRes = await listRecordsPageSafe("entries", {
          filter: entriesFilter,
          sort: registerServerSortExpr(),
          perPage: state.perPage,
          page: state.page
        });
        if (state.page > entriesRes.totalPages) {
          state.page = entriesRes.totalPages;
          entriesRes = await listRecordsPageSafe("entries", {
            filter: entriesFilter,
            sort: registerServerSortExpr(),
            perPage: state.perPage,
            page: state.page
          });
        }
        state.totalPages = entriesRes.totalPages;
        state.totalItems = entriesRes.totalItems;
        updateRegisterPageInfo();

        const entries = entriesRes.items || [];
        await ensureAccountsLoaded(entries.map((e) => e && e.account));
        await ensureCategoriesLoaded(entries.map((e) => e && e.category));

        const filtered = filteredClientSide(entries);
        filtered.forEach((e) => {
          parseMinorInt(e && e.qty, "entries.qty");
        });
        state.entries = filtered;
        state.txns = new Map();
        await backfillMissingLinkedTxns(state.entries);
        await ensurePayeesLoaded(Array.from(state.txns.values()).map((t) => t && t.payee));

        renderRegister();
      }

      async function backfillMissingLinkedTxns(entries) {
        const missingIds = Array.from(new Set(
          (entries || [])
            .map((e) => String(e && e.txn ? e.txn : ""))
            .filter((txnId) => txnId && !state.txns.has(txnId))
        ));
        if (!missingIds.length) return;

        const batchSize = 25;
        for (let i = 0; i < missingIds.length; i += batchSize) {
          const batch = missingIds.slice(i, i + batchSize);
          const rows = await Promise.all(batch.map(async (txnId) => {
            try {
              return await getRecord("txns", txnId);
            } catch {
              return null;
            }
          }));
          rows.forEach((txn) => {
            if (txn && txn.id) state.txns.set(txn.id, txn);
          });
        }
      }

      function fieldOrNull(v) {
        const s = String(v == null ? "" : v).trim();
        return s ? s : null;
      }

      function accountLabel(account, includeArchivedTag) {
        const base = (account && (account.name || account.id)) || "";
        const type = (account && account.type) || "other";
        const archivedTag = includeArchivedTag && account && account.is_archived ? " [archived]" : "";
        return base + " (" + type + ")" + archivedTag;
      }

      function categoryLabel(category, includeArchivedTag) {
        const base = (category && (category.name || category.id)) || "";
        const kind = (category && category.kind) || "other";
        const archivedTag = includeArchivedTag && category && category.is_archived ? " [archived]" : "";
        return base + " [" + kind + "]" + archivedTag;
      }

      function payeeLabel(payee, includeArchivedTag) {
        const base = (payee && (payee.name || payee.id)) || "";
        const card = payee && payee.card_category ? " {" + payee.card_category + "}" : "";
        const archivedTag = includeArchivedTag && payee && payee.is_archived ? " [archived]" : "";
        return base + card + archivedTag;
      }

      function getAccountById(accountId) {
        return state.accountById.get(String(accountId || "")) || null;
      }

      function accountDisplayName(accountId) {
        const a = getAccountById(accountId);
        return (a && (a.name || a.id)) || String(accountId || "");
      }

      function getCategoryById(categoryId) {
        return state.categoryById.get(String(categoryId || "")) || null;
      }

      function categoryDisplayName(categoryId) {
        const c = getCategoryById(categoryId);
        return (c && (c.name || c.id)) || String(categoryId || "");
      }

      function getPayeeById(payeeId) {
        return state.payeeById.get(String(payeeId || "")) || null;
      }

      function payeeDisplayName(payeeId) {
        const p = getPayeeById(payeeId);
        return (p && (p.name || p.id)) || String(payeeId || "");
      }

      function getEntryAssetId(entry) {
        return String((entry && entry.asset) || "");
      }

      function qtyMajorForEntry(entry) {
        const precision = assetPrecision(getEntryAssetId(entry));
        return minorToMajor(parseMinorInt(entry && entry.qty, "entries.qty"), precision);
      }

      function editableAccountOptions(selectedAccountId) {
        const selectedId = String(selectedAccountId || "");
        if (!selectedId) return state.accounts.slice();
        if (state.accounts.some((a) => String(a.id) === selectedId)) return state.accounts.slice();
        const selected = getAccountById(selectedId);
        if (!selected) return state.accounts.slice();
        return state.accounts.concat([selected]);
      }

      function editableCategoryOptions(selectedCategoryId) {
        const selectedId = String(selectedCategoryId || "");
        if (!selectedId) return state.categories.slice();
        if (state.categories.some((c) => String(c.id) === selectedId)) return state.categories.slice();
        const selected = getCategoryById(selectedId);
        if (!selected) return state.categories.slice();
        return state.categories.concat([selected]);
      }

      function editablePayeeOptions(selectedPayeeId) {
        const selectedId = String(selectedPayeeId || "");
        if (!selectedId) return state.payees.slice();
        if (state.payees.some((p) => String(p.id) === selectedId)) return state.payees.slice();
        const selected = getPayeeById(selectedId);
        if (!selected) return state.payees.slice();
        return state.payees.concat([selected]);
      }

      async function ensureAccountsLoaded(accountIds) {
        const missingIds = Array.from(new Set(
          (accountIds || [])
            .map((id) => String(id || ""))
            .filter((id) => id && !state.accountById.has(id))
        ));
        if (!missingIds.length) return;

        const batchSize = 25;
        for (let i = 0; i < missingIds.length; i += batchSize) {
          const batch = missingIds.slice(i, i + batchSize);
          const rows = await Promise.all(batch.map(async (accountId) => {
            try {
              return await getRecord("accounts", accountId);
            } catch {
              return null;
            }
          }));
          rows.forEach((account) => {
            if (account && account.id) state.accountById.set(String(account.id), account);
          });
        }
      }

      async function ensureCategoriesLoaded(categoryIds) {
        const missingIds = Array.from(new Set(
          (categoryIds || [])
            .map((id) => String(id || ""))
            .filter((id) => id && !state.categoryById.has(id))
        ));
        if (!missingIds.length) return;

        const batchSize = 25;
        for (let i = 0; i < missingIds.length; i += batchSize) {
          const batch = missingIds.slice(i, i + batchSize);
          const rows = await Promise.all(batch.map(async (categoryId) => {
            try {
              return await getRecord("categories", categoryId);
            } catch {
              return null;
            }
          }));
          rows.forEach((category) => {
            if (category && category.id) state.categoryById.set(String(category.id), category);
          });
        }
      }

      async function ensurePayeesLoaded(payeeIds) {
        const missingIds = Array.from(new Set(
          (payeeIds || [])
            .map((id) => String(id || ""))
            .filter((id) => id && !state.payeeById.has(id))
        ));
        if (!missingIds.length) return;

        const batchSize = 25;
        for (let i = 0; i < missingIds.length; i += batchSize) {
          const batch = missingIds.slice(i, i + batchSize);
          const rows = await Promise.all(batch.map(async (payeeId) => {
            try {
              return await getRecord("payees", payeeId);
            } catch {
              return null;
            }
          }));
          rows.forEach((payee) => {
            if (payee && payee.id) state.payeeById.set(String(payee.id), payee);
          });
        }
      }

      function optionList(items, selected, labelFn, includeBlank) {
        let html = "";
        if (includeBlank) html += '<option value=""></option>';
        html += items.map((item) => {
          const value = String(item.id);
          const isSel = String(selected || "") === value ? " selected" : "";
          return '<option value="' + escapeHtml(value) + '"' + isSel + '>' + escapeHtml(labelFn(item)) + "</option>";
        }).join("");
        return html;
      }

      function inlineLookupMarkup(items, selectedId, labelFn, dataEditKey, includeBlank, placeholder) {
        const normalizedSelectedId = String(selectedId || "");
        const options = [];
        if (includeBlank) options.push({ value: "", label: "" });
        (items || []).forEach((item) => {
          options.push({ value: String(item.id), label: labelFn(item) });
        });

        let selectedLabel = "";
        const selectedOpt = options.find((opt) => opt.value === normalizedSelectedId);
        if (selectedOpt) selectedLabel = selectedOpt.label;

        const optionHtml = options.map((opt) => {
          const display = opt.label || "(none)";
          const lower = display.toLocaleLowerCase();
          return '<button type="button" class="inlineLookupOption" data-lookup-static="1" data-lookup-value="' + escapeHtml(opt.value) + '" data-lookup-label="' + escapeHtml(lower) + '">' + escapeHtml(display) + "</button>";
        }).join("");
        const collection = dataEditKey === "entry-account"
          ? "accounts"
          : (dataEditKey === "entry-category"
            ? "categories"
            : (dataEditKey === "txn-payee" ? "payees" : ""));

        return [
          '<div class="inlineLookup" data-lookup-root="1" data-lookup-collection="' + escapeHtml(collection) + '">',
          '<input class="inlineInput" type="text" data-lookup-input="1" data-lookup-for="' + escapeHtml(dataEditKey) + '" value="' + escapeHtml(selectedLabel) + '" placeholder="' + escapeHtml(placeholder || "") + '" autocomplete="off" />',
          '<input type="hidden" data-edit="' + escapeHtml(dataEditKey) + '" value="' + escapeHtml(normalizedSelectedId) + '" />',
          '<div class="inlineLookupMenu" data-lookup-menu="1">',
          optionHtml,
          '<div class="inlineLookupEmpty">No matches</div>',
          "</div>",
          "</div>"
        ].join("");
      }

      function closeInlineLookups(except) {
        $$(".inlineLookup.open", $("#registerBody")).forEach((el) => {
          if (except && (el === except || el.contains(except))) return;
          el.classList.remove("open");
          el.removeAttribute("data-lookup-nav-ready");
        });
      }

      function normalizeLookupText(raw) {
        return String(raw == null ? "" : raw).trim().toLocaleLowerCase();
      }

      function encodeLookupCreateToken(collection, name) {
        return "__create__|" + String(collection || "") + "|" + encodeURIComponent(String(name || ""));
      }

      function parseLookupCreateToken(value) {
        const raw = String(value || "");
        if (!raw.startsWith("__create__|")) return null;
        const parts = raw.split("|");
        if (parts.length < 3) return null;
        return {
          collection: parts[1] || "",
          name: decodeURIComponent(parts.slice(2).join("|") || "")
        };
      }

      function fuzzyLookupScore(label, query) {
        if (!query) return 0;
        const text = normalizeLookupText(label);
        const term = normalizeLookupText(query);
        if (!text || !term) return 0;

        let qi = 0;
        let score = 0;
        let lastMatchAt = -2;
        let firstMatchAt = -1;
        let lastMatchPos = -1;

        for (let i = 0; i < text.length && qi < term.length; i += 1) {
          if (text[i] !== term[qi]) continue;
          if (firstMatchAt === -1) firstMatchAt = i;
          if (i === lastMatchAt + 1) score += 6;
          else score += 3;
          if (i === 0 || text[i - 1] === " " || text[i - 1] === "-" || text[i - 1] === "[" || text[i - 1] === "(") score += 2;
          lastMatchAt = i;
          lastMatchPos = i;
          qi += 1;
        }

        if (qi < term.length) return -1;
        const span = Math.max(0, lastMatchPos - firstMatchAt);
        score -= span * 0.08;
        score -= firstMatchAt * 0.12;
        return score;
      }

      function firstVisibleLookupOption(lookup) {
        return $$(".inlineLookupOption", lookup).find((btn) => btn.style.display !== "none") || null;
      }

      function visibleLookupOptions(lookup) {
        return $$(".inlineLookupOption", lookup).filter((btn) => btn.style.display !== "none");
      }

      function activeLookupOption(lookup) {
        const visible = visibleLookupOptions(lookup);
        return visible.find((btn) => btn.classList.contains("active")) || null;
      }

      function setActiveLookupOption(lookup, optionBtn) {
        const visible = visibleLookupOptions(lookup);
        visible.forEach((btn) => btn.classList.remove("active"));
        if (!optionBtn) return;
        optionBtn.classList.add("active");
        try { optionBtn.scrollIntoView({ block: "nearest" }); } catch {}
      }

      function moveActiveLookupOption(lookup, direction) {
        const visible = visibleLookupOptions(lookup);
        if (!visible.length) return null;
        const current = activeLookupOption(lookup);
        const idx = current ? visible.indexOf(current) : -1;
        let nextIdx = 0;
        if (idx === -1) nextIdx = direction > 0 ? 0 : visible.length - 1;
        else if (direction > 0) nextIdx = Math.min(visible.length - 1, idx + 1);
        else nextIdx = Math.max(0, idx - 1);
        const next = visible[nextIdx];
        setActiveLookupOption(lookup, next);
        return next;
      }

      function syncInlineLookupValue(lookup, rawOverride) {
        if (!lookup) return;
        const textInput = $('[data-lookup-input="1"]', lookup);
        const hidden = $('input[type="hidden"][data-edit]', lookup);
        if (!textInput || !hidden) return;
        const raw = normalizeLookupText(rawOverride == null ? textInput.value : rawOverride);
        if (!raw) {
          hidden.value = "";
          return;
        }
        const exact = $$(".inlineLookupOption[data-lookup-static=\"1\"]", lookup).find((btn) => (btn.getAttribute("data-lookup-label") || "") === raw);
        hidden.value = exact ? (exact.getAttribute("data-lookup-value") || "") : "";
      }

      function filterInlineLookupMenu(lookup, queryOverride) {
        if (!lookup) return;
        const textInput = $('[data-lookup-input="1"]', lookup);
        if (!textInput) return;
        const menu = $('[data-lookup-menu="1"]', lookup);
        if (!menu) return;
        const term = String(queryOverride == null ? textInput.value : queryOverride);
        const termNorm = normalizeLookupText(term);
        const collection = lookup.getAttribute("data-lookup-collection") || "";
        const existingCreate = $(".inlineLookupOption[data-lookup-create=\"1\"]", lookup);
        if (existingCreate) existingCreate.remove();
        const ranked = [];
        $$(".inlineLookupOption[data-lookup-static=\"1\"]", lookup).forEach((btn) => {
          const label = btn.getAttribute("data-lookup-label") || "";
          const score = fuzzyLookupScore(label, term);
          if (score < 0) {
            btn.style.display = "none";
            btn.classList.remove("active");
            return;
          }
          ranked.push({ btn: btn, score: score, label: label });
        });
        ranked.sort((a, b) => {
          if (b.score !== a.score) return b.score - a.score;
          return a.label.localeCompare(b.label, undefined, { sensitivity: "base", numeric: true });
        });
        const wantCreate = !!termNorm && !!collection;
        const maxMatches = Math.max(0, 50 - (wantCreate ? 1 : 0));
        const limited = ranked.slice(0, maxMatches);
        limited.forEach((item, idx) => {
          item.btn.style.display = "block";
          item.btn.classList.toggle("active", idx === 0);
          menu.appendChild(item.btn);
        });
        if (ranked.length > maxMatches) {
          ranked.slice(maxMatches).forEach((item) => {
            item.btn.style.display = "none";
            item.btn.classList.remove("active");
          });
        }
        if (wantCreate) {
          const createBtn = document.createElement("button");
          createBtn.type = "button";
          createBtn.className = "inlineLookupOption";
          createBtn.setAttribute("data-lookup-create", "1");
          createBtn.setAttribute("data-lookup-create-name", term);
          createBtn.setAttribute("data-lookup-value", encodeLookupCreateToken(collection, term));
          createBtn.setAttribute("data-lookup-label", normalizeLookupText(term));
          createBtn.textContent = '+ Add "' + term + '"';
          if (!limited.length) createBtn.classList.add("active");
          menu.appendChild(createBtn);
        }
        const empty = $(".inlineLookupEmpty", lookup);
        const visibleCount = limited.length + (wantCreate ? 1 : 0);
        if (empty) empty.style.display = visibleCount ? "none" : "block";
      }

      function applyInlineLookupPhantomFill(lookup, rawTyped) {
        if (!lookup) return;
        const textInput = $('[data-lookup-input="1"]', lookup);
        if (!textInput) return;
        const top = firstVisibleLookupOption(lookup);
        const typed = String(rawTyped == null ? "" : rawTyped);
        if (!top || !typed) return;
        if (top.getAttribute("data-lookup-create") === "1") return;
        const candidate = top.textContent === "(none)" ? "" : String(top.textContent || "");
        if (!candidate) return;
        if (!normalizeLookupText(candidate).startsWith(normalizeLookupText(typed))) return;
        textInput.value = candidate;
        try { textInput.setSelectionRange(typed.length, candidate.length); } catch {}
      }

      function previewInlineLookupOption(lookup, optionBtn, rawTyped) {
        if (!lookup || !optionBtn) return;
        const textInput = $('[data-lookup-input="1"]', lookup);
        if (!textInput) return;
        const typed = String(rawTyped == null ? "" : rawTyped);
        if (optionBtn.getAttribute("data-lookup-create") === "1") {
          textInput.value = typed;
          try { textInput.setSelectionRange(typed.length, typed.length); } catch {}
          return;
        }
        const candidate = optionBtn.textContent === "(none)" ? "" : String(optionBtn.textContent || "");
        if (!candidate) {
          textInput.value = "";
          return;
        }
        textInput.value = candidate;
        const typedNorm = normalizeLookupText(typed);
        const candNorm = normalizeLookupText(candidate);
        if (typed && candNorm.startsWith(typedNorm)) {
          try { textInput.setSelectionRange(typed.length, candidate.length); } catch {}
          return;
        }
        try { textInput.setSelectionRange(candidate.length, candidate.length); } catch {}
      }

      function chooseInlineLookupOption(lookup, optionBtn) {
        if (!lookup || !optionBtn) return;
        const textInput = $('[data-lookup-input="1"]', lookup);
        const hidden = $('input[type="hidden"][data-edit]', lookup);
        if (!textInput || !hidden) return;
        const value = optionBtn.getAttribute("data-lookup-value") || "";
        const display = optionBtn.getAttribute("data-lookup-create") === "1"
          ? (optionBtn.getAttribute("data-lookup-create-name") || "")
          : (optionBtn.textContent === "(none)" ? "" : optionBtn.textContent);
        hidden.value = value;
        textInput.value = display;
        lookup.setAttribute("data-lookup-typed", display);
        lookup.setAttribute("data-lookup-searching", "0");
        lookup.classList.remove("open");
        lookup.removeAttribute("data-lookup-nav-ready");
      }

      function restoreInlineLookupOriginal(lookup) {
        if (!lookup) return;
        const textInput = $('[data-lookup-input="1"]', lookup);
        const hidden = $('input[type="hidden"][data-edit]', lookup);
        if (!textInput || !hidden) return;
        const originalValue = lookup.getAttribute("data-lookup-original-value") || "";
        const originalText = lookup.getAttribute("data-lookup-original-text") || "";
        hidden.value = originalValue;
        textInput.value = originalText;
        lookup.setAttribute("data-lookup-typed", originalText);
        lookup.setAttribute("data-lookup-searching", "0");
        lookup.classList.remove("open");
        lookup.removeAttribute("data-lookup-nav-ready");
        try { textInput.focus({ preventScroll: true }); } catch { textInput.focus(); }
      }

      async function resolveLookupValue(value, createdLookupByToken) {
        const raw = String(value || "").trim();
        if (!raw) return "";
        const token = parseLookupCreateToken(raw);
        if (!token) return raw;
        const key = raw;
        if (createdLookupByToken.has(key)) return createdLookupByToken.get(key);

        const collection = token.collection;
        const name = String(token.name || "").trim();
        if (!collection || !name) throw new Error("New lookup value is missing collection/name.");

        if (collection === "payees") {
          const existing = state.payees.find((p) => normalizeLookupText(p && p.name) === normalizeLookupText(name));
          if (existing && existing.id) {
            const existingId = String(existing.id);
            createdLookupByToken.set(key, existingId);
            return existingId;
          }
        }

        const body = collection === "accounts"
          ? { name: name, type: "bank", is_archived: false }
          : (collection === "categories"
            ? { name: name, kind: "expense", is_archived: false }
            : (collection === "payees"
              ? { name: name, is_archived: false }
              : null));
        if (!body) throw new Error("Unsupported create-lookup collection: " + collection);

        const created = await createRecord(collection, body);
        const id = String((created && created.id) || "");
        if (!id) throw new Error("Failed to create new " + collection + " entry for \"" + name + "\".");
        createdLookupByToken.set(key, id);
        return id;
      }

      function sortedCopyByLabel(items, labelFn) {
        return items.slice().sort((a, b) => labelFn(a).localeCompare(labelFn(b), undefined, { sensitivity: "base" }));
      }

      function compareSortValues(a, b, direction) {
        const dir = direction === "asc" ? 1 : -1;
        const aNum = typeof a === "number" ? a : NaN;
        const bNum = typeof b === "number" ? b : NaN;
        if (Number.isFinite(aNum) && Number.isFinite(bNum)) {
          if (aNum < bNum) return -1 * dir;
          if (aNum > bNum) return 1 * dir;
          return 0;
        }
        const aStr = String(a == null ? "" : a).toLocaleLowerCase();
        const bStr = String(b == null ? "" : b).toLocaleLowerCase();
        const cmp = aStr.localeCompare(bStr, undefined, { sensitivity: "base", numeric: true });
        return cmp * dir;
      }

      function summarizeGroupText(group, valueFn) {
        return Array.from(new Set((group || []).map(valueFn).map((v) => String(v || "").trim()).filter(Boolean)))
          .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: "base" }))
          .join(" | ");
      }

      function txnSortValue(txnId, group, txn, column) {
        if (column === "date") {
          const dateSource = txn.date || ((group && group[0]) ? group[0].date : "");
          const ts = Date.parse(dateSource || "");
          return Number.isFinite(ts) ? ts : -Infinity;
        }
        if (column === "account") {
          if ((group || []).length <= 1) return accountDisplayName(group[0] && group[0].account);
          return summarizeGroupText(group, (e) => accountDisplayName(e && e.account));
        }
        if (column === "payee") return payeeDisplayName(txn.payee);
        if (column === "category") {
          if ((group || []).length <= 1) return categoryDisplayName(group[0] && group[0].category);
          return summarizeGroupText(group, (e) => categoryDisplayName(e && e.category));
        }
        if (column === "memo") return txn.memo || "";
        if (column === "amount") {
          return (group || []).reduce((sum, e) => {
            try {
              return sum + qtyMajorForEntry(e);
            } catch {
              return sum;
            }
          }, 0);
        }
        if (column === "status") {
          if ((group || []).length <= 1) return (group[0] && group[0].status) || "";
          return summarizeGroupText(group, (e) => (e && e.status) || "");
        }
        return String(txnId || "");
      }

      function updateRegisterSortHeaders() {
        const headers = $$("th[data-sort]", $("#registerTable thead"));
        headers.forEach((th) => {
          const key = th.getAttribute("data-sort") || "";
          const isActive = key === state.sort.column;
          th.classList.toggle("sorted-asc", isActive && state.sort.direction === "asc");
          th.classList.toggle("sorted-desc", isActive && state.sort.direction === "desc");
          th.setAttribute("aria-sort", isActive ? (state.sort.direction === "asc" ? "ascending" : "descending") : "none");
        });
      }

      function toggleRegisterSort(column) {
        if (!column) return;
        if (state.editingTxnId) {
          setStatus("warn", "Finish or cancel inline edit before sorting.");
          return;
        }
        if (state.sort.column === column) {
          state.sort.direction = state.sort.direction === "asc" ? "desc" : "asc";
        } else {
          state.sort.column = column;
          state.sort.direction = (column === "date" || column === "amount") ? "desc" : "asc";
        }
        state.page = 1;
        updateRegisterSortHeaders();
        if (column === "payee" || column === "memo") {
          setStatus("warn", "Payee/Memo sorting uses current page only; PocketBase sort is applied on entries fields.");
        }
        refreshAll();
      }

      function setupRegisterSortHeaders() {
        const headers = $$("th[data-sort]", $("#registerTable thead"));
        headers.forEach((th) => {
          th.classList.add("sortable");
          if (th.getAttribute("data-sort-bound") === "1") return;
          th.setAttribute("data-sort-bound", "1");
          th.addEventListener("click", function() {
            toggleRegisterSort(th.getAttribute("data-sort") || "");
          });
        });
        updateRegisterSortHeaders();
      }

      function registerServerSortKey(column) {
        if (column === "date") return "date";
        if (column === "account") return "account";
        if (column === "category") return "category";
        if (column === "amount") return "qty";
        if (column === "status") return "status";
        return "date";
      }

      function registerServerSortExpr() {
        const key = registerServerSortKey(state.sort.column);
        return (state.sort.direction === "desc" ? "-" : "") + key;
      }

      function updateRegisterPageInfo() {
        const current = Math.max(1, state.page || 1);
        const totalPages = Math.max(1, state.totalPages || 1);
        const totalItems = Math.max(0, state.totalItems || 0);
        $("#pageInfo").textContent = "Page " + current + " of " + totalPages + " (" + totalItems + " rows)";
      }

      function localTodayYmd() {
        const now = new Date();
        return new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 10);
      }

      function getUsdAssetId() {
        const usd = state.assets.find((a) => String(a.symbol || "").toUpperCase() === "USD");
        return usd ? usd.id : "";
      }

      function focusKeyFromDblClickEvent(ev) {
        const td = ev && ev.target ? ev.target.closest("td") : null;
        const idx = td ? td.cellIndex : 0;
        if (idx === 0) return "txn-date";
        if (idx === 1) return "entry-account";
        if (idx === 2) return "txn-payee";
        if (idx === 3) return "entry-category";
        if (idx === 4) return "txn-memo";
        if (idx === 5) return "entry-qty";
        if (idx === 6) return "entry-status";
        return "txn-date";
      }

      function applyPendingInlineFocus() {
        if (!state.editingTxnId || !state.pendingFocusKey) return;
        const key = state.pendingFocusKey;
        const selector = (key === "entry-account" || key === "entry-category" || key === "txn-payee")
          ? '[data-lookup-for="' + key + '"]'
          : '[data-edit="' + key + '"]';
        requestAnimationFrame(function() {
          const el = $("#registerBody " + selector);
          if (!el) return;
          try { el.focus({ preventScroll: true }); } catch { el.focus(); }
          if (el.tagName === "INPUT" && el.type !== "date") {
            try { el.select(); } catch {}
          }
          state.pendingFocusKey = "";
        });
      }

      async function startNewInlineEdit() {
        if (!SESSION.token) return;
        if (state.loading || state.saving || state.deleting) return;
        if (state.editingTxnId) {
          setStatus("warn", "Finish or cancel the current inline edit before creating a new transaction.");
          return;
        }

        let createdTxnId = "";
        let createdEntryId = "";
        try {
          state.loading = true;
          setBusy();

          if (!state.accounts.length || !state.assets.length || !state.categories.length || !state.payees.length) {
            await loadReferenceData();
          }

          const accountSorted = sortedCopyByLabel(state.accounts, (a) => (a.name || a.id || ""));
          const categorySorted = sortedCopyByLabel(state.categories, (c) => (c.name || c.id || ""));
          const usdAssetId = getUsdAssetId();

          const defaultAccount = accountSorted[0] ? accountSorted[0].id : "";
          const defaultCategory = categorySorted[0] ? categorySorted[0].id : "";
          if (!defaultAccount) throw new Error("No account available for default selection.");
          if (!usdAssetId) throw new Error("USD asset was not found.");

          const normalizedDate = normalizeDateToNoonUtc(localTodayYmd());
          const txn = await createRecord("txns", {
            date: normalizedDate,
            source: "manual"
          });
          createdTxnId = txn.id;
          const entry = await createRecord("entries", {
            txn: txn.id,
            date: normalizedDate,
            account: defaultAccount,
            category: defaultCategory || null,
            asset: usdAssetId,
            qty: 0,
            status: "pending"
          });
          createdEntryId = entry.id;

          state.selectedTxnIds = [txn.id];
          state.selectionAnchorTxnId = txn.id;
          state.editingTxnId = txn.id;
          state.editDraft = { txn: txn, entries: [entry] };
          state.pendingFocusKey = "txn-date";
          setStatus("warn", "Created new transaction and opened inline edit mode.");
          await loadRegister();
        } catch (err) {
          if (createdEntryId) {
            try { await deleteRecord("entries", createdEntryId); } catch {}
          }
          if (createdTxnId) {
            try { await deleteRecord("txns", createdTxnId); } catch {}
          }
          const info = classifyError(err);
          setStatus(info.kind, "New transaction failed: " + (err && err.message ? err.message : info.message));
        } finally {
          state.loading = false;
          setBusy();
        }
      }

      async function startInlineEdit(txnId, focusKey) {
        if (!SESSION.token || !txnId) return;
        if (state.loading || state.saving || state.deleting) return;
        if (state.editingTxnId && state.editingTxnId !== txnId) {
          const ok = await saveInlineEdit();
          if (!ok) return;
        }
        if (state.editingTxnId === txnId) {
          state.pendingFocusKey = focusKey || "txn-date";
          applyPendingInlineFocus();
          return;
        }
        try {
          state.loading = true;
          setBusy();
          const txn = await getRecord("txns", txnId);
          const entries = await listRecordsSafe("entries", {
            filter: 'txn = "' + txnId.replaceAll('"', '\\"') + '"',
            sort: "-date",
            perPage: 500
          });
          await ensureAccountsLoaded(entries.map((e) => e && e.account));
          await ensureCategoriesLoaded(entries.map((e) => e && e.category));
          await ensurePayeesLoaded([txn && txn.payee]);
          state.editingTxnId = txnId;
          state.selectedTxnIds = [txnId];
          state.selectionAnchorTxnId = txnId;
          state.editDraft = { txn: txn, entries: entries };
          state.pendingFocusKey = focusKey || "txn-date";
          setStatus("warn", "Inline edit mode: update fields, then Save Edit or Cancel.");
          renderRegister();
        } catch (err) {
          const info = classifyError(err);
          setStatus(info.kind, "Failed to start edit: " + (err && err.message ? err.message : info.message));
        } finally {
          state.loading = false;
          setBusy();
        }
      }

      function cancelInlineEdit() {
        state.editingTxnId = "";
        state.editDraft = null;
        state.pendingFocusKey = "";
        setStatus("ok", "Edit canceled.");
        renderRegister();
        setBusy();
      }

      async function saveInlineEdit() {
        if (!state.editingTxnId || !state.editDraft || !SESSION.token) return false;
        if (state.saving) return false;
        const txnId = state.editingTxnId;
        const root = $('#registerBody tr[data-edit-root="1"]');
        if (!root) return false;
        let normalizedDate = "";
        let payee = null;
        let memo = null;
        const updates = [];
        const createdLookupByToken = new Map();

        try {
          const dateRaw = $('input[data-edit="txn-date"]', root).value.trim();
          payee = fieldOrNull($('input[data-edit="txn-payee"]', root).value);
          memo = fieldOrNull($('input[data-edit="txn-memo"]', root).value);
          if (!/^\d{4}-\d{2}-\d{2}$/.test(dateRaw)) throw new Error("Date must be in YYYY-MM-DD format.");
          normalizedDate = normalizeDateToNoonUtc(dateRaw);
          payee = payee ? await resolveLookupValue(payee, createdLookupByToken) : null;

          const entryRows = $$('tr[data-edit-entry="1"]', $("#registerBody"));
          for (const row of entryRows) {
            const entryId = row.getAttribute("data-entry-id") || "";
            const accountRaw = $('input[data-edit="entry-account"]', row).value;
            const categoryRaw = $('input[data-edit="entry-category"]', row).value;
            const qtyRaw = $('input[data-edit="entry-qty"]', row).value.trim();
            const status = $('select[data-edit="entry-status"]', row).value;

            if (!entryId) throw new Error("Entry id missing in edit row.");
            const account = await resolveLookupValue(accountRaw, createdLookupByToken);
            const categoryResolved = categoryRaw ? await resolveLookupValue(categoryRaw, createdLookupByToken) : "";
            if (!account) throw new Error("Account is required for all entries.");
            if (!status) throw new Error("Status is required for all entries.");
            if (!qtyRaw) throw new Error("Amount is required for all entries.");
            const sourceEntry = (state.editDraft.entries || []).find((e) => String(e.id || "") === entryId);
            if (!sourceEntry) throw new Error("Entry " + entryId + " is missing from edit draft.");
            const entryAssetId = String(sourceEntry.asset || getUsdAssetId() || "");
            if (!entryAssetId) throw new Error("Entry asset is required.");
            const precision = assetPrecision(entryAssetId);
            const qty = parseMajorToMinor(qtyRaw, precision);

            const body = {
              date: normalizedDate,
              account: account,
              category: categoryResolved || null,
              asset: entryAssetId,
              qty: qty,
              status: status
            };
            updates.push({ id: entryId, body: body });
          }
        } catch (err) {
          setStatus("bad", "Save failed: " + (err && err.message ? err.message : String(err)));
          return false;
        }

        try {
          state.saving = true;
          setBusy();
          await updateRecord("txns", txnId, {
            date: normalizedDate,
            payee: payee,
            memo: memo
          });
          for (const u of updates) {
            await updateRecord("entries", u.id, u.body);
          }
          state.editingTxnId = "";
          state.editDraft = null;
          state.pendingFocusKey = "";
          setStatus("ok", "Transaction " + txnId + " updated.");
          await refreshAll();
          return true;
        } catch (err) {
          const info = classifyError(err);
          setStatus(info.kind, "Save edit failed: " + (err && err.message ? err.message : info.message));
          return false;
        } finally {
          state.saving = false;
          setBusy();
        }
      }

      function renderRegister() {
        const body = $("#registerBody");

        body.innerHTML = "";
        const txnGroups = new Map();
        const txnOrder = [];
        state.entries.forEach((e) => {
          const key = e.txn || "";
          if (!txnGroups.has(key)) {
            txnGroups.set(key, []);
            txnOrder.push(key);
          }
          txnGroups.get(key).push(e);
        });
        if (state.sort.column === "payee" || state.sort.column === "memo") {
          txnOrder.sort((a, b) => {
            const groupA = txnGroups.get(a) || [];
            const groupB = txnGroups.get(b) || [];
            const txnA = state.txns.get(a) || {};
            const txnB = state.txns.get(b) || {};
            const valA = txnSortValue(a, groupA, txnA, state.sort.column);
            const valB = txnSortValue(b, groupB, txnB, state.sort.column);
            const cmp = compareSortValues(valA, valB, state.sort.direction);
            if (cmp !== 0) return cmp;
            return String(a || "").localeCompare(String(b || ""), undefined, { sensitivity: "base", numeric: true });
          });
        }
        state.visibleTxnOrder = txnOrder.slice();
        const orderSet = new Set(txnOrder);
        state.selectedTxnIds = state.selectedTxnIds.filter((id) => orderSet.has(id));
        if (state.selectionAnchorTxnId && !orderSet.has(state.selectionAnchorTxnId)) {
          state.selectionAnchorTxnId = state.selectedTxnIds[0] || "";
        }
        const selectedSet = new Set(state.selectedTxnIds);

        function selectTxn(txnId, ev) {
          if (state.editingTxnId) return;
          const order = state.visibleTxnOrder || [];
          const selected = new Set(state.selectedTxnIds);
          const isToggle = !!(ev && (ev.metaKey || ev.ctrlKey));
          const isRange = !!(ev && ev.shiftKey);

          if (isRange && state.selectionAnchorTxnId) {
            const a = order.indexOf(state.selectionAnchorTxnId);
            const b = order.indexOf(txnId);
            if (a !== -1 && b !== -1) {
              const start = Math.min(a, b);
              const end = Math.max(a, b);
              const range = order.slice(start, end + 1);
              if (!isToggle) selected.clear();
              range.forEach((id) => selected.add(id));
            } else {
              if (!isToggle) selected.clear();
              selected.add(txnId);
            }
          } else if (isToggle) {
            if (selected.has(txnId)) selected.delete(txnId);
            else selected.add(txnId);
            state.selectionAnchorTxnId = txnId;
          } else {
            selected.clear();
            selected.add(txnId);
            state.selectionAnchorTxnId = txnId;
          }

          if (!state.selectionAnchorTxnId && txnId) state.selectionAnchorTxnId = txnId;
          state.selectedTxnIds = Array.from(selected);
          setBusy();
          renderRegister();
        }

        txnOrder.forEach((txnId) => {
          const group = txnGroups.get(txnId) || [];
          const txn = state.txns.get(txnId) || {};
          const isSelected = selectedSet.has(txnId);

          if (state.editingTxnId && state.editingTxnId === txnId && state.editDraft) {
            const draftTxn = state.editDraft.txn || {};
            const draftEntries = state.editDraft.entries || [];
            const isSingle = draftEntries.length <= 1;

            if (isSingle) {
              const e = draftEntries[0] || {};
              const trSingle = document.createElement("tr");
              trSingle.className = "txn-edit txn-edit-end";
              trSingle.setAttribute("data-edit-root", "1");
              trSingle.setAttribute("data-edit-entry", "1");
              trSingle.setAttribute("data-entry-id", String(e.id || ""));
              trSingle.innerHTML = [
                '<td><input class="inlineInput" data-edit="txn-date" type="text" inputmode="numeric" placeholder="YYYY-MM-DD" value="' + escapeHtml(fmtDate(draftTxn.date || e.date)) + '" /></td>',
                '<td>' + inlineLookupMarkup(editableAccountOptions(e.account), e.account, (a) => accountLabel(a, true), "entry-account", false, "Select account") + "</td>",
                '<td>' + inlineLookupMarkup(editablePayeeOptions(draftTxn.payee), draftTxn.payee, (p) => payeeLabel(p, true), "txn-payee", true, "Optional payee") + "</td>",
                '<td>' + inlineLookupMarkup(editableCategoryOptions(e.category), e.category, (c) => categoryLabel(c, true), "entry-category", true, "Optional category") + "</td>",
                '<td><input class="inlineInput" data-edit="txn-memo" type="text" value="' + escapeHtml(draftTxn.memo || "") + '" /></td>',
                '<td><input class="inlineInput" data-edit="entry-qty" type="text" value="' + escapeHtml(e.qty == null ? "" : fmtMinor(e.qty, assetPrecision(e.asset))) + '" /></td>',
                '<td><select class="inlineSelect" data-edit="entry-status"><option value="pending"' + (e.status === "pending" ? " selected" : "") + '>pending</option><option value="cleared"' + (e.status === "cleared" ? " selected" : "") + '>cleared</option></select></td>'
              ].join("");
              body.appendChild(trSingle);
              return;
            }

            const trTxn = document.createElement("tr");
            trTxn.className = "txn-edit";
            trTxn.setAttribute("data-edit-root", "1");
            trTxn.innerHTML = [
              '<td><input class="inlineInput" data-edit="txn-date" type="text" inputmode="numeric" placeholder="YYYY-MM-DD" value="' + escapeHtml(fmtDate(draftTxn.date)) + '" /></td>',
              "<td></td>",
              '<td>' + inlineLookupMarkup(editablePayeeOptions(draftTxn.payee), draftTxn.payee, (p) => payeeLabel(p, true), "txn-payee", true, "Optional payee") + "</td>",
              "<td></td>",
              '<td><input class="inlineInput" data-edit="txn-memo" type="text" value="' + escapeHtml(draftTxn.memo || "") + '" /></td>',
              "<td></td>",
              "<td></td>"
            ].join("");
            body.appendChild(trTxn);

            draftEntries.forEach((e, idx) => {
              const trE = document.createElement("tr");
              trE.className = "txn-edit" + (idx === draftEntries.length - 1 ? " txn-edit-end" : "");
              trE.setAttribute("data-edit-entry", "1");
              trE.setAttribute("data-entry-id", String(e.id || ""));
              trE.innerHTML = [
                "<td></td>",
                '<td>' + inlineLookupMarkup(editableAccountOptions(e.account), e.account, (a) => accountLabel(a, true), "entry-account", false, "Select account") + "</td>",
                "<td></td>",
                '<td>' + inlineLookupMarkup(editableCategoryOptions(e.category), e.category, (c) => categoryLabel(c, true), "entry-category", true, "Optional category") + "</td>",
                "<td></td>",
                '<td><input class="inlineInput" data-edit="entry-qty" type="text" value="' + escapeHtml(e.qty == null ? "" : fmtMinor(e.qty, assetPrecision(e.asset))) + '" /></td>',
                '<td><select class="inlineSelect" data-edit="entry-status"><option value="pending"' + (e.status === "pending" ? " selected" : "") + '>pending</option><option value="cleared"' + (e.status === "cleared" ? " selected" : "") + '>cleared</option></select></td>'
              ].join("");
              body.appendChild(trE);
            });
            return;
          }

          if (group.length <= 1) {
            const e = group[0];
            if (!e) return;

            const tr = document.createElement("tr");
            if (isSelected) tr.classList.add("selected");

            let qtyTxt = e.qty == null ? "" : String(e.qty);
            try {
              qtyTxt = fmtMinor(e.qty, assetPrecision(e.asset));
            } catch {}

            tr.innerHTML = [
              "<td>" + escapeHtml(fmtDate(e.date)) + "</td>",
              "<td>" + escapeHtml(accountDisplayName(e.account)) + "</td>",
              "<td>" + escapeHtml(payeeDisplayName(txn.payee)) + "</td>",
              "<td><span class=\"pill\">" + escapeHtml(categoryDisplayName(e.category)) + "</span></td>",
              "<td>" + escapeHtml(txn.memo || "") + "</td>",
              "<td>" + escapeHtml(qtyTxt) + "</td>",
              "<td>" + escapeHtml(e.status || "") + "</td>"
            ].join("");

            tr.addEventListener("click", function(ev) { selectTxn(e.txn || "", ev); });
            tr.addEventListener("dblclick", function(ev) { startInlineEdit(e.txn || "", focusKeyFromDblClickEvent(ev)); });
            body.appendChild(tr);
            return;
          }

          const totalQty = group.reduce((sum, e) => {
            try {
              return sum + qtyMajorForEntry(e);
            } catch {
              return sum;
            }
          }, 0);
          const totalTxt = totalQty.toLocaleString(undefined, { maximumFractionDigits: 8 });

          const parentRow = document.createElement("tr");
          parentRow.className = "txn-parent";
          if (isSelected) parentRow.classList.add("selected");
          parentRow.innerHTML = [
            "<td>" + escapeHtml(fmtDate(txn.date || group[0].date)) + "</td>",
            "<td></td>",
            "<td>" + escapeHtml(payeeDisplayName(txn.payee)) + "</td>",
            "<td></td>",
            "<td>" + escapeHtml(txn.memo || "") + "</td>",
            "<td>" + escapeHtml(totalTxt) + "</td>",
            "<td></td>"
          ].join("");
          parentRow.addEventListener("click", function(ev) { selectTxn(txnId, ev); });
          parentRow.addEventListener("dblclick", function(ev) { startInlineEdit(txnId, focusKeyFromDblClickEvent(ev)); });
          body.appendChild(parentRow);

          group.forEach((e, idx) => {
            const tr = document.createElement("tr");
            tr.className = "txn-sub" + (idx === group.length - 1 ? " txn-sub-end" : "");
            if (isSelected) tr.classList.add("selected");

            let qtyTxt = e.qty == null ? "" : String(e.qty);
            try {
              qtyTxt = fmtMinor(e.qty, assetPrecision(e.asset));
            } catch {}
            tr.innerHTML = [
              "<td></td>",
              "<td>" + escapeHtml(accountDisplayName(e.account)) + "</td>",
              "<td></td>",
              "<td><span class=\"pill\">" + escapeHtml(categoryDisplayName(e.category)) + "</span></td>",
              "<td></td>",
              "<td>" + escapeHtml(qtyTxt) + "</td>",
              "<td>" + escapeHtml(e.status || "") + "</td>"
            ].join("");

            tr.addEventListener("click", function(ev) { selectTxn(txnId, ev); });
            tr.addEventListener("dblclick", function(ev) { startInlineEdit(txnId, focusKeyFromDblClickEvent(ev)); });
            body.appendChild(tr);
          });
        });

        applyPendingInlineFocus();
        $("#resultCount").textContent = state.entries.length + " entries shown across " + txnOrder.length + " transactions. Double-click a transaction row to edit inline.";
      }

      async function deleteSelectedTransaction() {
        if (!SESSION.token || state.selectedTxnIds.length < 1 || state.deleting) return;
        const txnIds = state.selectedTxnIds.slice();
        const yes = confirm("Delete " + txnIds.length + " selected transaction(s) and their entries? This cannot be undone.");
        if (!yes) return;

        state.deleting = true;
        setBusy();

        let deletedTxns = 0;
        let deletedEntries = 0;
        const failed = [];
        try {
          for (const txnId of txnIds) {
            try {
              const rows = await listRecordsSafe("entries", { filter: 'txn = "' + txnId.replaceAll('"', '\\"') + '"', perPage: 500, sort: "-date" });
              for (const row of rows) {
                await deleteRecord("entries", row.id);
                deletedEntries += 1;
              }
              await deleteRecord("txns", txnId);
              deletedTxns += 1;
            } catch {
              failed.push(txnId);
            }
          }
          state.selectedTxnIds = failed.slice();
          state.selectionAnchorTxnId = state.selectedTxnIds[0] || "";
          if (failed.length > 0) {
            setStatus("warn", "Deleted " + deletedTxns + " txn(s), " + deletedEntries + " entries. Failed: " + failed.join(", "));
          } else {
            setStatus("ok", "Deleted " + deletedTxns + " txn(s) and " + deletedEntries + " related entries.");
          }
          await refreshAll();
        } catch (err) {
          const info = classifyError(err);
          setStatus(info.kind, "Delete failed: " + (err && err.message ? err.message : info.message));
        } finally {
          state.deleting = false;
          setBusy();
        }
      }

      async function refreshAll() {
        if (!SESSION.token) return;
        state.loading = true;
        setBusy();

        try {
          await loadReferenceData();

          await loadRegister();

          setStatus("ok", "Loaded accounts/assets/categories/payees and register entries.");
        } catch (err) {
          const info = classifyError(err);
          setStatus(info.kind, "Load failed: " + (err && err.message ? err.message : info.message));
          if (err && err.kind === "auth") {
            SESSION.token = "";
            store.del("pbToken");
            state.editingTxnId = "";
            state.editDraft = null;
            setAuthenticatedUI(false);
          }
        } finally {
          state.loading = false;
          setBusy();
        }
      }

      async function validateCachedSession() {
        if (!SESSION.base || !SESSION.token) return false;
        try {
          const res = await authRefresh();
          if (res && res.token) {
            SESSION.token = res.token;
            store.set("pbToken", res.token);
          }
          return true;
        } catch {
          return false;
        }
      }

      $("#btnLogin").addEventListener("click", async function() {
        const base = $("#pbUrl").value.trim().replace(/\/+$/, "");
        const email = $("#pbEmail").value.trim();
        const password = $("#pbPass").value;

        if (!base || !email || !password) {
          setStatus("bad", "Login failed: URL, email, and password are required.");
          return;
        }

        store.set("pbUrl", base);
        store.set("pbEmail", email);

        try {
          $("#btnLogin").disabled = true;
          SESSION.base = base;
          SESSION.token = "";

          const res = await authWithPassword(email, password);
          if (!res || !res.token) throw new Error("No token returned by PocketBase.");

          SESSION.token = res.token;
          store.set("pbToken", res.token);
          setAuthenticatedUI(true);
          setStatus("ok", "Login succeeded. Session saved in localStorage.");
          await refreshAll();
        } catch (err) {
          SESSION.token = "";
          store.del("pbToken");
          setAuthenticatedUI(false);
          const info = classifyError(err);
          setStatus(info.kind, "Login failed: " + (err && err.message ? err.message : info.message));
        } finally {
          $("#btnLogin").disabled = false;
          $("#pbPass").value = "";
        }
      });

      $("#logoutLink").addEventListener("click", function(ev) {
        ev.preventDefault();
        SESSION.base = "";
        SESSION.token = "";
        store.del("pbUrl");
        store.del("pbEmail");
        store.del("pbToken");
        $("#pbUrl").value = "";
        $("#pbEmail").value = "";
        $("#pbPass").value = "";
        state.entries = [];
        state.accounts = [];
        state.accountById = new Map();
        state.assets = [];
        state.assetPrecisionById = new Map();
        state.categories = [];
        state.categoryById = new Map();
        state.payees = [];
        state.payeeById = new Map();
        state.txns = new Map();
        state.selectedTxnIds = [];
        state.selectionAnchorTxnId = "";
        state.visibleTxnOrder = [];
        state.editingTxnId = "";
        state.editDraft = null;
        state.page = 1;
        state.totalPages = 1;
        state.totalItems = 0;
        $("#registerBody").innerHTML = "";
        $("#resultCount").textContent = "";
        updateRegisterPageInfo();
        setAuthenticatedUI(false);
        setStatus("ok", "Logged out. Local session cleared.");
        setBusy();
      });

      $("#btnRefresh").addEventListener("click", refreshAll);
      $("#btnNewTxn").addEventListener("click", startNewInlineEdit);
      $("#btnDeleteTxn").addEventListener("click", deleteSelectedTransaction);
      $("#btnEditSave").addEventListener("click", saveInlineEdit);
      $("#btnEditCancel").addEventListener("click", cancelInlineEdit);

      ["#fltFrom", "#fltTo", "#fltAccount", "#fltCategory", "#fltStatus", "#fltBudgetOnly"].forEach((sel) => {
        $(sel).addEventListener("change", function() {
          state.page = 1;
          refreshAll();
        });
      });

      $("#btnPrevPage").addEventListener("click", function() {
        if (state.page <= 1 || state.loading || state.saving || state.deleting) return;
        state.page -= 1;
        refreshAll();
      });
      $("#btnNextPage").addEventListener("click", function() {
        if (state.page >= state.totalPages || state.loading || state.saving || state.deleting) return;
        state.page += 1;
        refreshAll();
      });
      $("#perPage").addEventListener("change", function() {
        const v = Number($("#perPage").value);
        if (!Number.isFinite(v) || v < 1) return;
        state.perPage = v;
        state.page = 1;
        refreshAll();
      });

      $("#registerBody").addEventListener("keydown", function(e) {
        if (!state.editingTxnId) return;
        const t = e.target;
        if (t && t.matches('input[data-lookup-input="1"]')) {
          const lookup = t.closest(".inlineLookup");
          const isSearching = lookup && lookup.getAttribute("data-lookup-searching") === "1";
          if (e.key === "ArrowDown" || e.key === "ArrowUp") {
            e.preventDefault();
            if (!lookup) return;
            lookup.classList.add("open");
            const typed = lookup.getAttribute("data-lookup-typed");
            if (!lookup.getAttribute("data-lookup-nav-ready")) {
              filterInlineLookupMenu(lookup, typed == null ? t.value : typed);
              lookup.setAttribute("data-lookup-nav-ready", "1");
            }
            const next = moveActiveLookupOption(lookup, e.key === "ArrowDown" ? 1 : -1);
            if (next) lookup.setAttribute("data-lookup-searching", "1");
            previewInlineLookupOption(lookup, next, typed == null ? t.value : typed);
            return;
          }
          if (e.key === "Escape") {
            e.preventDefault();
            if (lookup && isSearching) {
              restoreInlineLookupOriginal(lookup);
              return;
            }
            cancelInlineEdit();
            return;
          }
          if (e.key === "Tab") {
            if (lookup && isSearching) {
              const top = activeLookupOption(lookup) || firstVisibleLookupOption(lookup);
              if (top) chooseInlineLookupOption(lookup, top);
            }
            return;
          }
          if (e.key === "Enter") {
            if (lookup) {
              if (isSearching) {
                const top = activeLookupOption(lookup) || firstVisibleLookupOption(lookup);
                if (top) chooseInlineLookupOption(lookup, top);
                e.preventDefault();
                return;
              }
            }
          }
        }
        if (e.key === "Escape") {
          e.preventDefault();
          cancelInlineEdit();
          return;
        }
        if (e.key !== "Enter") return;
        if (!t || !(t.matches("input") || t.matches("select"))) return;
        e.preventDefault();
        saveInlineEdit();
      });

      $("#registerBody").addEventListener("focusin", function(e) {
        const input = e.target && e.target.matches('input[data-lookup-input="1"]') ? e.target : null;
        if (!input) return;
        const lookup = input.closest(".inlineLookup");
        if (!lookup) return;
        const hidden = $('input[type="hidden"][data-edit]', lookup);
        closeInlineLookups(lookup);
        lookup.classList.add("open");
        lookup.setAttribute("data-lookup-original-text", input.value || "");
        lookup.setAttribute("data-lookup-original-value", hidden ? (hidden.value || "") : "");
        lookup.setAttribute("data-lookup-searching", "0");
        lookup.setAttribute("data-lookup-typed", "");
        lookup.removeAttribute("data-lookup-nav-ready");
        filterInlineLookupMenu(lookup, "");
      });

      $("#registerBody").addEventListener("input", function(e) {
        const input = e.target && e.target.matches('input[data-lookup-input="1"]') ? e.target : null;
        if (!input) return;
        const lookup = input.closest(".inlineLookup");
        if (!lookup) return;
        const rawTyped = input.value;
        lookup.classList.add("open");
        lookup.setAttribute("data-lookup-searching", rawTyped.trim() ? "1" : "0");
        lookup.setAttribute("data-lookup-typed", rawTyped);
        lookup.removeAttribute("data-lookup-nav-ready");
        filterInlineLookupMenu(lookup, rawTyped);
        applyInlineLookupPhantomFill(lookup, rawTyped);
        syncInlineLookupValue(lookup, rawTyped);
      });

      $("#registerBody").addEventListener("click", function(e) {
        const option = e.target ? e.target.closest(".inlineLookupOption") : null;
        if (!option) return;
        const lookup = option.closest(".inlineLookup");
        if (!lookup) return;
        chooseInlineLookupOption(lookup, option);
      });

      document.addEventListener("click", function(e) {
        if (e.target && e.target.closest("#registerBody .inlineLookup")) return;
        closeInlineLookups();
      });

      $("#pbUrl").value = store.get("pbUrl", "");
      $("#pbEmail").value = store.get("pbEmail", "");
      $("#perPage").value = String(state.perPage);
      updateRegisterPageInfo();

      (async function init() {
        setupRegisterSortHeaders();
        SESSION.base = ($("#pbUrl").value || "").trim().replace(/\/+$/, "");
        SESSION.token = (store.get("pbToken", "") || "").trim();

        if (SESSION.base && SESSION.token) {
          const ok = await validateCachedSession();
          if (ok) {
            setAuthenticatedUI(true);
            setStatus("ok", "Session restored via auth-refresh.");
            await refreshAll();
            return;
          }
          SESSION.token = "";
          store.del("pbToken");
        }

        setAuthenticatedUI(false);
        setStatus("warn", "Not logged in. Enter URL, email, and password.");
        setBusy();
      })();
    })();
  </script>
</body>
</html>
