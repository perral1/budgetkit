<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BudgetKit - CSV Importer</title>
  <style>
    :root {
      --bg: #0a0f16;
      --panel: #111a26;
      --panel2: #172335;
      --text: #e7edf6;
      --muted: #a8b7ca;
      --line: #2a3a52;
      --accent: #6ec1ff;
      --ok: #3ed598;
      --warn: #ffd479;
      --bad: #ff7f7f;
      --radius: 12px;
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--sans);
      color: var(--text);
      background: radial-gradient(circle at top right, #17263b 0%, #0a0f16 45%, #070b10 100%);
      min-height: 100vh;
    }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
    .topbar, .panel {
      border: 1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(17, 26, 38, 0.92);
      box-shadow: var(--shadow);
    }
    .topbar {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 12px;
      flex-wrap: wrap;
      padding: 12px;
    }
    h1 { margin: 0; font-size: 18px; }
    .sub { margin-top: 4px; color: var(--muted); font-size: 12px; }
    .auth {
      display: flex;
      gap: 8px;
      align-items: flex-end;
      flex-wrap: wrap;
    }
    .field { display: flex; flex-direction: column; gap: 5px; }
    label { color: var(--muted); font-size: 12px; }
    input[type="text"], input[type="password"], input[type="file"], select {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(23, 35, 53, 0.95);
      color: var(--text);
      padding: 8px 10px;
      outline: none;
    }
    input:focus, select:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(110, 193, 255, 0.15); }
    .btn {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 12px;
      background: rgba(23, 35, 53, 0.95);
      color: var(--text);
      cursor: pointer;
      font-weight: 600;
    }
    .btn:hover { border-color: var(--accent); }
    .btn.primary { border-color: rgba(110, 193, 255, 0.55); background: rgba(110, 193, 255, 0.18); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .logout {
      display: none;
      color: var(--muted);
      text-decoration: none;
      font-size: 12px;
      margin-left: 8px;
    }
    .status {
      margin-top: 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 9px 10px;
      font-size: 13px;
      background: rgba(14, 22, 33, 0.75);
      color: var(--muted);
    }
    .status.ok { border-color: rgba(62, 213, 152, 0.45); color: #bdf7df; }
    .status.warn { border-color: rgba(255, 212, 121, 0.45); color: #ffeabc; }
    .status.bad { border-color: rgba(255, 127, 127, 0.45); color: #ffd1d1; }
    #app { display: none; margin-top: 12px; }
    .panel { padding: 12px; margin-bottom: 12px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: flex-end; }
    .dropzone {
      border: 2px dashed rgba(110, 193, 255, 0.45);
      border-radius: 12px;
      padding: 18px;
      text-align: center;
      color: var(--muted);
      background: rgba(23, 35, 53, 0.35);
      transition: border-color 120ms, background-color 120ms;
    }
    .dropzone.active {
      border-color: rgba(62, 213, 152, 0.7);
      background: rgba(62, 213, 152, 0.12);
      color: #bdf7df;
    }
    .mono { font-family: var(--mono); font-size: 12px; color: var(--muted); }
    .help { color: var(--muted); font-size: 12px; line-height: 1.35; }
    table { width: 100%; border-collapse: collapse; table-layout: fixed; }
    th, td {
      border-bottom: 1px solid rgba(42, 58, 82, 0.75);
      padding: 8px 6px;
      font-size: 12px;
      text-align: left;
      vertical-align: top;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    th { color: var(--muted); font-size: 11px; text-transform: uppercase; }
    .log {
      max-height: 220px;
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px;
      background: rgba(14, 22, 33, 0.75);
      font-family: var(--mono);
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .logLine { margin-bottom: 4px; }
    .logLine.bad { color: #ffd1d1; }
    .logLine.warn { color: #ffeabc; }
    .logLine.ok { color: #bdf7df; }
    @media (max-width: 760px) {
      .auth input[type="text"], .auth input[type="password"] { width: 100%; }
      .auth .field { min-width: 100%; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1>CSV Importer <a class="logout" id="logoutLink" href="#">logout</a></h1>
        <div class="sub">Imports register-style CSV rows into `txns` and `entries`.</div>
      </div>
      <div class="auth" id="authPanel">
        <div class="field">
          <label for="pbUrl">URL</label>
          <input id="pbUrl" type="text" placeholder="http://127.0.0.1:8090" />
        </div>
        <div class="field">
          <label for="pbEmail">Email</label>
          <input id="pbEmail" type="text" placeholder="you@example.com" />
        </div>
        <div class="field">
          <label for="pbPass">Password</label>
          <input id="pbPass" type="password" placeholder="password" />
        </div>
        <button class="btn primary" id="btnLogin" type="button">Login</button>
      </div>
    </div>

    <div class="status" id="statusBox">Not authenticated.</div>

    <div id="app">
      <section class="panel">
        <div class="row" style="justify-content:space-between;">
          <h2 style="margin:0;font-size:14px;">CSV File</h2>
          <button class="btn" id="btnClearFile" type="button">Clear File</button>
        </div>
        <div id="dropzone" class="dropzone" style="margin-top:10px;">
          Drag and drop CSV here, or choose file below.
        </div>
        <div class="row" style="margin-top:10px;">
          <div class="field" style="flex:1;min-width:260px;">
            <label for="csvFile">File</label>
            <input id="csvFile" type="file" accept=".csv,text/csv" />
          </div>
          <div class="field">
            <label for="idempotentIds">External IDs</label>
            <select id="idempotentIds">
              <option value="1" selected>Set deterministic IDs</option>
              <option value="0">Do not set IDs</option>
            </select>
          </div>
          <button class="btn" id="btnPreview" type="button">Parse Preview</button>
          <button class="btn primary" id="btnImport" type="button" disabled>Import CSV</button>
        </div>
        <div class="help" style="margin-top:8px;">
          Expected headers: Date, Account, Payee, Category, Subcategory, Memo, Amount. Optional header: Cleared (`TRUE` = cleared, `FALSE` = pending). If Cleared is missing, status defaults to `cleared`. All rows import with asset `USD`.
        </div>
        <div class="mono" id="fileInfo" style="margin-top:8px;">No file loaded.</div>
      </section>

      <section class="panel">
        <h2 style="margin:0 0 10px;font-size:14px;">Preview (first 15 rows)</h2>
        <div style="overflow:auto;">
          <table>
            <thead>
              <tr>
                <th>Line</th>
                <th>Date</th>
                <th>Account</th>
                <th>Payee</th>
                <th>Category</th>
                <th>Subcategory</th>
                <th>Amount</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody id="previewBody"></tbody>
          </table>
        </div>
        <div class="mono" id="previewSummary" style="margin-top:8px;">No parsed rows.</div>
      </section>

      <section class="panel">
        <h2 style="margin:0 0 10px;font-size:14px;">Import Log</h2>
        <div id="importStats" class="mono" style="margin-bottom:8px;">No import run yet.</div>
        <div id="logBox" class="log"></div>
      </section>
    </div>
  </div>

  <script>
    (function() {
      const $ = (s, el) => (el || document).querySelector(s);
      const store = {
        get(k, d) { try { const v = localStorage.getItem(k); return v == null ? d : v; } catch { return d; } },
        set(k, v) { try { localStorage.setItem(k, v); } catch {} },
        del(k) { try { localStorage.removeItem(k); } catch {} }
      };

      const SESSION = { base: "", token: "" };
      const state = {
        file: null,
        parsedRows: [],
        importing: false,
        refs: {
          accountsByName: new Map(),
          categoriesByName: new Map(),
          assetsBySymbol: new Map()
        }
      };

      function setStatus(kind, message) {
        const box = $("#statusBox");
        box.className = "status" + (kind ? " " + kind : "");
        box.textContent = message;
      }

      function escapeHtml(v) {
        return String(v == null ? "" : v)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      function setLoggedInUI(isLoggedIn) {
        $("#authPanel").style.display = isLoggedIn ? "none" : "flex";
        $("#logoutLink").style.display = isLoggedIn ? "inline" : "none";
        $("#app").style.display = isLoggedIn ? "block" : "none";
      }

      function setBusy() {
        const isAuthed = !!SESSION.token;
        const hasRows = state.parsedRows.length > 0;
        $("#btnImport").disabled = !isAuthed || !hasRows || state.importing;
        $("#btnPreview").disabled = !isAuthed || !state.file || state.importing;
        $("#btnClearFile").disabled = state.importing;
        $("#csvFile").disabled = !isAuthed || state.importing;
        $("#idempotentIds").disabled = state.importing;
        $("#btnLogin").disabled = state.importing;
      }

      function classifyError(err) {
        if (!err || typeof err !== "object") return { kind: "bad", message: String(err || "Unknown error") };
        if (err.kind === "network") return { kind: "bad", message: "Network error: check URL, protocol (http/https), host, and CORS." };
        if (err.kind === "auth") return { kind: "bad", message: "Auth failure: session expired or credentials/token were rejected." };
        if (err.kind === "query") return { kind: "warn", message: "Query/schema mismatch (HTTP 400): fallback query was used." };
        return { kind: "bad", message: err.message || "Request failed." };
      }

      async function pbFetch(path, options) {
        if (!SESSION.base) {
          const e = new Error("PocketBase URL is required.");
          e.kind = "auth";
          throw e;
        }

        const headers = Object.assign({ "Content-Type": "application/json" }, (options && options.headers) || {});
        if (SESSION.token) headers["Authorization"] = /^Bearer\s+/i.test(SESSION.token) ? SESSION.token : ("Bearer " + SESSION.token);

        let res;
        try {
          res = await fetch(SESSION.base + path, Object.assign({}, options || {}, { headers }));
        } catch (error) {
          const e = new Error("Network error (fetch failed): " + (error && error.message ? error.message : String(error)));
          e.kind = "network";
          throw e;
        }

        const text = await res.text();
        let data = null;
        try { data = text ? JSON.parse(text) : null; } catch { data = text; }

        if (!res.ok) {
          const e = new Error("HTTP " + res.status + ": " + (typeof data === "string" ? data : JSON.stringify(data || {})));
          e.status = res.status;
          e.responseData = data;
          if (res.status === 401 || res.status === 403) e.kind = "auth";
          else if (res.status === 400) e.kind = "query";
          else e.kind = "bad";
          throw e;
        }

        return data;
      }

      async function authWithPassword(email, password) {
        return pbFetch("/api/collections/users/auth-with-password", {
          method: "POST",
          body: JSON.stringify({ identity: email, password: password })
        });
      }

      async function authRefresh() {
        return pbFetch("/api/collections/users/auth-refresh", { method: "POST" });
      }

      async function createRecord(collection, body) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records", {
          method: "POST",
          body: JSON.stringify(body)
        });
      }

      async function deleteRecord(collection, id) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records/" + encodeURIComponent(id), {
          method: "DELETE"
        });
      }

      function toQS(params) {
        return Object.keys(params)
          .filter((k) => params[k] !== "" && params[k] != null)
          .map((k) => encodeURIComponent(k) + "=" + encodeURIComponent(params[k]))
          .join("&");
      }

      async function listRecordsSafe(collection, opts) {
        const options = opts || {};
        const perPage = options.perPage || 200;

        async function runAttempt(params) {
          const items = [];
          let page = 1;
          while (true) {
            const qs = toQS(Object.assign({}, params, { page: page, perPage: perPage }));
            const data = await pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records?" + qs, { method: "GET" });
            const rows = (data && data.items) ? data.items : [];
            for (const row of rows) items.push(row);
            const totalPages = Number(data && data.totalPages ? data.totalPages : 1);
            if (page >= totalPages) break;
            page += 1;
          }
          return items;
        }

        const attempts = [
          { filter: options.filter || "", sort: options.sort || "" },
          { sort: options.sort || "" },
          {}
        ];

        let saw400 = false;
        for (let i = 0; i < attempts.length; i++) {
          try {
            return await runAttempt(attempts[i]);
          } catch (err) {
            if (err && err.status === 400) {
              saw400 = true;
              continue;
            }
            throw err;
          }
        }

        if (saw400) {
          const e = new Error("HTTP 400 on all list query attempts.");
          e.kind = "query";
          throw e;
        }

        return [];
      }

      function normalizeDateToNoonUtc(dateStr) {
        return dateStr + "T12:00:00Z";
      }

      function normalizeDateInput(s) {
        const raw = String(s || "").trim();
        if (!raw) return "";
        if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) return raw;
        const d = new Date(raw);
        if (isNaN(d.getTime())) return "";
        return d.toISOString().slice(0, 10);
      }

      function parseAmount(raw) {
        let s = String(raw == null ? "" : raw).trim();
        if (!s) return null;
        s = s.replaceAll("$", "").replaceAll(",", "").trim();
        if (/^\(.*\)$/.test(s)) s = "-" + s.slice(1, -1);
        const n = Number(s);
        return Number.isFinite(n) ? n : null;
      }

      function parseClearedStatus(raw) {
        const s = String(raw == null ? "" : raw).trim().toUpperCase();
        if (!s) return null;
        if (s === "TRUE") return "cleared";
        if (s === "FALSE") return "pending";
        return null;
      }

      function categoryKindFromName(name, qty) {
        const n = String(name || "").trim().toLowerCase();
        const lead = n.includes(":") ? n.slice(0, n.indexOf(":")).trim() : n;
        if (lead === "income") return "income";
        if (lead === "spending" || lead === "expense") return "expense";
        if (lead === "transfer") return "transfer";
        if (lead === "trade_cash") return "trade_cash";
        if (lead === "trade_asset") return "trade_asset";
        if (lead === "fee") return "fee";
        if (lead === "withholding") return "withholding";
        if (lead === "benefit") return "benefit";
        if (lead === "employer_contrib") return "employer_contrib";
        if (lead === "info") return "info";
        if (qty != null) return qty >= 0 ? "income" : "expense";
        return "other";
      }

      function csvParse(text) {
        const rows = [];
        let i = 0;
        let cell = "";
        let row = [];
        let inQuotes = false;

        while (i < text.length) {
          const ch = text[i];

          if (inQuotes) {
            if (ch === '"') {
              if (text[i + 1] === '"') {
                cell += '"';
                i += 2;
                continue;
              }
              inQuotes = false;
              i += 1;
              continue;
            }
            cell += ch;
            i += 1;
            continue;
          }

          if (ch === '"') {
            inQuotes = true;
            i += 1;
            continue;
          }

          if (ch === ',') {
            row.push(cell);
            cell = "";
            i += 1;
            continue;
          }

          if (ch === '\n') {
            row.push(cell);
            rows.push(row);
            row = [];
            cell = "";
            i += 1;
            continue;
          }

          if (ch === '\r') {
            i += 1;
            continue;
          }

          cell += ch;
          i += 1;
        }

        if (cell.length || row.length) {
          row.push(cell);
          rows.push(row);
        }

        return rows;
      }

      function parseCsvRows(text) {
        const matrix = csvParse(text);
        if (!matrix.length) throw new Error("CSV is empty.");

        const headers = matrix[0].map((h) => String(h || "").trim().toLowerCase());
        const idx = {
          date: headers.indexOf("date"),
          account: headers.indexOf("account"),
          payee: headers.indexOf("payee"),
          category: headers.indexOf("category"),
          subcategory: headers.indexOf("subcategory"),
          memo: headers.indexOf("memo"),
          amount: headers.indexOf("amount"),
          cleared: headers.indexOf("cleared")
        };

        const required = ["date", "account", "category", "amount"];
        for (const k of required) {
          if (idx[k] < 0) throw new Error("Missing required column: " + k);
        }

        const out = [];
        for (let r = 1; r < matrix.length; r++) {
          const line = matrix[r];
          if (!line || !line.length || line.every((x) => String(x || "").trim() === "")) continue;

          const date = normalizeDateInput(line[idx.date]);
          const account = String(line[idx.account] || "").trim();
          const payee = idx.payee >= 0 ? String(line[idx.payee] || "").trim() : "";
          const category = String(line[idx.category] || "").trim();
          const subcategory = idx.subcategory >= 0 ? String(line[idx.subcategory] || "").trim() : "";
          const memo = idx.memo >= 0 ? String(line[idx.memo] || "").trim() : "";
          const amount = parseAmount(line[idx.amount]);
          const status = idx.cleared >= 0 ? parseClearedStatus(line[idx.cleared]) : "cleared";

          out.push({
            lineNo: r + 1,
            date: date,
            account: account,
            payee: payee,
            category: category,
            subcategory: subcategory,
            memo: memo,
            amount: amount,
            status: status
          });
        }

        return {
          rows: out,
          hasClearedColumn: idx.cleared >= 0
        };
      }

      function renderPreview() {
        const body = $("#previewBody");
        const rows = state.parsedRows.slice(0, 15);
        body.innerHTML = rows.map((r) => {
          return "<tr>" +
            "<td>" + r.lineNo + "</td>" +
            "<td>" + escapeHtml(r.date) + "</td>" +
            "<td>" + escapeHtml(r.account) + "</td>" +
            "<td>" + escapeHtml(r.payee) + "</td>" +
            "<td>" + escapeHtml(r.category) + "</td>" +
            "<td>" + escapeHtml(r.subcategory) + "</td>" +
            "<td>" + escapeHtml(r.amount) + "</td>" +
            "<td>" + escapeHtml(r.status || "") + "</td>" +
            "</tr>";
        }).join("");

        const bad = state.parsedRows.filter((r) => !r.date || !r.account || !r.category || r.amount == null || !r.status).length;
        $("#previewSummary").textContent = "Parsed rows: " + state.parsedRows.length + ". Invalid rows: " + bad + ".";
      }

      function invalidReason(row) {
        const missing = [];
        if (!row.date) missing.push("date");
        if (!row.account) missing.push("account");
        if (!row.category) missing.push("category");
        if (row.amount == null) missing.push("amount");
        if (!row.status) missing.push("cleared");
        return missing.length ? ("missing/invalid: " + missing.join(", ")) : "";
      }

      function firstInvalidRow(rows) {
        for (let i = 0; i < rows.length; i++) {
          const r = rows[i];
          if (!r.date || !r.account || !r.category || r.amount == null || !r.status) {
            return r;
          }
        }
        return null;
      }

      function hasInvalidValueError(err, fieldName, badValue) {
        if (!err || err.status !== 400) return false;
        const top = String(err.message || "").toLowerCase();
        if (top.includes("validation_invalid_value") && top.includes(String(badValue || "").toLowerCase())) return true;
        const data = err.responseData && err.responseData.data ? err.responseData.data : null;
        const field = data && fieldName ? data[fieldName] : null;
        if (!field) return false;
        const msg = String(field.message || "").toLowerCase();
        return msg.includes("invalid value") || msg.includes(String(badValue || "").toLowerCase());
      }

      function pushLog(kind, msg) {
        const box = $("#logBox");
        const div = document.createElement("div");
        div.className = "logLine" + (kind ? " " + kind : "");
        div.textContent = msg;
        box.appendChild(div);
        box.scrollTop = box.scrollHeight;
      }

      function clearLog() {
        $("#logBox").innerHTML = "";
      }

      function keyOfName(name) {
        return String(name || "").trim().toLowerCase();
      }

      async function loadReferenceData() {
        const [accounts, categories, assets] = await Promise.all([
          listRecordsSafe("accounts", { filter: "is_archived = false", sort: "name", perPage: 500 }),
          listRecordsSafe("categories", { filter: "is_archived = false", sort: "name", perPage: 500 }),
          listRecordsSafe("assets", { sort: "symbol", perPage: 200 })
        ]);

        state.refs.accountsByName = new Map(accounts.map((a) => [keyOfName(a.name), a]));
        state.refs.categoriesByName = new Map(categories.map((c) => [keyOfName(c.name), c]));
        state.refs.assetsBySymbol = new Map(assets.map((a) => [String(a.symbol || "").toUpperCase(), a]));
      }

      async function ensureUsdAsset() {
        const existing = state.refs.assetsBySymbol.get("USD");
        if (existing) return existing;

        const created = await createRecord("assets", {
          symbol: "USD",
          name: "US Dollar",
          precision: 2
        });

        state.refs.assetsBySymbol.set("USD", created);
        pushLog("ok", "Created missing asset USD (" + created.id + ").");
        return created;
      }

      async function ensureAccount(name) {
        const key = keyOfName(name);
        const found = state.refs.accountsByName.get(key);
        if (found) return found;

        // Some deployments may not include every enum value; retry with common types.
        const typeCandidates = ["other", "bank", "cash", "credit", "brokerage", "crypto", "virtual"];
        let lastErr = null;
        for (let i = 0; i < typeCandidates.length; i++) {
          const type = typeCandidates[i];
          try {
            const created = await createRecord("accounts", {
              name: name,
              type: type,
              is_archived: false
            });
            state.refs.accountsByName.set(key, created);
            pushLog("ok", "Created account: " + name + " (" + created.id + ", type=" + type + ").");
            return created;
          } catch (err) {
            lastErr = err;
            if (hasInvalidValueError(err, "type", type)) continue;
            throw err;
          }
        }

        throw lastErr || new Error("Failed to create account: no valid type enum accepted.");
      }

      async function ensureCategory(name, qtyHint) {
        const key = keyOfName(name);
        const found = state.refs.categoriesByName.get(key);
        if (found) return found;

        const created = await createRecord("categories", {
          name: name,
          kind: categoryKindFromName(name, qtyHint),
          is_archived: false
        });

        state.refs.categoriesByName.set(key, created);
        pushLog("ok", "Created category: " + name + " [" + created.kind + "] (" + created.id + ").");
        return created;
      }

      function buildExternalId(fileName, row) {
        const core = [fileName, row.lineNo, row.date, row.account, row.category, row.amount].join("|");
        return "import:csv:" + core;
      }

      function buildPairedExternalId(fileName, left, right) {
        const ordered = [left, right].sort((a, b) => a.lineNo - b.lineNo);
        const core = [
          fileName,
          "pair",
          ordered[0].lineNo,
          ordered[1].lineNo,
          ordered[0].date,
          ordered[0].account,
          ordered[0].amount,
          ordered[1].account,
          ordered[1].amount
        ].join("|");
        return "import:csv:" + core;
      }

      function isTransferCategory(name) {
        return keyOfName(name) === "transfer";
      }

      function findPairedTransferIndex(rows, index, consumedIndexes) {
        const row = rows[index];
        if (!row || !row.date || !row.account || !row.category || row.amount == null || !row.status) return -1;
        if (!isTransferCategory(row.category)) return -1;

        for (let j = index + 1; j < rows.length; j++) {
          if (consumedIndexes.has(j)) continue;
          const candidate = rows[j];
          if (!candidate || !candidate.date || !candidate.account || !candidate.category || candidate.amount == null || !candidate.status) continue;
          if (!isTransferCategory(candidate.category)) continue;
          if (candidate.date !== row.date) continue;
          if (candidate.amount === -row.amount) return j;
        }

        return -1;
      }

      async function importRows() {
        state.importing = true;
        setBusy();
        clearLog();

        const started = Date.now();
        let createdTxns = 0;
        let createdEntries = 0;
        let createdAccounts = 0;
        let createdCategories = 0;
        let pairedTxns = 0;
        let skipped = 0;
        let failed = 0;
        let loggedFirstInvalid = false;
        const consumedIndexes = new Set();
        let processedRows = 0;

        try {
          setStatus("", "Loading existing accounts/categories/assets...");
          await loadReferenceData();
          const usd = await ensureUsdAsset();
          const useExternalId = $("#idempotentIds").value === "1";
          const fileName = state.file ? state.file.name : "csv";

          setStatus("", "Importing " + state.parsedRows.length + " rows...");
          $("#importStats").textContent = "Running...";

          for (let i = 0; i < state.parsedRows.length; i++) {
            if (consumedIndexes.has(i)) continue;
            const row = state.parsedRows[i];

            if (!row.date || !row.account || !row.category || row.amount == null || !row.status) {
              skipped += 1;
              pushLog("warn", "Line " + row.lineNo + " skipped: missing required value (date/account/category/amount/cleared).");
              if (!loggedFirstInvalid) {
                loggedFirstInvalid = true;
                pushLog("warn", "First invalid row details: " + JSON.stringify({
                  lineNo: row.lineNo,
                  reason: invalidReason(row),
                  date: row.date,
                  account: row.account,
                  category: row.category,
                  amount: row.amount,
                  status: row.status,
                  payee: row.payee,
                  subcategory: row.subcategory,
                  memo: row.memo
                }));
              }
              processedRows += 1;
              continue;
            }

            const pairIndex = findPairedTransferIndex(state.parsedRows, i, consumedIndexes);
            const groupRows = pairIndex >= 0 ? [row, state.parsedRows[pairIndex]] : [row];
            if (pairIndex >= 0) consumedIndexes.add(pairIndex);

            const groupAccounts = [];
            const groupCategories = [];
            try {
              for (let g = 0; g < groupRows.length; g++) {
                const groupRow = groupRows[g];
                const hadAccount = state.refs.accountsByName.has(keyOfName(groupRow.account));
                const account = await ensureAccount(groupRow.account);
                if (!hadAccount) createdAccounts += 1;

                const hadCategory = state.refs.categoriesByName.has(keyOfName(groupRow.category));
                const category = await ensureCategory(groupRow.category, groupRow.amount);
                if (!hadCategory) createdCategories += 1;

                groupAccounts.push(account);
                groupCategories.push(category);
              }

              const txnBody = {
                date: normalizeDateToNoonUtc(groupRows[0].date),
                payee: groupRows[0].payee || groupRows[1]?.payee || null,
                memo: groupRows[0].memo || groupRows[1]?.memo || null,
                source: "import:csv"
              };

              if (useExternalId) {
                txnBody.external_id = groupRows.length === 2
                  ? buildPairedExternalId(fileName, groupRows[0], groupRows[1])
                  : buildExternalId(fileName, groupRows[0]);
              }

              let txn;
              try {
                txn = await createRecord("txns", txnBody);
              } catch (errTxn) {
                const hasExternalIdError = !!(errTxn && errTxn.responseData && errTxn.responseData.data && errTxn.responseData.data.external_id);
                const isDuplicate = useExternalId && errTxn && errTxn.status === 400 && (hasExternalIdError || String(errTxn.message || "").toLowerCase().includes("already exists"));
                if (isDuplicate) {
                  skipped += groupRows.length;
                  processedRows += groupRows.length;
                  pushLog("warn", "Line " + groupRows[0].lineNo + (groupRows.length === 2 ? ("/" + groupRows[1].lineNo) : "") + " skipped: external_id already exists.");
                  continue;
                }
                throw errTxn;
              }

              try {
                for (let g = 0; g < groupRows.length; g++) {
                  const groupRow = groupRows[g];
                  const entryBody = {
                    txn: txn.id,
                    date: normalizeDateToNoonUtc(groupRow.date),
                    account: groupAccounts[g].id,
                    category: groupCategories[g].id,
                    asset: usd.id,
                    qty: groupRow.amount,
                    memo: groupRow.memo || null,
                    status: groupRow.status
                  };
                  if (groupRow.subcategory) entryBody.meta = { subcategory: groupRow.subcategory };
                  await createRecord("entries", entryBody);
                }
              } catch (errEntry) {
                try {
                  await deleteRecord("txns", txn.id);
                } catch {}
                throw errEntry;
              }

              createdTxns += 1;
              createdEntries += groupRows.length;
              if (groupRows.length === 2) pairedTxns += 1;

              processedRows += groupRows.length;
              if (processedRows % 100 === 0) {
                setStatus("", "Importing... " + processedRows + "/" + state.parsedRows.length + " rows processed.");
                $("#importStats").textContent = "Processed " + processedRows + " / " + state.parsedRows.length + " rows...";
              }
            } catch (rowErr) {
              failed += groupRows.length;
              processedRows += groupRows.length;
              pushLog("bad", "Line " + groupRows[0].lineNo + (groupRows.length === 2 ? ("/" + groupRows[1].lineNo) : "") + " failed: " + (rowErr && rowErr.message ? rowErr.message : String(rowErr)));
            }
          }

          const elapsedSec = ((Date.now() - started) / 1000).toFixed(1);
          const summary = [
            "Import complete in " + elapsedSec + "s.",
            "Txns created: " + createdTxns,
            "Entries created: " + createdEntries,
            "Paired transfers: " + pairedTxns,
            "Accounts created: " + createdAccounts,
            "Categories created: " + createdCategories,
            "Skipped: " + skipped,
            "Failed: " + failed
          ].join(" ");

          $("#importStats").textContent = summary;
          if (failed === 0) setStatus("ok", summary);
          else setStatus("warn", summary);
        } catch (err) {
          const cls = classifyError(err);
          setStatus(cls.kind, cls.message);
          $("#importStats").textContent = "Import aborted: " + (err && err.message ? err.message : String(err));
          pushLog("bad", "Import aborted: " + (err && err.message ? err.message : String(err)));
        } finally {
          state.importing = false;
          setBusy();
        }
      }

      async function parseCurrentFile() {
        if (!state.file) {
          setStatus("warn", "Choose a CSV file first.");
          return;
        }

        const text = await state.file.text();
        const parsed = parseCsvRows(text);
        state.parsedRows = parsed.rows;
        renderPreview();
        setBusy();
        const badRow = firstInvalidRow(state.parsedRows);
        if (badRow) {
          const details = {
            lineNo: badRow.lineNo,
            reason: invalidReason(badRow),
            date: badRow.date,
            account: badRow.account,
            category: badRow.category,
            amount: badRow.amount,
            status: badRow.status,
            payee: badRow.payee,
            subcategory: badRow.subcategory,
            memo: badRow.memo
          };
          pushLog("warn", "First invalid row after parse: " + JSON.stringify(details));
          setStatus("warn", "CSV parsed with invalid rows. First invalid row printed in Import Log.");
        } else {
          if (parsed.hasClearedColumn) setStatus("ok", "CSV parsed. Cleared column detected. Ready to import " + state.parsedRows.length + " rows.");
          else setStatus("ok", "CSV parsed. No Cleared column found; defaulting all entry status values to cleared for " + state.parsedRows.length + " rows.");
        }
      }

      function setFile(file) {
        state.file = file || null;
        state.parsedRows = [];
        $("#previewBody").innerHTML = "";
        $("#previewSummary").textContent = "No parsed rows.";
        $("#fileInfo").textContent = file ? (file.name + " (" + file.size + " bytes)") : "No file loaded.";
        setBusy();
      }

      function handleDropFiles(files) {
        if (!files || !files.length) return;
        const f = files[0];
        setFile(f);
      }

      $("#btnLogin").addEventListener("click", async () => {
        const base = $("#pbUrl").value.trim().replace(/\/+$/, "");
        const email = $("#pbEmail").value.trim();
        const password = $("#pbPass").value;

        if (!base) {
          setStatus("bad", "Login failed: enter URL.");
          return;
        }
        if (!email || !password) {
          setStatus("bad", "Login failed: enter email and password.");
          return;
        }

        store.set("pbUrl", base);
        store.set("pbEmail", email);

        try {
          $("#btnLogin").disabled = true;
          SESSION.base = base;
          SESSION.token = "";

          const res = await authWithPassword(email, password);
          if (!res || !res.token) throw new Error("No token returned by PocketBase.");

          SESSION.token = res.token;
          store.set("pbToken", SESSION.token);

          setLoggedInUI(true);
          setStatus("ok", "Login succeeded.");
        } catch (err) {
          const cls = classifyError(err);
          SESSION.token = "";
          store.del("pbToken");
          setLoggedInUI(false);
          setStatus(cls.kind, cls.message);
        } finally {
          $("#btnLogin").disabled = false;
          setBusy();
        }
      });

      $("#logoutLink").addEventListener("click", (e) => {
        e.preventDefault();
        SESSION.base = "";
        SESSION.token = "";
        store.del("pbUrl");
        store.del("pbEmail");
        store.del("pbToken");
        $("#pbUrl").value = "";
        $("#pbEmail").value = "";
        $("#pbPass").value = "";
        setFile(null);
        clearLog();
        setLoggedInUI(false);
        setStatus("", "Logged out.");
        setBusy();
      });

      $("#csvFile").addEventListener("change", (e) => {
        const f = e.target.files && e.target.files[0] ? e.target.files[0] : null;
        setFile(f);
        if (!f || !SESSION.token) return;
        parseCurrentFile().catch((err) => {
          state.parsedRows = [];
          renderPreview();
          setBusy();
          setStatus("bad", "Parse failed: " + (err && err.message ? err.message : String(err)));
        });
      });

      $("#btnClearFile").addEventListener("click", () => {
        $("#csvFile").value = "";
        setFile(null);
      });

      $("#btnPreview").addEventListener("click", async () => {
        try {
          await parseCurrentFile();
        } catch (err) {
          state.parsedRows = [];
          renderPreview();
          setBusy();
          setStatus("bad", "Parse failed: " + (err && err.message ? err.message : String(err)));
        }
      });

      $("#btnImport").addEventListener("click", importRows);

      const dz = $("#dropzone");
      dz.addEventListener("dragover", (e) => {
        e.preventDefault();
        dz.classList.add("active");
      });
      dz.addEventListener("dragleave", () => dz.classList.remove("active"));
      dz.addEventListener("drop", (e) => {
        e.preventDefault();
        dz.classList.remove("active");
        const files = e.dataTransfer ? e.dataTransfer.files : [];
        handleDropFiles(files);
        if (!files || !files.length || !SESSION.token) return;
        parseCurrentFile().catch((err) => {
          state.parsedRows = [];
          renderPreview();
          setBusy();
          setStatus("bad", "Parse failed: " + (err && err.message ? err.message : String(err)));
        });
      });

      (async function init() {
        $("#pbUrl").value = store.get("pbUrl", "");
        $("#pbEmail").value = store.get("pbEmail", "");

        SESSION.base = store.get("pbUrl", "").trim().replace(/\/+$/, "");
        SESSION.token = store.get("pbToken", "").trim();

        if (SESSION.base && SESSION.token) {
          try {
            const res = await authRefresh();
            if (res && res.token) {
              SESSION.token = res.token;
              store.set("pbToken", res.token);
            }
            setLoggedInUI(true);
            setStatus("ok", "Session restored via auth-refresh.");
          } catch {
            SESSION.token = "";
            store.del("pbToken");
            setLoggedInUI(false);
            setStatus("warn", "Saved session expired. Please log in again.");
          }
        } else {
          setLoggedInUI(false);
          setStatus("", "Not authenticated.");
        }

        setBusy();
      })();
    })();
  </script>
</body>
</html>
