<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BudgetKit - CSV Importer</title>
  <style>
    :root {
      --bg: #0a0f16;
      --panel: #111a26;
      --panel2: #172335;
      --text: #e7edf6;
      --muted: #a8b7ca;
      --line: #2a3a52;
      --accent: #6ec1ff;
      --ok: #3ed598;
      --warn: #ffd479;
      --bad: #ff7f7f;
      --radius: 12px;
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--sans);
      color: var(--text);
      background: radial-gradient(circle at top right, #17263b 0%, #0a0f16 45%, #070b10 100%);
      min-height: 100vh;
    }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
    .topbar, .panel {
      border: 1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(17, 26, 38, 0.92);
      box-shadow: var(--shadow);
    }
    .topbar {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 12px;
      flex-wrap: wrap;
      padding: 12px;
    }
    h1 { margin: 0; font-size: 18px; }
    .sub { margin-top: 4px; color: var(--muted); font-size: 12px; }
    .auth {
      display: flex;
      gap: 8px;
      align-items: flex-end;
      flex-wrap: wrap;
    }
    .field { display: flex; flex-direction: column; gap: 5px; }
    label { color: var(--muted); font-size: 12px; }
    input[type="text"], input[type="password"], input[type="file"], select {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(23, 35, 53, 0.95);
      color: var(--text);
      padding: 8px 10px;
      outline: none;
    }
    input:focus, select:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(110, 193, 255, 0.15); }
    .btn {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 12px;
      background: rgba(23, 35, 53, 0.95);
      color: var(--text);
      cursor: pointer;
      font-weight: 600;
    }
    .btn:hover { border-color: var(--accent); }
    .btn.primary { border-color: rgba(110, 193, 255, 0.55); background: rgba(110, 193, 255, 0.18); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .logout {
      display: none;
      color: var(--muted);
      text-decoration: none;
      font-size: 12px;
      margin-left: 8px;
    }
    .status {
      margin-top: 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 9px 10px;
      font-size: 13px;
      background: rgba(14, 22, 33, 0.75);
      color: var(--muted);
    }
    .status.ok { border-color: rgba(62, 213, 152, 0.45); color: #bdf7df; }
    .status.warn { border-color: rgba(255, 212, 121, 0.45); color: #ffeabc; }
    .status.bad { border-color: rgba(255, 127, 127, 0.45); color: #ffd1d1; }
    #app { display: none; margin-top: 12px; }
    .panel { padding: 12px; margin-bottom: 12px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: flex-end; }
    .dropzone {
      border: 2px dashed rgba(110, 193, 255, 0.45);
      border-radius: 12px;
      padding: 18px;
      text-align: center;
      color: var(--muted);
      background: rgba(23, 35, 53, 0.35);
      transition: border-color 120ms, background-color 120ms;
    }
    .dropzone.active {
      border-color: rgba(62, 213, 152, 0.7);
      background: rgba(62, 213, 152, 0.12);
      color: #bdf7df;
    }
    .mono { font-family: var(--mono); font-size: 12px; color: var(--muted); }
    .help { color: var(--muted); font-size: 12px; line-height: 1.35; }
    table { width: 100%; border-collapse: collapse; table-layout: fixed; }
    th, td {
      border-bottom: 1px solid rgba(42, 58, 82, 0.75);
      padding: 8px 6px;
      font-size: 12px;
      text-align: left;
      vertical-align: top;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    th { color: var(--muted); font-size: 11px; text-transform: uppercase; }
    .log {
      max-height: 220px;
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px;
      background: rgba(14, 22, 33, 0.75);
      font-family: var(--mono);
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .logLine { margin-bottom: 4px; }
    .logLine.bad { color: #ffd1d1; }
    .logLine.warn { color: #ffeabc; }
    .logLine.ok { color: #bdf7df; }
    @media (max-width: 760px) {
      .auth input[type="text"], .auth input[type="password"] { width: 100%; }
      .auth .field { min-width: 100%; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1>CSV Importer <a class="logout" id="logoutLink" href="#">logout</a></h1>
        <div class="sub">Imports register-style CSV rows into `txns` and `entries`.</div>
      </div>
      <div class="auth" id="authPanel">
        <div class="field">
          <label for="pbUrl">URL</label>
          <input id="pbUrl" type="text" placeholder="http://127.0.0.1:8090" />
        </div>
        <div class="field">
          <label for="pbEmail">Email</label>
          <input id="pbEmail" type="text" placeholder="you@example.com" />
        </div>
        <div class="field">
          <label for="pbPass">Password</label>
          <input id="pbPass" type="password" placeholder="password" />
        </div>
        <button class="btn primary" id="btnLogin" type="button">Login</button>
      </div>
    </div>

    <div class="status" id="statusBox">Not authenticated.</div>

    <div id="app">
      <section class="panel">
        <div class="row" style="justify-content:space-between;">
          <h2 style="margin:0;font-size:14px;">CSV File</h2>
          <button class="btn" id="btnClearFile" type="button">Clear File</button>
        </div>
        <div id="dropzone" class="dropzone" style="margin-top:10px;">
          Drag and drop CSV here, or choose file below.
        </div>
        <div class="row" style="margin-top:10px;">
          <div class="field" style="flex:1;min-width:260px;">
            <label for="csvFile">File</label>
            <input id="csvFile" type="file" accept=".csv,text/csv" />
          </div>
          <div class="field">
            <label for="idempotentIds">External IDs</label>
            <select id="idempotentIds">
              <option value="1" selected>Set deterministic IDs</option>
              <option value="0">Do not set IDs</option>
            </select>
          </div>
          <button class="btn" id="btnPreview" type="button">Parse Preview</button>
          <button class="btn primary" id="btnImport" type="button" disabled>Import CSV</button>
        </div>
        <div class="help" style="margin-top:8px;">
          Expected headers: Date, Account, Payee, Category, Subcategory, Memo, Amount. Optional header: Cleared (`TRUE` = cleared, `FALSE` = pending). If Cleared is missing, status defaults to `cleared`. Payee values ending with a supported card category suffix (for example `Jersey Mike Restaurant`) are split into payee name + card category unless the full payee name already exists. All rows import with asset `USD`.
        </div>
        <div class="mono" id="fileInfo" style="margin-top:8px;">No file loaded.</div>
      </section>

      <section class="panel">
        <h2 style="margin:0 0 10px;font-size:14px;">Preview (first 15 rows)</h2>
        <div style="overflow:auto;">
          <table>
            <thead>
              <tr>
                <th>Line</th>
                <th>Date</th>
                <th>Account</th>
                <th>Payee</th>
                <th>Category</th>
                <th>Subcategory</th>
                <th>Amount</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody id="previewBody"></tbody>
          </table>
        </div>
        <div class="mono" id="previewSummary" style="margin-top:8px;">No parsed rows.</div>
      </section>

      <section class="panel">
        <h2 style="margin:0 0 10px;font-size:14px;">Import Log</h2>
        <div id="importStats" class="mono" style="margin-bottom:8px;">No import run yet.</div>
        <div id="logBox" class="log"></div>
      </section>
    </div>
  </div>

  <script>
    (function() {
      const $ = (s, el) => (el || document).querySelector(s);
      const store = {
        get(k, d) { try { const v = localStorage.getItem(k); return v == null ? d : v; } catch { return d; } },
        set(k, v) { try { localStorage.setItem(k, v); } catch {} },
        del(k) { try { localStorage.removeItem(k); } catch {} }
      };

      const SESSION = { base: "", token: "" };
      const state = {
        file: null,
        parsedRows: [],
        parsedRowsSortedByDate: false,
        importing: false,
        usdPrecision: 2,
        refs: {
          accountsByName: new Map(),
          categoriesByName: new Map(),
          assetsBySymbol: new Map(),
          payeesByName: new Map()
        }
      };

      const PAYEE_CARD_CATEGORIES = ["restaurant", "intlrest", "grocery", "airlines", "hotel", "rental", "parking", "toll", "taxi"];
      const TXN_IMPORT_CONCURRENCY = 6;
      const SHARED_SAVINGS_CATEGORY_KEY = "savings: shared";
      const SHARED_SAVINGS_SHARON = "Savings: Sharon";
      const SHARED_SAVINGS_TAYLOR = "Savings: Taylor";

      function setStatus(kind, message) {
        const box = $("#statusBox");
        box.className = "status" + (kind ? " " + kind : "");
        box.textContent = message;
      }

      async function runWithConcurrency(items, concurrency, worker) {
        const total = Array.isArray(items) ? items.length : 0;
        if (!total) return;
        const limit = Math.max(1, Math.min(Number(concurrency) || 1, total));
        let nextIndex = 0;
        const runners = [];
        for (let r = 0; r < limit; r++) {
          runners.push((async () => {
            while (true) {
              const current = nextIndex;
              nextIndex += 1;
              if (current >= total) break;
              await worker(items[current], current);
            }
          })());
        }
        await Promise.all(runners);
      }

      function escapeHtml(v) {
        return String(v == null ? "" : v)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      function setLoggedInUI(isLoggedIn) {
        $("#authPanel").style.display = isLoggedIn ? "none" : "flex";
        $("#logoutLink").style.display = isLoggedIn ? "inline" : "none";
        $("#app").style.display = isLoggedIn ? "block" : "none";
      }

      function setBusy() {
        const isAuthed = !!SESSION.token;
        const hasRows = state.parsedRows.length > 0;
        $("#btnImport").disabled = !isAuthed || !hasRows || state.importing;
        $("#btnPreview").disabled = !isAuthed || !state.file || state.importing;
        $("#btnClearFile").disabled = state.importing;
        $("#csvFile").disabled = !isAuthed || state.importing;
        $("#idempotentIds").disabled = state.importing;
        $("#btnLogin").disabled = state.importing;
      }

      function classifyError(err) {
        if (!err || typeof err !== "object") return { kind: "bad", message: String(err || "Unknown error") };
        if (err.kind === "network") return { kind: "bad", message: "Network error: check URL, protocol (http/https), host, and CORS." };
        if (err.kind === "auth") return { kind: "bad", message: "Auth failure: session expired or credentials/token were rejected." };
        if (err.kind === "query") return { kind: "warn", message: "Query/schema mismatch (HTTP 400): fallback query was used." };
        return { kind: "bad", message: err.message || "Request failed." };
      }

      async function pbFetch(path, options) {
        if (!SESSION.base) {
          const e = new Error("PocketBase URL is required.");
          e.kind = "auth";
          throw e;
        }

        const headers = Object.assign({ "Content-Type": "application/json" }, (options && options.headers) || {});
        if (SESSION.token) headers["Authorization"] = /^Bearer\s+/i.test(SESSION.token) ? SESSION.token : ("Bearer " + SESSION.token);

        let res;
        try {
          res = await fetch(SESSION.base + path, Object.assign({}, options || {}, { headers }));
        } catch (error) {
          const e = new Error("Network error (fetch failed): " + (error && error.message ? error.message : String(error)));
          e.kind = "network";
          throw e;
        }

        const text = await res.text();
        let data = null;
        try { data = text ? JSON.parse(text) : null; } catch { data = text; }

        if (!res.ok) {
          const e = new Error("HTTP " + res.status + ": " + (typeof data === "string" ? data : JSON.stringify(data || {})));
          e.status = res.status;
          e.responseData = data;
          if (res.status === 401 || res.status === 403) e.kind = "auth";
          else if (res.status === 400) e.kind = "query";
          else e.kind = "bad";
          throw e;
        }

        return data;
      }

      async function authWithPassword(email, password) {
        return pbFetch("/api/collections/users/auth-with-password", {
          method: "POST",
          body: JSON.stringify({ identity: email, password: password })
        });
      }

      async function authRefresh() {
        return pbFetch("/api/collections/users/auth-refresh", { method: "POST" });
      }

      async function createRecord(collection, body) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records", {
          method: "POST",
          body: JSON.stringify(body)
        });
      }

      async function updateRecord(collection, id, body) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records/" + encodeURIComponent(id), {
          method: "PATCH",
          body: JSON.stringify(body)
        });
      }

      async function deleteRecord(collection, id) {
        return pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records/" + encodeURIComponent(id), {
          method: "DELETE"
        });
      }

      function toQS(params) {
        return Object.keys(params)
          .filter((k) => params[k] !== "" && params[k] != null)
          .map((k) => encodeURIComponent(k) + "=" + encodeURIComponent(params[k]))
          .join("&");
      }

      async function listRecordsSafe(collection, opts) {
        const options = opts || {};
        const perPage = options.perPage || 200;

        async function runAttempt(params) {
          const items = [];
          let page = 1;
          while (true) {
            const qs = toQS(Object.assign({}, params, { page: page, perPage: perPage }));
            const data = await pbFetch("/api/collections/" + encodeURIComponent(collection) + "/records?" + qs, { method: "GET" });
            const rows = (data && data.items) ? data.items : [];
            for (const row of rows) items.push(row);
            const totalPages = Number(data && data.totalPages ? data.totalPages : 1);
            if (page >= totalPages) break;
            page += 1;
          }
          return items;
        }

        const attempts = [
          { filter: options.filter || "", sort: options.sort || "" },
          { sort: options.sort || "" },
          {}
        ];

        let saw400 = false;
        for (let i = 0; i < attempts.length; i++) {
          try {
            return await runAttempt(attempts[i]);
          } catch (err) {
            if (err && err.status === 400) {
              saw400 = true;
              continue;
            }
            throw err;
          }
        }

        if (saw400) {
          const e = new Error("HTTP 400 on all list query attempts.");
          e.kind = "query";
          throw e;
        }

        return [];
      }

      function normalizeDateToNoonUtc(dateStr) {
        return dateStr + "T12:00:00Z";
      }

      function normalizeDateInput(s) {
        const raw = String(s || "").trim();
        if (!raw) return "";
        if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) return raw;
        const d = new Date(raw);
        if (isNaN(d.getTime())) return "";
        return d.toISOString().slice(0, 10);
      }

      function normalizePrecision(raw) {
        const n = Number(raw);
        if (Number.isInteger(n) && n >= 0 && n <= 9) return n;
        return 2;
      }

      function parseMajorToMinor(raw, precision) {
        let s = String(raw == null ? "" : raw).trim();
        if (!s) throw new Error("Amount is required.");
        s = s.replaceAll("$", "").replaceAll(",", "").trim();
        if (/^\(.*\)$/.test(s)) s = "-" + s.slice(1, -1);
        if (!/^-?\d+(\.\d+)?$/.test(s)) throw new Error("Amount must be numeric.");

        const neg = s.startsWith("-");
        const unsigned = neg ? s.slice(1) : s;
        const parts = unsigned.split(".");
        const whole = parts[0] || "0";
        const frac = parts[1] || "";
        if (frac.length > precision) throw new Error("Amount has more than " + precision + " decimal places.");

        const scale = 10 ** precision;
        const wholeNum = Number(whole);
        const fracNum = frac ? Number(frac.padEnd(precision, "0")) : 0;
        if (!Number.isFinite(wholeNum) || !Number.isFinite(fracNum)) throw new Error("Amount must be numeric.");
        const minor = wholeNum * scale + fracNum;
        if (!Number.isSafeInteger(minor)) throw new Error("Amount is too large.");
        return neg ? -minor : minor;
      }

      function fmtMinor(minor, precision) {
        const n = Number(minor || 0);
        if (!Number.isFinite(n)) return "";
        const scale = 10 ** precision;
        const sign = n < 0 ? "-" : "";
        const abs = Math.abs(Math.trunc(n));
        const whole = Math.floor(abs / scale);
        if (precision === 0) return sign + whole.toLocaleString();
        const frac = String(abs % scale).padStart(precision, "0");
        return sign + whole.toLocaleString() + "." + frac;
      }

      function parseClearedStatus(raw) {
        const s = String(raw == null ? "" : raw).trim().toUpperCase();
        if (!s) return null;
        if (s === "TRUE") return "cleared";
        if (s === "FALSE") return "pending";
        return null;
      }

      function splitPayeeAndCardCategory(rawPayee) {
        const raw = String(rawPayee || "").trim().replace(/\s+/g, " ");
        if (!raw) return { name: "", cardCategory: null };
        const parts = raw.split(" ");
        const tail = String(parts[parts.length - 1] || "").toLowerCase();
        if (PAYEE_CARD_CATEGORIES.includes(tail) && parts.length > 1) {
          return { name: parts.slice(0, -1).join(" ").trim(), cardCategory: tail };
        }
        return { name: raw, cardCategory: null };
      }

      function parsePayeeForImport(rawPayee, payeesByName) {
        const raw = String(rawPayee || "").trim().replace(/\s+/g, " ");
        if (!raw) return { name: "", cardCategory: null, wasSplit: false };

        const fullKey = keyOfName(raw);
        if (payeesByName && payeesByName.has(fullKey)) {
          return { name: raw, cardCategory: null, wasSplit: false };
        }

        const parsed = splitPayeeAndCardCategory(raw);
        return {
          name: parsed.name,
          cardCategory: parsed.cardCategory,
          wasSplit: !!parsed.cardCategory && keyOfName(parsed.name) !== fullKey
        };
      }

      function categoryKindFromName(name, qty) {
        const n = String(name || "").trim().toLowerCase();
        const lead = n.includes(":") ? n.slice(0, n.indexOf(":")).trim() : n;
        if (lead === "income") return "income";
        if (lead === "spending" || lead === "expense") return "expense";
        if (lead === "transfer") return "transfer";
        if (lead === "trade_cash") return "trade_cash";
        if (lead === "trade_asset") return "trade_asset";
        if (lead === "fee") return "fee";
        if (lead === "withholding") return "withholding";
        if (lead === "benefit") return "benefit";
        if (lead === "employer_contrib") return "employer_contrib";
        if (lead === "info") return "info";
        if (qty != null) return qty >= 0 ? "income" : "expense";
        return "other";
      }

      function isSharedSavingsCategory(name) {
        return keyOfName(name) === SHARED_SAVINGS_CATEGORY_KEY;
      }

      function roundHalfEven(value) {
        if (!Number.isFinite(value)) throw new Error("Amount must be numeric.");
        const lower = Math.floor(value);
        const upper = Math.ceil(value);
        if (lower === upper) return lower;
        const dLower = Math.abs(value - lower);
        const dUpper = Math.abs(value - upper);
        if (dLower < dUpper) return lower;
        if (dUpper < dLower) return upper;
        return Math.abs(lower % 2) === 0 ? lower : upper;
      }

      function splitSharedSavingsAmountMinor(amountMinor) {
        const sharonMinor = roundHalfEven(amountMinor / 2);
        const taylorMinor = amountMinor - sharonMinor;
        if (!Number.isSafeInteger(sharonMinor) || !Number.isSafeInteger(taylorMinor)) {
          throw new Error("Amount split is too large.");
        }
        return { sharonMinor, taylorMinor };
      }

      function csvParse(text) {
        const rows = [];
        let i = 0;
        let cell = "";
        let row = [];
        let inQuotes = false;

        while (i < text.length) {
          const ch = text[i];

          if (inQuotes) {
            if (ch === '"') {
              if (text[i + 1] === '"') {
                cell += '"';
                i += 2;
                continue;
              }
              inQuotes = false;
              i += 1;
              continue;
            }
            cell += ch;
            i += 1;
            continue;
          }

          if (ch === '"') {
            inQuotes = true;
            i += 1;
            continue;
          }

          if (ch === ',') {
            row.push(cell);
            cell = "";
            i += 1;
            continue;
          }

          if (ch === '\n') {
            row.push(cell);
            rows.push(row);
            row = [];
            cell = "";
            i += 1;
            continue;
          }

          if (ch === '\r') {
            i += 1;
            continue;
          }

          cell += ch;
          i += 1;
        }

        if (cell.length || row.length) {
          row.push(cell);
          rows.push(row);
        }

        return rows;
      }

      function parseCsvRows(text, usdPrecision, payeesByName) {
        const matrix = csvParse(text);
        if (!matrix.length) throw new Error("CSV is empty.");

        const headers = matrix[0].map((h) => String(h || "").trim().toLowerCase());
        const idx = {
          date: headers.indexOf("date"),
          account: headers.indexOf("account"),
          payee: headers.indexOf("payee"),
          category: headers.indexOf("category"),
          subcategory: headers.indexOf("subcategory"),
          memo: headers.indexOf("memo"),
          amount: headers.indexOf("amount"),
          cleared: headers.indexOf("cleared")
        };

        const required = ["date", "account", "category", "amount"];
        for (const k of required) {
          if (idx[k] < 0) throw new Error("Missing required column: " + k);
        }

        const out = [];
        let prevDate = "";
        let isSortedByDate = true;
        for (let r = 1; r < matrix.length; r++) {
          const line = matrix[r];
          if (!line || !line.length || line.every((x) => String(x || "").trim() === "")) continue;

          const date = normalizeDateInput(line[idx.date]);
          const account = String(line[idx.account] || "").trim();
          const payeeRaw = idx.payee >= 0 ? String(line[idx.payee] || "").trim().replace(/\s+/g, " ") : "";
          const parsedPayee = parsePayeeForImport(payeeRaw, payeesByName);
          const category = String(line[idx.category] || "").trim();
          const subcategory = idx.subcategory >= 0 ? String(line[idx.subcategory] || "").trim() : "";
          const memo = idx.memo >= 0 ? String(line[idx.memo] || "").trim() : "";
          let amountMinor = null;
          try {
            amountMinor = parseMajorToMinor(line[idx.amount], usdPrecision);
          } catch (err) {
            throw new Error("Line " + (r + 2) + " invalid amount '" + String(line[idx.amount] || "").trim() + "': " + (err && err.message ? err.message : "invalid amount"));
          }
          const status = idx.cleared >= 0 ? parseClearedStatus(line[idx.cleared]) : "cleared";

          if (date) {
            if (prevDate && date < prevDate) isSortedByDate = false;
            prevDate = date;
          }

          const baseRow = {
            lineNo: r + 1,
            date: date,
            account: account,
            payeeRaw: payeeRaw,
            payeeName: parsedPayee.name,
            payeeCardCategory: parsedPayee.cardCategory,
            payeeWasSplit: parsedPayee.wasSplit,
            category: category,
            subcategory: subcategory,
            memo: memo,
            amountMinor: amountMinor,
            status: status,
            splitGroupType: "",
            splitGroupKey: ""
          };

          if (isSharedSavingsCategory(category)) {
            const split = splitSharedSavingsAmountMinor(amountMinor);
            const splitGroupKey = "savings-shared:" + String(r + 1);
            out.push(Object.assign({}, baseRow, {
              category: SHARED_SAVINGS_SHARON,
              amountMinor: split.sharonMinor,
              splitGroupType: "savings_shared",
              splitGroupKey: splitGroupKey
            }));
            out.push(Object.assign({}, baseRow, {
              category: SHARED_SAVINGS_TAYLOR,
              amountMinor: split.taylorMinor,
              splitGroupType: "savings_shared",
              splitGroupKey: splitGroupKey
            }));
            continue;
          }

          out.push(baseRow);
        }

        return {
          rows: out,
          hasClearedColumn: idx.cleared >= 0,
          isSortedByDate: isSortedByDate
        };
      }

      function renderPreview() {
        const body = $("#previewBody");
        const rows = state.parsedRows.slice(0, 15);
        body.innerHTML = rows.map((r) => {
          return "<tr>" +
            "<td>" + r.lineNo + "</td>" +
            "<td>" + escapeHtml(r.date) + "</td>" +
            "<td>" + escapeHtml(r.account) + "</td>" +
            "<td>" + escapeHtml(r.payeeName + (r.payeeCardCategory ? (" {" + r.payeeCardCategory + "}") : "")) + "</td>" +
            "<td>" + escapeHtml(r.category) + "</td>" +
            "<td>" + escapeHtml(r.subcategory) + "</td>" +
            "<td>" + escapeHtml(fmtMinor(r.amountMinor, state.usdPrecision)) + "</td>" +
            "<td>" + escapeHtml(r.status || "") + "</td>" +
            "</tr>";
        }).join("");

        const bad = state.parsedRows.filter((r) => !r.date || !r.account || !r.category || r.amountMinor == null || !r.status).length;
        $("#previewSummary").textContent = "Parsed rows: " + state.parsedRows.length + ". Invalid rows: " + bad + ".";
      }

      function invalidReason(row) {
        const missing = [];
        if (!row.date) missing.push("date");
        if (!row.account) missing.push("account");
        if (!row.category) missing.push("category");
        if (row.amountMinor == null) missing.push("amount");
        if (!row.status) missing.push("cleared");
        return missing.length ? ("missing/invalid: " + missing.join(", ")) : "";
      }

      function firstInvalidRow(rows) {
        for (let i = 0; i < rows.length; i++) {
          const r = rows[i];
          if (!r.date || !r.account || !r.category || r.amountMinor == null || !r.status) {
            return r;
          }
        }
        return null;
      }

      function isImportRowValid(row) {
        return !!(row && row.date && row.account && row.category && row.amountMinor != null && row.status);
      }

      function hasInvalidValueError(err, fieldName, badValue) {
        if (!err || err.status !== 400) return false;
        const top = String(err.message || "").toLowerCase();
        if (top.includes("validation_invalid_value") && top.includes(String(badValue || "").toLowerCase())) return true;
        const data = err.responseData && err.responseData.data ? err.responseData.data : null;
        const field = data && fieldName ? data[fieldName] : null;
        if (!field) return false;
        const msg = String(field.message || "").toLowerCase();
        return msg.includes("invalid value") || msg.includes(String(badValue || "").toLowerCase());
      }

      function hasDuplicateNameError(err, fieldName) {
        if (!err || err.status !== 400) return false;
        const top = String(err.message || "").toLowerCase();
        if (top.includes("already exists")) return true;
        const data = err.responseData && err.responseData.data ? err.responseData.data : null;
        const field = data && fieldName ? data[fieldName] : null;
        if (!field) return false;
        const msg = String(field.message || "").toLowerCase();
        return msg.includes("already exists") || msg.includes("must be unique") || msg.includes("duplicate");
      }

      function pushLog(kind, msg) {
        const box = $("#logBox");
        const div = document.createElement("div");
        div.className = "logLine" + (kind ? " " + kind : "");
        div.textContent = msg;
        box.appendChild(div);
        box.scrollTop = box.scrollHeight;
      }

      function clearLog() {
        $("#logBox").innerHTML = "";
      }

      function keyOfName(name) {
        return String(name || "").trim().toLowerCase();
      }

      function indexByName(records) {
        const byName = new Map();
        for (const record of (records || [])) {
          const key = keyOfName(record && record.name);
          if (!key) continue;
          const current = byName.get(key);
          if (!current) {
            byName.set(key, record);
            continue;
          }
          // If duplicates exist, prefer non-archived so imports use active records when available.
          if (current && current.is_archived === true && record && record.is_archived !== true) {
            byName.set(key, record);
          }
        }
        return byName;
      }

      async function loadReferenceData() {
        const [accounts, categories, assets, payees] = await Promise.all([
          listRecordsSafe("accounts", { sort: "name", perPage: 500 }),
          listRecordsSafe("categories", { sort: "name", perPage: 500 }),
          listRecordsSafe("assets", { sort: "symbol", perPage: 200 }),
          listRecordsSafe("payees", { sort: "name", perPage: 500 })
        ]);

        state.refs.accountsByName = indexByName(accounts);
        state.refs.categoriesByName = indexByName(categories);
        state.refs.assetsBySymbol = new Map(assets.map((a) => [String(a.symbol || "").toUpperCase(), a]));
        state.refs.payeesByName = indexByName(payees);
      }

      async function ensureUsdAsset() {
        const existing = state.refs.assetsBySymbol.get("USD");
        if (existing) {
          state.usdPrecision = normalizePrecision(existing.precision);
          return existing;
        }

        const created = await createRecord("assets", {
          symbol: "USD",
          name: "US Dollar",
          precision: 2
        });

        state.refs.assetsBySymbol.set("USD", created);
        state.usdPrecision = normalizePrecision(created.precision);
        pushLog("ok", "Created missing asset USD (" + created.id + ").");
        return created;
      }

      async function ensureAccount(name) {
        const key = keyOfName(name);
        const found = state.refs.accountsByName.get(key);
        if (found) return found;

        // Some deployments may not include every enum value; retry with common types.
        const typeCandidates = ["bank", "credit", "cash", "virtual", "roth", "pretax", "hsa", "brokerage"];
        let lastErr = null;
        for (let i = 0; i < typeCandidates.length; i++) {
          const type = typeCandidates[i];
          try {
            const created = await createRecord("accounts", {
              name: name,
              type: type,
              is_archived: false
            });
            state.refs.accountsByName.set(key, created);
            pushLog("ok", "Created account: " + name + " (" + created.id + ", type=" + type + ").");
            return created;
          } catch (err) {
            lastErr = err;
            if (hasInvalidValueError(err, "type", type)) continue;
            throw err;
          }
        }

        throw lastErr || new Error("Failed to create account: no valid type enum accepted.");
      }

      async function ensureCategory(name, qtyHint) {
        const key = keyOfName(name);
        const found = state.refs.categoriesByName.get(key);
        if (found) return found;

        const created = await createRecord("categories", {
          name: name,
          kind: categoryKindFromName(name, qtyHint),
          is_archived: false
        });

        state.refs.categoriesByName.set(key, created);
        pushLog("ok", "Created category: " + name + " [" + created.kind + "] (" + created.id + ").");
        return created;
      }

      function normalizeCardCategory(value) {
        const raw = String(value || "").trim().toLowerCase();
        return raw || null;
      }

      async function reconcilePayeeCardCategory(found, name, cardCategory) {
        const incomingCategory = normalizeCardCategory(cardCategory);
        const existingCategory = normalizeCardCategory(found && found.card_category);

        if (!incomingCategory) return found;

        if (!existingCategory) {
          const updated = await updateRecord("payees", found.id, { card_category: incomingCategory });
          state.refs.payeesByName.set(keyOfName(name), updated);
          pushLog("ok", "Updated payee card category: " + name + " {" + incomingCategory + "} (" + updated.id + ").");
          return updated;
        }

        if (existingCategory !== incomingCategory) {
          const err = new Error(
            "Payee card category conflict for '" + name + "': existing {" + existingCategory + "} vs incoming {" + incomingCategory + "}."
          );
          err.isPayeeCardCategoryConflict = true;
          throw err;
        }

        return found;
      }

      async function ensurePayee(name, cardCategory) {
        const key = keyOfName(name);
        if (!key) return null;
        const found = state.refs.payeesByName.get(key);
        if (found) return await reconcilePayeeCardCategory(found, name, cardCategory);

        try {
          const created = await createRecord("payees", {
            name: name,
            card_category: cardCategory || null,
            is_archived: false
          });

          state.refs.payeesByName.set(key, created);
          pushLog("ok", "Created payee: " + name + (cardCategory ? (" {" + cardCategory + "}") : "") + " (" + created.id + ").");
          return created;
        } catch (err) {
          if (!hasDuplicateNameError(err, "name")) throw err;
          const payees = await listRecordsSafe("payees", { sort: "name", perPage: 500 });
          state.refs.payeesByName = indexByName(payees);
          const existing = state.refs.payeesByName.get(key);
          if (existing) {
            const reconciled = await reconcilePayeeCardCategory(existing, name, cardCategory);
            pushLog("warn", "Reused existing payee after unique-name conflict: " + name + " (" + reconciled.id + ").");
            return reconciled;
          }
          throw err;
        }
      }

      async function ensurePayeeForRow(row) {
        const payeeName = String(row && row.payeeName || "").trim();
        if (!payeeName) return null;

        try {
          return await ensurePayee(payeeName, row && row.payeeCardCategory);
        } catch (err) {
          const fullRawName = String(row && row.payeeRaw || "").trim().replace(/\s+/g, " ");
          const canFallback = !!(
            err &&
            err.isPayeeCardCategoryConflict &&
            row &&
            row.payeeWasSplit &&
            fullRawName &&
            keyOfName(fullRawName) !== keyOfName(payeeName)
          );
          if (!canFallback) throw err;

          pushLog("warn", "Payee card category conflict on stripped payee; retrying with full payee: " + fullRawName + ".");
          return await ensurePayee(fullRawName, row.payeeCardCategory);
        }
      }

      function payeeEnsureKeyForRow(row) {
        const payeeName = String(row && row.payeeName || "").trim().replace(/\s+/g, " ");
        const payeeRaw = String(row && row.payeeRaw || "").trim().replace(/\s+/g, " ");
        const cardCategory = normalizeCardCategory(row && row.payeeCardCategory) || "";
        const wasSplit = row && row.payeeWasSplit ? "1" : "0";
        return [payeeName, cardCategory, payeeRaw, wasSplit].join("|");
      }

      function buildExternalId(fileName, row) {
        const core = [fileName, row.lineNo, row.date, row.account, row.category, row.amountMinor].join("|");
        return "import:csv:" + core;
      }

      function buildPairedExternalId(fileName, left, right) {
        const ordered = [left, right].sort((a, b) => a.lineNo - b.lineNo);
        const core = [
          fileName,
          "pair",
          ordered[0].lineNo,
          ordered[1].lineNo,
          ordered[0].date,
          ordered[0].account,
          ordered[0].amountMinor,
          ordered[1].account,
          ordered[1].amountMinor
        ].join("|");
        return "import:csv:" + core;
      }

      function isTransferCategory(name) {
        return keyOfName(name) === "transfer";
      }

      function findPairedTransferIndex(rows, index, consumedIndexes, assumeSortedByDate) {
        const row = rows[index];
        if (!row || !row.date || !row.account || !row.category || row.amountMinor == null || !row.status) return -1;
        if (!isTransferCategory(row.category)) return -1;

        for (let j = index + 1; j < rows.length; j++) {
          if (consumedIndexes.has(j)) continue;
          const candidate = rows[j];
          if (!candidate || !candidate.date || !candidate.account || !candidate.category || candidate.amountMinor == null || !candidate.status) continue;
          if (!isTransferCategory(candidate.category)) continue;
          if (assumeSortedByDate && candidate.date > row.date) break;
          if (candidate.date !== row.date) continue;
          if (candidate.amountMinor === -row.amountMinor) return j;
        }

        return -1;
      }

      function findSplitPairIndex(rows, index, consumedIndexes) {
        const row = rows[index];
        if (!row || !row.splitGroupType || !row.splitGroupKey) return -1;
        for (let j = index + 1; j < rows.length; j++) {
          if (consumedIndexes.has(j)) continue;
          const candidate = rows[j];
          if (!candidate) continue;
          if (candidate.splitGroupType === row.splitGroupType && candidate.splitGroupKey === row.splitGroupKey) return j;
        }
        return -1;
      }

      async function importRows() {
        state.importing = true;
        setBusy();
        clearLog();

        const started = Date.now();
        let createdTxns = 0;
        let createdEntries = 0;
        let createdAccounts = 0;
        let createdCategories = 0;
        let createdPayees = 0;
        let pairedTxns = 0;
        let skipped = 0;
        let failed = 0;
        let loggedFirstInvalid = false;
        const consumedIndexes = new Set();
        let processedRows = 0;
        const payeeEnsureFailedKeys = new Set();
        const payeeEnsureResolvedIds = new Map();

        try {
          setStatus("", "Loading existing accounts/categories/assets...");
          await loadReferenceData();
          const usd = await ensureUsdAsset();
          const useExternalId = $("#idempotentIds").value === "1";
          const fileName = state.file ? state.file.name : "csv";

          const missingAccounts = [];
          const missingCategories = [];
          const seenAccountKeys = new Set();
          const seenCategoryKeys = new Set();
          const seenPayeeEnsureKeys = new Set();
          const payeeRowsToEnsure = [];

          for (let i = 0; i < state.parsedRows.length; i++) {
            const row = state.parsedRows[i];
            if (!isImportRowValid(row)) continue;

            const accountKey = keyOfName(row.account);
            if (accountKey && !seenAccountKeys.has(accountKey)) {
              seenAccountKeys.add(accountKey);
              if (!state.refs.accountsByName.has(accountKey)) missingAccounts.push(row.account);
            }

            const categoryKey = keyOfName(row.category);
            if (categoryKey && !seenCategoryKeys.has(categoryKey)) {
              seenCategoryKeys.add(categoryKey);
              if (!state.refs.categoriesByName.has(categoryKey)) {
                missingCategories.push({ name: row.category, qtyHint: row.amountMinor });
              }
            }

            if (row.payeeName) {
              const payeeEnsureKey = payeeEnsureKeyForRow(row);
              if (!seenPayeeEnsureKeys.has(payeeEnsureKey)) {
                seenPayeeEnsureKeys.add(payeeEnsureKey);
                payeeRowsToEnsure.push(row);
              }
            }
          }

          if (missingAccounts.length) {
            setStatus("", "Ensuring " + missingAccounts.length + " missing accounts...");
            for (let i = 0; i < missingAccounts.length; i++) {
              const name = missingAccounts[i];
              try {
                await ensureAccount(name);
                createdAccounts += 1;
              } catch (err) {
                pushLog("bad", "Failed to create account '" + name + "': " + (err && err.message ? err.message : String(err)));
              }
            }
          }

          if (missingCategories.length) {
            setStatus("", "Ensuring " + missingCategories.length + " missing categories...");
            for (let i = 0; i < missingCategories.length; i++) {
              const item = missingCategories[i];
              try {
                await ensureCategory(item.name, item.qtyHint);
                createdCategories += 1;
              } catch (err) {
                pushLog("bad", "Failed to create category '" + item.name + "': " + (err && err.message ? err.message : String(err)));
              }
            }
          }

          if (payeeRowsToEnsure.length) {
            setStatus("", "Ensuring " + payeeRowsToEnsure.length + " payees...");
            let payeesProcessed = 0;
            let payeesCreatedInPhase = 0;
            let lastPayeeProgressBucket = 0;
            function maybeUpdatePayeeProgress() {
              const bucket = Math.floor(payeesProcessed / 100);
              if (bucket <= lastPayeeProgressBucket && payeesProcessed !== payeeRowsToEnsure.length) return;
              lastPayeeProgressBucket = bucket;
              setStatus("", "Ensuring payees... " + payeesProcessed + "/" + payeeRowsToEnsure.length + " processed (" + payeesCreatedInPhase + " created).");
              $("#importStats").textContent = "Payees: " + payeesProcessed + " / " + payeeRowsToEnsure.length + " processed...";
            }
            for (let i = 0; i < payeeRowsToEnsure.length; i++) {
              const row = payeeRowsToEnsure[i];
              const payeeEnsureKey = payeeEnsureKeyForRow(row);
              const candidateKeys = [keyOfName(row.payeeName)];
              const rawKey = keyOfName(row.payeeRaw);
              if (row.payeeWasSplit && rawKey && !candidateKeys.includes(rawKey)) candidateKeys.push(rawKey);
              const hadPayee = candidateKeys.some((k) => k && state.refs.payeesByName.has(k));

              try {
                const payeeRecord = await ensurePayeeForRow(row);
                if (payeeRecord && payeeRecord.id) payeeEnsureResolvedIds.set(payeeEnsureKey, payeeRecord.id);
                if (!hadPayee && payeeRecord) {
                  createdPayees += 1;
                  payeesCreatedInPhase += 1;
                }
              } catch (err) {
                if (err && err.isPayeeCardCategoryConflict) throw err;
                payeeEnsureFailedKeys.add(payeeEnsureKey);
                pushLog("bad", "Line " + row.lineNo + " payee pre-create failed: " + (err && err.message ? err.message : String(err)));
              } finally {
                payeesProcessed += 1;
                maybeUpdatePayeeProgress();
              }
            }
          }

          setStatus("", "Importing " + state.parsedRows.length + " rows...");
          $("#importStats").textContent = "Running...";
          const importGroups = [];
          for (let i = 0; i < state.parsedRows.length; i++) {
            if (consumedIndexes.has(i)) continue;
            const row = state.parsedRows[i];

            if (!isImportRowValid(row)) {
              skipped += 1;
              pushLog("warn", "Line " + row.lineNo + " skipped: missing required value (date/account/category/amount/cleared).");
              if (!loggedFirstInvalid) {
                loggedFirstInvalid = true;
                pushLog("warn", "First invalid row details: " + JSON.stringify({
                  lineNo: row.lineNo,
                  reason: invalidReason(row),
                  date: row.date,
                  account: row.account,
                  category: row.category,
                  amount: row.amountMinor,
                  status: row.status,
                  payeeRaw: row.payeeRaw,
                  payeeName: row.payeeName,
                  payeeCardCategory: row.payeeCardCategory,
                  payeeWasSplit: row.payeeWasSplit,
                  subcategory: row.subcategory,
                  memo: row.memo
                }));
              }
              processedRows += 1;
              continue;
            }

            let groupRows = [row];
            if (row.splitGroupType === "savings_shared") {
              const splitPairIndex = findSplitPairIndex(state.parsedRows, i, consumedIndexes);
              if (splitPairIndex < 0) throw new Error("Internal split-pairing failed for line " + row.lineNo + ".");
              groupRows = [row, state.parsedRows[splitPairIndex]];
              consumedIndexes.add(splitPairIndex);
            } else {
              const pairIndex = findPairedTransferIndex(state.parsedRows, i, consumedIndexes, state.parsedRowsSortedByDate);
              if (pairIndex >= 0) {
                groupRows = [row, state.parsedRows[pairIndex]];
                consumedIndexes.add(pairIndex);
              }
            }
            importGroups.push(groupRows);
          }

          let lastProgressBucket = Math.floor(processedRows / 100);
          function maybeUpdateProgress() {
            const bucket = Math.floor(processedRows / 100);
            if (bucket <= lastProgressBucket) return;
            lastProgressBucket = bucket;
            setStatus("", "Importing... " + processedRows + "/" + state.parsedRows.length + " rows processed.");
            $("#importStats").textContent = "Processed " + processedRows + " / " + state.parsedRows.length + " rows...";
          }

          await runWithConcurrency(importGroups, TXN_IMPORT_CONCURRENCY, async (groupRows) => {
            const groupAccounts = [];
            const groupCategories = [];
            try {
              for (let g = 0; g < groupRows.length; g++) {
                const groupRow = groupRows[g];
                const account = state.refs.accountsByName.get(keyOfName(groupRow.account));
                if (!account) throw new Error("Account not found after pre-create: " + groupRow.account);

                const category = state.refs.categoriesByName.get(keyOfName(groupRow.category));
                if (!category) throw new Error("Category not found after pre-create: " + groupRow.category);

                groupAccounts.push(account);
                groupCategories.push(category);
              }

              const primaryPayee = groupRows.find((r) => r.payeeName) || null;
              let payeeRecord = null;
              if (primaryPayee) {
                const payeeEnsureKey = payeeEnsureKeyForRow(primaryPayee);
                if (payeeEnsureFailedKeys.has(payeeEnsureKey)) {
                  throw new Error("Payee pre-create failed: " + primaryPayee.payeeName);
                }

                const resolvedPayeeId = payeeEnsureResolvedIds.get(payeeEnsureKey);
                if (resolvedPayeeId) {
                  payeeRecord = { id: resolvedPayeeId };
                } else {
                  const candidateKeys = [keyOfName(primaryPayee.payeeName)];
                  const rawKey = keyOfName(primaryPayee.payeeRaw);
                  if (primaryPayee.payeeWasSplit && rawKey && !candidateKeys.includes(rawKey)) candidateKeys.push(rawKey);
                  for (let p = 0; p < candidateKeys.length; p++) {
                    const found = state.refs.payeesByName.get(candidateKeys[p]);
                    if (found) {
                      payeeRecord = found;
                      break;
                    }
                  }
                  if (!payeeRecord) throw new Error("Payee not found after pre-create: " + primaryPayee.payeeName);
                }
              }

              const txnBody = {
                date: normalizeDateToNoonUtc(groupRows[0].date),
                payee: payeeRecord ? payeeRecord.id : null,
                memo: groupRows[0].memo || groupRows[1]?.memo || null,
                source: "import:csv"
              };

              if (useExternalId) {
                txnBody.external_id = groupRows.length === 2
                  ? buildPairedExternalId(fileName, groupRows[0], groupRows[1])
                  : buildExternalId(fileName, groupRows[0]);
              }

              let txn;
              try {
                txn = await createRecord("txns", txnBody);
              } catch (errTxn) {
                const hasExternalIdError = !!(errTxn && errTxn.responseData && errTxn.responseData.data && errTxn.responseData.data.external_id);
                const isDuplicate = useExternalId && errTxn && errTxn.status === 400 && (hasExternalIdError || String(errTxn.message || "").toLowerCase().includes("already exists"));
                if (isDuplicate) {
                  skipped += groupRows.length;
                  processedRows += groupRows.length;
                  pushLog("warn", "Line " + groupRows[0].lineNo + (groupRows.length === 2 ? ("/" + groupRows[1].lineNo) : "") + " skipped: external_id already exists.");
                  maybeUpdateProgress();
                  return;
                }
                throw errTxn;
              }

              try {
                for (let g = 0; g < groupRows.length; g++) {
                  const groupRow = groupRows[g];
                  const entryBody = {
                    txn: txn.id,
                    date: normalizeDateToNoonUtc(groupRow.date),
                    account: groupAccounts[g].id,
                    category: groupCategories[g].id,
                    asset: usd.id,
                    qty: groupRow.amountMinor,
                    memo: groupRow.memo || null,
                    status: groupRow.status
                  };
                  if (groupRow.subcategory) entryBody.meta = { subcategory: groupRow.subcategory };
                  await createRecord("entries", entryBody);
                }
              } catch (errEntry) {
                try {
                  await deleteRecord("txns", txn.id);
                } catch {}
                throw errEntry;
              }

              createdTxns += 1;
              createdEntries += groupRows.length;
              if (groupRows.length === 2 && groupRows.every((r) => isTransferCategory(r.category))) pairedTxns += 1;

              processedRows += groupRows.length;
              maybeUpdateProgress();
            } catch (rowErr) {
              if (rowErr && rowErr.isPayeeCardCategoryConflict) {
                pushLog("bad", "Line " + groupRows[0].lineNo + (groupRows.length === 2 ? ("/" + groupRows[1].lineNo) : "") + " failed: " + rowErr.message);
                throw rowErr;
              }
              failed += groupRows.length;
              processedRows += groupRows.length;
              pushLog("bad", "Line " + groupRows[0].lineNo + (groupRows.length === 2 ? ("/" + groupRows[1].lineNo) : "") + " failed: " + (rowErr && rowErr.message ? rowErr.message : String(rowErr)));
              maybeUpdateProgress();
            }
          });

          const elapsedSec = ((Date.now() - started) / 1000).toFixed(1);
          const summary = [
            "Import complete in " + elapsedSec + "s.",
            "Txns created: " + createdTxns,
            "Entries created: " + createdEntries,
            "Paired transfers: " + pairedTxns,
            "Accounts created: " + createdAccounts,
            "Categories created: " + createdCategories,
            "Payees created: " + createdPayees,
            "Skipped: " + skipped,
            "Failed: " + failed
          ].join(" ");

          $("#importStats").textContent = summary;
          if (failed === 0) setStatus("ok", summary);
          else setStatus("warn", summary);
        } catch (err) {
          const cls = classifyError(err);
          setStatus(cls.kind, cls.message);
          $("#importStats").textContent = "Import aborted: " + (err && err.message ? err.message : String(err));
          pushLog("bad", "Import aborted: " + (err && err.message ? err.message : String(err)));
        } finally {
          state.importing = false;
          setBusy();
        }
      }

      async function parseCurrentFile() {
        if (!state.file) {
          setStatus("warn", "Choose a CSV file first.");
          return;
        }

        const text = await state.file.text();
        await loadReferenceData();
        await ensureUsdAsset();
        const parsed = parseCsvRows(text, state.usdPrecision, state.refs.payeesByName);
        state.parsedRows = parsed.rows;
        state.parsedRowsSortedByDate = !!parsed.isSortedByDate;
        renderPreview();
        setBusy();
        const badRow = firstInvalidRow(state.parsedRows);
        if (badRow) {
          const details = {
            lineNo: badRow.lineNo,
            reason: invalidReason(badRow),
            date: badRow.date,
            account: badRow.account,
            category: badRow.category,
            amount: badRow.amountMinor,
            status: badRow.status,
            payeeRaw: badRow.payeeRaw,
            payeeName: badRow.payeeName,
            payeeCardCategory: badRow.payeeCardCategory,
            payeeWasSplit: badRow.payeeWasSplit,
            subcategory: badRow.subcategory,
            memo: badRow.memo
          };
          pushLog("warn", "First invalid row after parse: " + JSON.stringify(details));
          setStatus("warn", "CSV parsed with invalid rows. First invalid row printed in Import Log.");
        } else {
          if (parsed.hasClearedColumn) setStatus("ok", "CSV parsed. Cleared column detected. Ready to import " + state.parsedRows.length + " rows.");
          else setStatus("ok", "CSV parsed. No Cleared column found; defaulting all entry status values to cleared for " + state.parsedRows.length + " rows.");
        }
      }

      function setFile(file) {
        state.file = file || null;
        state.parsedRows = [];
        state.parsedRowsSortedByDate = false;
        $("#previewBody").innerHTML = "";
        $("#previewSummary").textContent = "No parsed rows.";
        $("#fileInfo").textContent = file ? (file.name + " (" + file.size + " bytes)") : "No file loaded.";
        setBusy();
      }

      function handleDropFiles(files) {
        if (!files || !files.length) return;
        const f = files[0];
        setFile(f);
      }

      $("#btnLogin").addEventListener("click", async () => {
        const base = $("#pbUrl").value.trim().replace(/\/+$/, "");
        const email = $("#pbEmail").value.trim();
        const password = $("#pbPass").value;

        if (!base) {
          setStatus("bad", "Login failed: enter URL.");
          return;
        }
        if (!email || !password) {
          setStatus("bad", "Login failed: enter email and password.");
          return;
        }

        store.set("pbUrl", base);
        store.set("pbEmail", email);

        try {
          $("#btnLogin").disabled = true;
          SESSION.base = base;
          SESSION.token = "";

          const res = await authWithPassword(email, password);
          if (!res || !res.token) throw new Error("No token returned by PocketBase.");

          SESSION.token = res.token;
          store.set("pbToken", SESSION.token);

          setLoggedInUI(true);
          setStatus("ok", "Login succeeded.");
        } catch (err) {
          const cls = classifyError(err);
          SESSION.token = "";
          store.del("pbToken");
          setLoggedInUI(false);
          setStatus(cls.kind, cls.message);
        } finally {
          $("#btnLogin").disabled = false;
          setBusy();
        }
      });

      $("#logoutLink").addEventListener("click", (e) => {
        e.preventDefault();
        SESSION.base = "";
        SESSION.token = "";
        store.del("pbUrl");
        store.del("pbEmail");
        store.del("pbToken");
        $("#pbUrl").value = "";
        $("#pbEmail").value = "";
        $("#pbPass").value = "";
        setFile(null);
        clearLog();
        setLoggedInUI(false);
        setStatus("", "Logged out.");
        setBusy();
      });

      $("#csvFile").addEventListener("change", (e) => {
        const f = e.target.files && e.target.files[0] ? e.target.files[0] : null;
        setFile(f);
        if (!f || !SESSION.token) return;
        parseCurrentFile().catch((err) => {
          state.parsedRows = [];
          renderPreview();
          setBusy();
          setStatus("bad", "Parse failed: " + (err && err.message ? err.message : String(err)));
        });
      });

      $("#btnClearFile").addEventListener("click", () => {
        $("#csvFile").value = "";
        setFile(null);
      });

      $("#btnPreview").addEventListener("click", async () => {
        try {
          await parseCurrentFile();
        } catch (err) {
          state.parsedRows = [];
          renderPreview();
          setBusy();
          setStatus("bad", "Parse failed: " + (err && err.message ? err.message : String(err)));
        }
      });

      $("#btnImport").addEventListener("click", importRows);

      const dz = $("#dropzone");
      dz.addEventListener("dragover", (e) => {
        e.preventDefault();
        dz.classList.add("active");
      });
      dz.addEventListener("dragleave", () => dz.classList.remove("active"));
      dz.addEventListener("drop", (e) => {
        e.preventDefault();
        dz.classList.remove("active");
        const files = e.dataTransfer ? e.dataTransfer.files : [];
        handleDropFiles(files);
        if (!files || !files.length || !SESSION.token) return;
        parseCurrentFile().catch((err) => {
          state.parsedRows = [];
          renderPreview();
          setBusy();
          setStatus("bad", "Parse failed: " + (err && err.message ? err.message : String(err)));
        });
      });

      (async function init() {
        $("#pbUrl").value = store.get("pbUrl", "");
        $("#pbEmail").value = store.get("pbEmail", "");

        SESSION.base = store.get("pbUrl", "").trim().replace(/\/+$/, "");
        SESSION.token = store.get("pbToken", "").trim();

        if (SESSION.base && SESSION.token) {
          try {
            const res = await authRefresh();
            if (res && res.token) {
              SESSION.token = res.token;
              store.set("pbToken", res.token);
            }
            setLoggedInUI(true);
            setStatus("ok", "Session restored via auth-refresh.");
          } catch {
            SESSION.token = "";
            store.del("pbToken");
            setLoggedInUI(false);
            setStatus("warn", "Saved session expired. Please log in again.");
          }
        } else {
          setLoggedInUI(false);
          setStatus("", "Not authenticated.");
        }

        setBusy();
      })();
    })();
  </script>
</body>
</html>
