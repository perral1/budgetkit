<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Admin — Accounts • Assets • Categories • Payees</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1620; --panel2:#121c29; --text:#e7edf6; --muted:#a9b7c8;
      --line:#223044; --accent:#7aa8ff; --danger:#ff6b6b; --ok:#3ddc97; --warn:#ffd166;
      --shadow: 0 12px 40px rgba(0,0,0,.35);
      --radius:14px;
      --sticky-offset:84px;
      --panel-head-height:56px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0; font-family:var(--sans); background:linear-gradient(180deg,#070a0f 0%,#0b0f14 45%,#070a0f 100%);
      color:var(--text);
    }
    a{ color:var(--accent); text-decoration:none; }
    .wrap{ max-width:1200px; margin:0 auto; padding:18px 16px 40px; }
    .topbar{
      display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;
      padding:12px 14px; border:1px solid var(--line); border-radius:var(--radius); background:rgba(15,22,32,.85);
      box-shadow:var(--shadow);
      position:sticky; top:10px; z-index:50; backdrop-filter: blur(10px);
    }
    .title{ display:flex; align-items:baseline; gap:10px; }
    .title h1{ margin:0; font-size:18px; letter-spacing:.2px; }
    .title .badge{
      font-size:12px; color:var(--muted); border:1px solid var(--line); padding:2px 8px; border-radius:999px;
      background:rgba(18,28,41,.8);
    }
    .conn{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .field{
      display:flex; flex-direction:column; gap:6px;
    }
    .field label{ font-size:12px; color:var(--muted); }
    .field label.bulkMixedLabel{ color:#94a8bf; }
    .field label.bulkLockedLabel{ color:#8393a7; }
    input[type="text"], input[type="password"], textarea, select{
      background:rgba(18,28,41,.9); color:var(--text);
      border:1px solid var(--line); border-radius:10px; padding:9px 10px; outline:none;
      min-width: 220px;
    }
    .bulkMixedControl{
      border-color:rgba(169,183,200,.5) !important;
      color:#a9b7c8 !important;
      opacity:.82;
    }
    .bulkLockedControl{
      opacity:.65;
      cursor:not-allowed;
    }
    textarea{ min-width: 300px; min-height: 90px; resize: vertical; font-family:var(--mono); font-size:12px; line-height:1.35; }
    input:focus, textarea:focus, select:focus{ border-color:rgba(122,168,255,.8); box-shadow:0 0 0 3px rgba(122,168,255,.15); }
    .btn{
      border:1px solid var(--line); background:rgba(18,28,41,.9); color:var(--text);
      padding:9px 12px; border-radius:10px; cursor:pointer; font-weight:600;
      display:inline-flex; align-items:center; gap:8px;
    }
    .btn:hover{ border-color:rgba(122,168,255,.55); }
    .btn.primary{ background:rgba(122,168,255,.18); border-color:rgba(122,168,255,.45); }
    .btn.danger{ background:rgba(255,107,107,.12); border-color:rgba(255,107,107,.35); color:#ffd6d6; }
    .btn.ghost{ background:transparent; }
    .btn:disabled{ opacity:.6; cursor:not-allowed; }
    .tabs{
      margin-top:14px;
      display:flex; gap:8px; flex-wrap:wrap;
    }
    .tab{
      padding:9px 12px; border-radius:999px; border:1px solid var(--line); background:rgba(15,22,32,.75);
      cursor:pointer; color:var(--muted); font-weight:700; letter-spacing:.2px; font-size:13px;
    }
    .tab.active{ color:var(--text); border-color:rgba(122,168,255,.55); background:rgba(122,168,255,.12); }
    .panel{
      margin-top:12px;
      border:1px solid var(--line); border-radius:var(--radius);
      background:rgba(15,22,32,.7); box-shadow:var(--shadow);
      overflow:visible;
    }
    .panelHead{
      display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;
      padding:12px 14px; border-bottom:1px solid var(--line); background:rgba(18,28,41,.6);
      position:sticky;
      top:var(--sticky-offset);
      z-index:45;
      backdrop-filter: blur(8px);
    }
    .panelHead .left{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .panelHead .right{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .panelHead .hint{ font-size:12px; color:var(--muted); }
    .searchRow{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .tableWrap{ overflow:visible; }
    table{ width:100%; border-collapse:collapse; }
    th, td{ padding:10px 12px; border-bottom:1px solid rgba(34,48,68,.75); vertical-align:top; }
    th{ text-align:left; font-size:12px; color:var(--muted); letter-spacing:.3px; text-transform:uppercase; }
    #table thead th{
      position:sticky;
      top:calc(var(--sticky-offset) + var(--panel-head-height));
      z-index:44;
      background:rgba(18,28,41,.92);
    }
    th.sortable{ cursor:pointer; user-select:none; }
    th.sortable:hover{ color:var(--text); }
    th.sorted-asc::after{ content:" \2191"; color:var(--accent); }
    th.sorted-desc::after{ content:" \2193"; color:var(--accent); }
    td{ font-size:13px; }
    tr.selectableRow{ cursor:pointer; }
    tr.selectableRow.selected{ background:rgba(122,168,255,.12); }
    tr.selectableRow:hover{ background:rgba(122,168,255,.08); }
    .selectionCell{ width:40px; text-align:center; }
    .selectionCell input{ width:16px; height:16px; }
    .mono{ font-family:var(--mono); font-size:12px; color:var(--muted); }
    .pill{
      display:inline-flex; align-items:center; gap:6px;
      border:1px solid var(--line); background:rgba(18,28,41,.7);
      padding:2px 8px; border-radius:999px; font-size:12px; color:var(--muted);
    }
    .pill.ok{ border-color:rgba(61,220,151,.35); background:rgba(61,220,151,.10); color:#bdf6df; }
    .pill.warn{ border-color:rgba(255,209,102,.35); background:rgba(255,209,102,.10); color:#ffe6b3; }
    .actions{ display:flex; gap:8px; align-items:center; }
    .actions .btn{ padding:7px 10px; font-weight:700; }
    .bulkActions{
      display:none;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .bulkActions.active{ display:flex; }
    .empty{
      padding:22px 14px; color:var(--muted);
    }
    .footNote{
      margin-top:10px; color:var(--muted); font-size:12px;
    }
    .pager{
      padding:10px 14px 14px;
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
      border-top:1px solid rgba(34,48,68,.5);
      background:rgba(18,28,41,.35);
    }
    .pager .spacer{ flex:1 1 auto; }

    /* modal */
    .modalBackdrop{
      position:fixed; inset:0; background:rgba(0,0,0,.6);
      display:none; align-items:center; justify-content:center;
      padding:18px; z-index:200;
    }
    .modalBackdrop.show{ display:flex; }
    .modal{
      width:min(820px, 100%); border:1px solid var(--line); border-radius:16px;
      background:linear-gradient(180deg, rgba(18,28,41,.95), rgba(15,22,32,.95));
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .modalHead{
      padding:14px 16px; border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      background:rgba(18,28,41,.65);
    }
    .modalHead h2{ margin:0; font-size:15px; }
    .modalBody{ padding:14px 16px; }
    .grid{
      display:grid; grid-template-columns:repeat(12,1fr); gap:12px;
    }
    .col-12{ grid-column:span 12; }
    .col-6{ grid-column:span 6; }
    .col-4{ grid-column:span 4; }
    .col-3{ grid-column:span 3; }
    .col-8{ grid-column:span 8; }
    .help{
      font-size:12px; color:var(--muted); line-height:1.35;
      border:1px dashed rgba(34,48,68,.9); border-radius:12px; padding:10px 11px;
      background:rgba(10,14,20,.35);
      white-space: pre-wrap;
    }
    .modalFoot{
      padding:12px 16px; border-top:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
      background:rgba(18,28,41,.55);
    }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .toggle{
      display:inline-flex; align-items:center; gap:8px; cursor:pointer; user-select:none;
      color:var(--muted); font-size:13px; font-weight:650;
    }
    .toggle input{ width:16px; height:16px; }
    .toastWrap{
      position:fixed; right:14px; bottom:14px; display:flex; flex-direction:column; gap:8px; z-index:400;
      width:min(420px, calc(100% - 28px));
    }
    .toast{
      border:1px solid var(--line); border-radius:14px;
      padding:10px 12px; background:rgba(15,22,32,.92); box-shadow:var(--shadow);
      display:flex; gap:10px; align-items:flex-start;
    }
    .toast b{ display:block; font-size:13px; }
    .toast p{ margin:4px 0 0; color:var(--muted); font-size:12px; line-height:1.35; }
    .dot{ width:10px; height:10px; border-radius:999px; margin-top:3px; background:var(--accent); flex:0 0 auto; }
    .dot.ok{ background:var(--ok); }
    .dot.bad{ background:var(--danger); }
    .dupTable{
      width:100%;
      border-collapse:collapse;
      font-size:12px;
    }
    .dupListWrap{
      max-height:min(58vh, 560px);
      overflow:auto;
      border:1px solid rgba(34,48,68,.6);
      border-radius:10px;
    }
    .dupTable th, .dupTable td{
      border-bottom:1px solid rgba(34,48,68,.75);
      padding:8px 10px;
      vertical-align:top;
    }
    .dupScore{
      font-weight:700;
      color:#d8e6ff;
      font-family:var(--mono);
    }

    @media (max-width: 880px){
      input[type="text"], input[type="password"], select{ min-width: 180px; }
      textarea{ min-width: 100%; }
      .col-6, .col-4, .col-3, .col-8{ grid-column:span 12; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>Manage: Accounts • Assets • Categories • Payees</h1>
        <a href="#" id="logoutLink" style="display:none; font-size:12px; color:var(--muted); margin-left:8px;">logout</a>
      </div>

      <div class="conn" id="authPanel">
        <div class="field">
          <label for="pbUrl">URL</label>
          <input id="pbUrl" type="text" placeholder="http://127.0.0.1:8090" />
        </div>

        <div class="field">
          <label for="pbEmail">Email</label>
          <input id="pbEmail" type="text" placeholder="you@example.com" />
        </div>

        <div class="field">
          <label for="pbPass">Password</label>
          <input id="pbPass" type="password" placeholder="••••••••" />
        </div>

        <button class="btn primary" id="btnLogin">Login</button>
      </div>
    </div>

    <div class="tabs" role="tablist">
      <button class="tab active" data-tab="accounts" role="tab" aria-selected="true">Accounts</button>
      <button class="tab" data-tab="assets" role="tab" aria-selected="false">Assets</button>
      <button class="tab" data-tab="categories" role="tab" aria-selected="false">Categories</button>
      <button class="tab" data-tab="payees" role="tab" aria-selected="false">Payees</button>
    </div>

    <section class="panel" id="panel">
      <div class="panelHead">
        <div class="left">
          <button class="btn primary" id="btnNew">+ New</button>
          <button class="btn" id="btnRefresh">Refresh</button>
          <div class="bulkActions" id="bulkActions"></div>
          <span class="hint" id="hint">List + CRUD for the selected collection.</span>
        </div>
        <div class="right">
          <div class="searchRow">
            <div class="field">
              <label for="q">Search</label>
              <input id="q" type="text" placeholder="name, symbol, institution..." />
            </div>
            <div class="field" id="payeeCardCategoryFilterWrap" style="display:none;">
              <label for="payeeCardCategoryFilter">Card Category</label>
              <select id="payeeCardCategoryFilter">
                <option value="">(all)</option>
              </select>
            </div>
            <div class="field" id="payeeCategoryFilterWrap" style="display:none;">
              <label for="payeeCategoryFilter">Category</label>
              <select id="payeeCategoryFilter">
                <option value="">(all)</option>
              </select>
            </div>
            <label class="toggle" title="Show archived records too (where applicable)">
              <input id="showArchived" type="checkbox" />
              Show archived
            </label>
            <label class="toggle" title="Show only archived records (where applicable)">
              <input id="onlyArchived" type="checkbox" />
              Only archived
            </label>
          </div>
        </div>
      </div>

      <div class="tableWrap">
        <table id="table" aria-label="records">
          <thead></thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="empty" id="empty" style="display:none;">
        No records found.
      </div>
      <div class="pager">
        <button class="btn" id="btnPrevPage" type="button">Prev</button>
        <button class="btn" id="btnNextPage" type="button">Next</button>
        <span class="mono" id="pageInfo">Page 1 of 1</span>
        <div class="spacer"></div>
        <label class="mono" for="perPage">Rows/page</label>
        <select id="perPage">
          <option value="25">25</option>
          <option value="50" selected>50</option>
          <option value="100">100</option>
        </select>
      </div>
    </section>

    <div class="footNote">
      Conforms to the Budget System schema: accounts, assets, categories, and payees fields and enums.
    </div>
  </div>

  <!-- modal -->
  <div class="modalBackdrop" id="modalBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modalHead">
        <h2 id="modalTitle">Edit</h2>
        <button class="btn ghost" id="btnClose">✕</button>
      </div>
      <div class="modalBody">
        <div class="grid" id="formGrid"></div>
        <div class="help" id="formHelp" style="margin-top:12px;"></div>
      </div>
      <div class="modalFoot">
        <div class="row">
          <span class="mono" id="recordMeta"></span>
        </div>
        <div class="row">
          <button class="btn" id="btnCancel">Cancel</button>
          <button class="btn primary" id="btnSave">Save</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modalBackdrop" id="dupModalBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="dupModalTitle">
      <div class="modalHead">
        <h2 id="dupModalTitle">Possible Payee Duplicates</h2>
        <button class="btn ghost" id="btnDupClose">✕</button>
      </div>
      <div class="modalBody">
        <div class="help" id="dupHelp" style="margin-bottom:12px;"></div>
        <div class="dupListWrap">
          <table class="dupTable" aria-label="possible payee duplicates">
            <thead>
              <tr>
                <th>Confidence</th>
                <th>Match</th>
                <th>Payee A</th>
                <th>Payee B</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="dupTableBody"></tbody>
          </table>
        </div>
      </div>
      <div class="modalFoot">
        <div class="row">
          <span class="mono" id="dupMeta"></span>
        </div>
        <div class="row">
          <button class="btn" id="btnDupRefresh">Recompute</button>
          <button class="btn" id="btnDupDone">Done</button>
        </div>
      </div>
    </div>
  </div>

  <div class="toastWrap" id="toastWrap" aria-live="polite" aria-relevant="additions"></div>

<script>
(function(){
  const $ = (sel, el=document) => el.querySelector(sel);
  const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));

  const store = {
    get(key, fallback=null){
      try{ const v = localStorage.getItem(key); return v===null ? fallback : v; }catch{ return fallback; }
    },
    set(key, val){
      try{ localStorage.setItem(key, val); }catch{}
    },
    del(key){ try{ localStorage.removeItem(key); }catch{} }
  };

  function toast(kind, title, message){
    const wrap = $("#toastWrap");
    const el = document.createElement("div");
    el.className = "toast";
    const dot = document.createElement("div");
    dot.className = "dot " + (kind==="ok" ? "ok" : kind==="bad" ? "bad" : "");
    const inner = document.createElement("div");
    inner.innerHTML = `<b>${escapeHtml(title)}</b><p>${escapeHtml(message||"")}</p>`;
    el.appendChild(dot);
    el.appendChild(inner);
    wrap.appendChild(el);
    setTimeout(() => { el.style.opacity = "0"; el.style.transform="translateY(6px)"; el.style.transition="all .25s ease"; }, 4200);
    setTimeout(() => { el.remove(); }, 4700);
  }

  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }

  function safeJsonParse(s){
    if (s === "" || s == null) return { ok:true, value:null };
    try{ return { ok:true, value: JSON.parse(s) }; }
    catch(e){ return { ok:false, error: e?.message || "Invalid JSON" }; }
  }

  function fmtDate(ts){
    if(!ts) return "";
    const d = new Date(ts);
    if (isNaN(d.getTime())) return String(ts);
    return d.toISOString().replace("T"," ").slice(0,19) + "Z";
  }

  let SESSION = { base: "", token: "" };

  function pbConfig(){
    return { base: SESSION.base, token: SESSION.token };
  }

  async function pbFetch(path, opts={}){
    const { base, token } = pbConfig();
    if(!base) throw new Error("PocketBase URL is required.");

    const headers = Object.assign(
      { "Content-Type":"application/json" },
      opts.headers || {}
    );
    if(token){
      // PocketBase expects: Authorization: Bearer <token>
      const t = /^Bearer\s+/i.test(token) ? token : ("Bearer " + token);
      headers["Authorization"] = t;
    }

    let res;
    try{
      res = await fetch(base + path, Object.assign({}, opts, { headers }));
    }catch(err){
      const msg = (err && err.message) ? err.message : String(err);
      // Common causes: CORS, mixed-content (https page -> http API), DNS/port unreachable
      throw new Error(`Network error (fetch failed): ${msg}. Check PocketBase URL, CORS, and http/https.`);
    }
    const text = await res.text();
    let data = null;
    try{ data = text ? JSON.parse(text) : null; }catch{ data = text; }
    if(!res.ok){
      const msg = (data && (data.message || data?.data || data?.error)) ? JSON.stringify(data) : (text || res.statusText);
      throw new Error(`HTTP ${res.status}: ${msg}`);
    }
    return data;
  }

  async function listRecords(collection, { q="", showArchived=false, onlyArchived=false, page=1, perPage=50, sort="" }={}){

    async function tryList({ includeSearch=true, includeArchivedFilter=true }){
      let filterParts = [];

      const query = (q || "").trim();
      if (includeSearch && query){
        const esc = query.replaceAll('"','\"');
        if(collection === "accounts"){
          filterParts.push(`name ~ "${esc}" || institution ~ "${esc}" || type ~ "${esc}"`);
        } else if(collection === "assets"){
          filterParts.push(`symbol ~ "${esc}" || name ~ "${esc}"`);
        } else if(collection === "categories"){
          filterParts.push(`name ~ "${esc}" || kind ~ "${esc}"`);
        } else if(collection === "payees"){
          filterParts.push(`name ~ "${esc}" || card_category ~ "${esc}"`);
        }
      }

      // archived flags are optional in many schemas; only apply when requested
      if(includeArchivedFilter && (collection === "accounts" || collection === "categories" || collection === "payees")){
        if(onlyArchived){
          filterParts.push(`is_archived = true`);
        } else if(!showArchived){
          filterParts.push(`is_archived = false`);
        }
      }

      const filter = filterParts.length ? `&filter=${encodeURIComponent(filterParts.join(" && "))}` : "";
      const sortParam = sort ? `&sort=${encodeURIComponent(sort)}` : "";
      const url = `/api/collections/${encodeURIComponent(collection)}/records?page=${page}&perPage=${perPage}${sortParam}${filter}`;
      const data = await pbFetch(url, { method:"GET" });
      return {
        items: data?.items || [],
        page: Math.max(1, Number(data?.page || page)),
        perPage: Math.max(1, Number(data?.perPage || perPage)),
        totalPages: Math.max(1, Number(data?.totalPages || 1)),
        totalItems: Math.max(0, Number(data?.totalItems || 0))
      };
    }

    try{
      return await tryList({ includeSearch:true, includeArchivedFilter:true });
    }catch(e1){
      const msg = String(e1?.message || e1);
      // A common PocketBase 400 cause: filter references fields that don't exist (e.g., is_archived)
      if(msg.startsWith("HTTP 400:")){
        try{
          const data = await tryList({ includeSearch:true, includeArchivedFilter:false });
          toast("bad", "Filter adjusted", "Your collection may not have is_archived; loaded without archived filtering.");
          return data;
        }catch(e2){
          const msg2 = String(e2?.message || e2);
          if(msg2.startsWith("HTTP 400:")){
            // last resort: no filters at all
            const data = await tryList({ includeSearch:false, includeArchivedFilter:false });
            toast("bad", "Filters disabled", "Search/filter syntax was rejected; loaded without filters. Check collection/field names.");
            return data;
          }
          throw e2;
        }
      }
      throw e1;
    }
  }

  async function createRecord(collection, body){
    return pbFetch(`/api/collections/${encodeURIComponent(collection)}/records`, {
      method:"POST",
      body: JSON.stringify(body)
    });
  }

  async function updateRecord(collection, id, body){
    return pbFetch(`/api/collections/${encodeURIComponent(collection)}/records/${encodeURIComponent(id)}`, {
      method:"PATCH",
      body: JSON.stringify(body)
    });
  }

  async function deleteRecord(collection, id){
    return pbFetch(`/api/collections/${encodeURIComponent(collection)}/records/${encodeURIComponent(id)}`, {
      method:"DELETE"
    });
  }

  async function getRecord(collection, id){
    return pbFetch(`/api/collections/${encodeURIComponent(collection)}/records/${encodeURIComponent(id)}`, {
      method:"GET"
    });
  }

  const SCHEMA = {
    accounts: {
      label: "Accounts",
      help: [
        "Schema: name (required), type (required), institution (optional), is_archived (bool), meta (json).",
        "Type enum: bank | credit | cash | virtual | roth | pretax | hsa | brokerage.",
        "Note: Budget modules typically exclude accounts.type = virtual (per schema)."
      ].join("\n"),
      fields: [
        { key:"name", label:"Name", type:"text", required:true, placeholder:"Checking" },
        { key:"type", label:"Type", type:"select", required:true, options:["bank","credit","cash","virtual","roth","pretax","hsa","brokerage"] },
        { key:"institution", label:"Institution", type:"text", required:false, placeholder:"Chase" },
        { key:"is_archived", label:"Archived", type:"bool", required:false },
        { key:"meta", label:"Meta (JSON)", type:"json", required:false, placeholder:'{"color":"#7aa8ff"}' }
      ],
      columns: [
        { key:"name", label:"Name" },
        { key:"type", label:"Type", pill:true },
        { key:"institution", label:"Institution" },
        { key:"entry_count", label:"Entries", render:"accountEntryCount", mono:true },
        { key:"balance_current", label:"Current", render:"accountCurrentBalance", mono:true },
        { key:"balance_cleared", label:"Cleared", render:"accountClearedBalance", mono:true },
        { key:"is_archived", label:"Archived", pillBool:true }
      ]
    },
    assets: {
      label: "Assets",
      help: [
        "Schema: symbol (required, unique), name (optional), precision (number, optional), meta (json).",
        "Examples: USD, AAPL, BTC."
      ].join("\n"),
      fields: [
        { key:"symbol", label:"Symbol", type:"text", required:true, placeholder:"USD", transform:"upper" },
        { key:"name", label:"Name", type:"text", required:false, placeholder:"US Dollar" },
        { key:"precision", label:"Precision", type:"number", required:false, placeholder:"2" },
        { key:"meta", label:"Meta (JSON)", type:"json", required:false, placeholder:'{"assetClass":"currency"}' }
      ],
      columns: [
        { key:"symbol", label:"Symbol", pill:true },
        { key:"name", label:"Name" },
        { key:"precision", label:"Precision" },
        { key:"entry_count", label:"Entries", render:"assetEntryCount", mono:true }
      ]
    },
    categories: {
      label: "Categories",
      help: [
        "Schema: name (required), parent (optional relation → categories), kind (required), is_archived (bool), meta (json).",
        "Kind enum: income, expense, transfer, trade_cash, trade_asset, fee, payroll, withholding, benefit, employer_contrib, info, other."
      ].join("\n"),
      fields: [
        { key:"name", label:"Name", type:"text", required:true, placeholder:"Groceries" },
        { key:"kind", label:"Kind", type:"select", required:true, options:[
          "income","expense","transfer","trade_cash","trade_asset","fee","payroll","withholding","benefit","employer_contrib","info","other"
        ]},
        { key:"parent", label:"Parent Category", type:"relation", required:false, relation:"categories", placeholder:"(optional)" },
        { key:"is_archived", label:"Archived", type:"bool", required:false },
        { key:"meta", label:"Meta (JSON)", type:"json", required:false, placeholder:'{"group":"Living"}' }
      ],
      columns: [
        { key:"name", label:"Name" },
        { key:"kind", label:"Kind", pill:true },
        { key:"parent", label:"Parent", render:"parentName" },
        { key:"entry_count", label:"Entries", render:"categoryEntryCount", mono:true },
        { key:"is_archived", label:"Archived", pillBool:true }
      ]
    },
    payees: {
      label: "Payees",
      help: [
        "Schema: name (required, unique), card_category (optional), is_archived (bool).",
        "Card category enum: restaurant, intlrest, grocery, airlines, hotel, rental, parking, toll, taxi."
      ].join("\n"),
      fields: [
        { key:"name", label:"Name", type:"text", required:true, placeholder:"Jersey Mike" },
        { key:"card_category", label:"Card Category", type:"select", required:false, options:[
          "restaurant","intlrest","grocery","airlines","hotel","rental","parking","toll","taxi"
        ]},
        { key:"is_archived", label:"Archived", type:"bool", required:false }
      ],
      columns: [
        { key:"name", label:"Name" },
        { key:"card_category", label:"Card Category", pill:true },
        { key:"txn_count", label:"Txns", render:"payeeTxnCount", mono:true },
        { key:"newest_txn_date", label:"Newest Txn", render:"payeeNewestTxnDate", mono:true },
        { key:"is_archived", label:"Archived", pillBool:true }
      ]
    }
  };

  let activeTab = "accounts";
  let records = [];
  let categoriesIndex = new Map();
  let accountStats = new Map();
  let assetEntryCounts = new Map();
  let categoryEntryCounts = new Map();
  let payeeTxnCounts = new Map();
  let payeeNewestTxnDates = new Map();
  let payeeIdsByCategory = new Map();
  let duplicateCandidates = [];
  let duplicatePayeeById = new Map();
  let editing = { mode:"new", id:null, ids:[], data:null, mixedKeys:new Set(), lockedKeys:new Set() };
  const BULK_LOCKED_FIELDS = {
    accounts: new Set(["name"]),
    assets: new Set(["symbol"]),
    categories: new Set(["name"]),
    payees: new Set(["name"])
  };
  const tableSort = {
    accounts: { key: "name", direction: "asc" },
    assets: { key: "symbol", direction: "asc" },
    categories: { key: "name", direction: "asc" },
    payees: { key: "name", direction: "asc" }
  };
  const tablePaging = {
    accounts: { page: 1, perPage: 50, totalPages: 1, totalItems: 0 },
    assets: { page: 1, perPage: 50, totalPages: 1, totalItems: 0 },
    categories: { page: 1, perPage: 50, totalPages: 1, totalItems: 0 },
    payees: { page: 1, perPage: 50, totalPages: 1, totalItems: 0 }
  };
  const selectedRowIds = {
    accounts: new Set(),
    assets: new Set(),
    categories: new Set(),
    payees: new Set()
  };

  function fmtBalance(n){
    const num = Number(n || 0);
    if(!Number.isFinite(num)) return "0";
    return num.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 8 });
  }

  function normalizePrecision(raw){
    const n = Number(raw);
    if(Number.isInteger(n) && n >= 0 && n <= 9) return n;
    return 2;
  }

  function minorToMajor(minor, precision){
    const n = Number(minor || 0);
    if(!Number.isFinite(n) || !Number.isSafeInteger(n)) return 0;
    return n / (10 ** precision);
  }

  function parseTxnDate(raw){
    const v = String(raw || "").trim();
    if(!v) return null;
    let d;
    if(/^\d{4}-\d{2}-\d{2}$/.test(v)){
      d = new Date(v + "T00:00:00Z");
    }else{
      d = new Date(v);
    }
    if(!Number.isFinite(d.getTime())) return null;
    return d;
  }

  function fmtTxnDate(raw){
    const d = parseTxnDate(raw);
    if(!d) return String(raw || "");
    return d.toISOString().slice(0,10);
  }

  function normalizePayeeName(raw){
    const suffixes = new Set(["inc","llc","co","corp","corporation","company","ltd","plc","the"]);
    const cleaned = String(raw || "")
      .toLowerCase()
      .replaceAll("&", " and ")
      .replace(/[^a-z0-9\s]/g, " ")
      .replace(/\s+/g, " ")
      .trim();
    if(!cleaned) return "";
    const parts = cleaned.split(" ").filter(Boolean).filter((p) => !suffixes.has(p));
    return parts.join(" ").trim();
  }

  function diceCoefficient(a, b){
    const s1 = String(a || "");
    const s2 = String(b || "");
    if(!s1 || !s2) return 0;
    if(s1 === s2) return 1;
    if(s1.length < 2 || s2.length < 2) return 0;
    const grams = (s) => {
      const m = new Map();
      for(let i = 0; i < s.length - 1; i += 1){
        const g = s.slice(i, i + 2);
        m.set(g, (m.get(g) || 0) + 1);
      }
      return m;
    };
    const g1 = grams(s1);
    const g2 = grams(s2);
    let overlap = 0;
    g1.forEach((count, gram) => {
      overlap += Math.min(count, g2.get(gram) || 0);
    });
    return (2 * overlap) / ((s1.length - 1) + (s2.length - 1));
  }

  function buildPayeeDuplicateCandidates(payees){
    const out = [];
    const seenPairs = new Set();
    const normalizedRows = (payees || []).map((p) => ({
      id: String(p?.id || ""),
      name: String(p?.name || ""),
      card: String(p?.card_category || ""),
      normalized: normalizePayeeName(p?.name || "")
    })).filter((r) => r.id && r.name);

    const byNormalized = new Map();
    normalizedRows.forEach((r) => {
      if(!r.normalized) return;
      const arr = byNormalized.get(r.normalized) || [];
      arr.push(r);
      byNormalized.set(r.normalized, arr);
    });

    byNormalized.forEach((arr, norm) => {
      if(arr.length < 2) return;
      for(let i = 0; i < arr.length; i += 1){
        for(let j = i + 1; j < arr.length; j += 1){
          const a = arr[i];
          const b = arr[j];
          const k = a.id < b.id ? `${a.id}|${b.id}` : `${b.id}|${a.id}`;
          seenPairs.add(k);
          out.push({
            idA: a.id,
            idB: b.id,
            confidence: 1,
            reason: `exact normalized match: "${norm}"`
          });
        }
      }
    });

    for(let i = 0; i < normalizedRows.length; i += 1){
      for(let j = i + 1; j < normalizedRows.length; j += 1){
        const a = normalizedRows[i];
        const b = normalizedRows[j];
        const k = a.id < b.id ? `${a.id}|${b.id}` : `${b.id}|${a.id}`;
        if(seenPairs.has(k)) continue;
        const scoreBase = diceCoefficient(a.normalized, b.normalized);
        let score = scoreBase;
        if(a.card && b.card && a.card === b.card) score += 0.04;
        score = Math.min(0.99, score);
        if(score < 0.88) continue;
        out.push({
          idA: a.id,
          idB: b.id,
          confidence: score,
          reason: "fuzzy normalized name"
        });
      }
    }

    out.sort((x, y) => {
      if(y.confidence !== x.confidence) return y.confidence - x.confidence;
      return (x.reason || "").localeCompare(y.reason || "", undefined, { sensitivity:"base" });
    });
    return out;
  }

  function pickDuplicateMergeTarget(a, b){
    const countA = Number(payeeTxnCounts.get(String(a?.id || "")) || 0);
    const countB = Number(payeeTxnCounts.get(String(b?.id || "")) || 0);
    if(countA !== countB) return countA > countB ? a : b;
    const dateA = parseTxnDate(payeeNewestTxnDates.get(String(a?.id || "")) || "");
    const dateB = parseTxnDate(payeeNewestTxnDates.get(String(b?.id || "")) || "");
    const tsA = dateA ? dateA.getTime() : 0;
    const tsB = dateB ? dateB.getTime() : 0;
    if(tsA !== tsB) return tsA > tsB ? a : b;
    return String(a?.name || "").localeCompare(String(b?.name || ""), undefined, { sensitivity:"base" }) <= 0 ? a : b;
  }

  async function listAllEntriesForStats(){
    const perPage = 500;
    let page = 1;
    let all = [];

    while(true){
      const data = await pbFetch(`/api/collections/${encodeURIComponent("entries")}/records?page=${page}&perPage=${perPage}`, { method:"GET" });
      const items = data?.items || [];
      all = all.concat(items);
      const totalPages = Number(data?.totalPages || 1);
      if(page >= totalPages) break;
      page += 1;
    }

    return all;
  }

  async function listAllAssetsForStats(){
    const perPage = 500;
    let page = 1;
    let all = [];

    while(true){
      const data = await pbFetch(`/api/collections/${encodeURIComponent("assets")}/records?page=${page}&perPage=${perPage}`, { method:"GET" });
      const items = data?.items || [];
      all = all.concat(items);
      const totalPages = Number(data?.totalPages || 1);
      if(page >= totalPages) break;
      page += 1;
    }

    return all;
  }

  async function listAllTxnsForStats(){
    const perPage = 500;
    let page = 1;
    let all = [];

    while(true){
      const data = await pbFetch(`/api/collections/${encodeURIComponent("txns")}/records?page=${page}&perPage=${perPage}`, { method:"GET" });
      const items = data?.items || [];
      all = all.concat(items);
      const totalPages = Number(data?.totalPages || 1);
      if(page >= totalPages) break;
      page += 1;
    }

    return all;
  }

  async function computeEntryStats(){
    const accountMap = new Map();
    const assetMap = new Map();
    const categoryMap = new Map();
    const payeeMap = new Map();
    const payeeNewestTxnDateMap = new Map();
    const payeeIdsByCategoryMap = new Map();
    const [entries, assets, txns] = await Promise.all([listAllEntriesForStats(), listAllAssetsForStats(), listAllTxnsForStats()]);
    const precisionByAssetId = new Map(assets.map(a => [String(a?.id || ""), normalizePrecision(a?.precision)]));
    const payeeByTxnId = new Map();

    txns.forEach((t) => {
      const txnId = String(t?.id || "");
      const payeeId = String(t?.payee || "");
      const txnDateRaw = String(t?.date || "");
      if(txnId && payeeId) payeeByTxnId.set(txnId, payeeId);
      if(!payeeId) return;
      payeeMap.set(payeeId, (payeeMap.get(payeeId) || 0) + 1);
      if(txnDateRaw){
        const nextD = parseTxnDate(txnDateRaw);
        if(nextD){
          const prevRaw = payeeNewestTxnDateMap.get(payeeId) || "";
          const prevD = parseTxnDate(prevRaw);
          if(!prevD || nextD.getTime() > prevD.getTime()){
            payeeNewestTxnDateMap.set(payeeId, txnDateRaw);
          }
        }
      }
    });

    entries.forEach(e => {
      const accountId = e?.account;
      const assetId = e?.asset;
      const categoryId = e?.category;
      const txnId = String(e?.txn || "");
      if(accountId){
        const qtyMinor = Number(e?.qty || 0);
        if(Number.isFinite(qtyMinor) && Number.isSafeInteger(qtyMinor)){
          const precision = precisionByAssetId.get(String(assetId || "")) ?? 2;
          const qty = minorToMajor(qtyMinor, precision);
          const status = String(e?.status || "").toLowerCase();
          const row = accountMap.get(accountId) || { current: 0, cleared: 0, entryCount: 0 };
          row.entryCount += 1;
          if(status === "cleared" || status === "pending"){
            row.current += qty;
          }
          if(status === "cleared"){
            row.cleared += qty;
          }
          accountMap.set(accountId, row);
        }
      }
      if(assetId){
        assetMap.set(assetId, (assetMap.get(assetId) || 0) + 1);
      }
      if(categoryId){
        categoryMap.set(categoryId, (categoryMap.get(categoryId) || 0) + 1);
      }
      const catId = String(categoryId || "");
      const payeeId = payeeByTxnId.get(txnId) || "";
      if(catId && payeeId){
        let payees = payeeIdsByCategoryMap.get(catId);
        if(!payees){
          payees = new Set();
          payeeIdsByCategoryMap.set(catId, payees);
        }
        payees.add(payeeId);
      }
    });

    return { accountMap, assetMap, categoryMap, payeeMap, payeeNewestTxnDateMap, payeeIdsByCategoryMap };
  }

  function entriesCountForRecord(tab, record){
    if(tab === "accounts") return (accountStats.get(record.id)?.entryCount || 0);
    if(tab === "assets") return (assetEntryCounts.get(record.id) || 0);
    if(tab === "categories") return (categoryEntryCounts.get(record.id) || 0);
    if(tab === "payees") return (payeeTxnCounts.get(record.id) || 0);
    return 0;
  }

  function canDeleteFromRow(tab, record){
    return !!record?.is_archived && entriesCountForRecord(tab, record) === 0;
  }

  function compareSortValues(a, b, direction){
    const dir = direction === "asc" ? 1 : -1;
    const aNum = typeof a === "number" ? a : NaN;
    const bNum = typeof b === "number" ? b : NaN;
    if(Number.isFinite(aNum) && Number.isFinite(bNum)){
      if(aNum < bNum) return -1 * dir;
      if(aNum > bNum) return 1 * dir;
      return 0;
    }

    const aStr = String(a == null ? "" : a).toLocaleLowerCase();
    const bStr = String(b == null ? "" : b).toLocaleLowerCase();
    return aStr.localeCompare(bStr, undefined, { sensitivity:"base", numeric:true }) * dir;
  }

  function tableSortStateForTab(tab){
    if(!tableSort[tab]) tableSort[tab] = { key:"id", direction:"asc" };
    return tableSort[tab];
  }

  function tablePagingStateForTab(tab){
    if(!tablePaging[tab]) tablePaging[tab] = { page: 1, perPage: 50, totalPages: 1, totalItems: 0 };
    return tablePaging[tab];
  }

  function isServerSortableColumn(column){
    if(!column) return false;
    if(column.render === "accountCurrentBalance") return false;
    if(column.render === "accountClearedBalance") return false;
    if(column.render === "accountEntryCount") return false;
    if(column.render === "assetEntryCount") return false;
    if(column.render === "categoryEntryCount") return false;
    if(column.render === "payeeTxnCount") return false;
    if(column.render === "payeeNewestTxnDate") return false;
    return true;
  }

  function selectedSetForTab(tab){
    if(!selectedRowIds[tab]) selectedRowIds[tab] = new Set();
    return selectedRowIds[tab];
  }

  function selectedRowsForActiveTab(){
    const selected = selectedSetForTab(activeTab);
    return records.filter(r => selected.has(String(r.id || "")));
  }

  function normalizeFieldValueForCompare(field, value){
    if(field.type === "bool") return !!value ? "1" : "0";
    if(field.type === "number"){
      if(value == null || value === "") return "";
      const n = Number(value);
      return Number.isFinite(n) ? String(n) : "";
    }
    if(field.type === "json"){
      if(value == null || value === "") return "null";
      try{ return JSON.stringify(value); }catch{ return String(value); }
    }
    return String(value ?? "");
  }

  function readRawFieldValue(field, row){
    if(field.type === "bool") return !!row?.[field.key];
    if(field.type === "number"){
      const v = row?.[field.key];
      if(v == null || v === "") return "";
      const n = Number(v);
      return Number.isFinite(n) ? n : "";
    }
    if(field.type === "json") return row?.[field.key] ?? null;
    return row?.[field.key] ?? "";
  }

  function computeBulkFieldState(schema, rows){
    const mixedKeys = new Set();
    const data = {};
    (schema.fields || []).forEach((field) => {
      if(!rows.length){
        data[field.key] = (field.type === "bool") ? false : "";
        return;
      }
      const firstRaw = readRawFieldValue(field, rows[0]);
      const firstToken = normalizeFieldValueForCompare(field, firstRaw);
      let mixed = false;
      for(let i = 1; i < rows.length; i += 1){
        const nextRaw = readRawFieldValue(field, rows[i]);
        const nextToken = normalizeFieldValueForCompare(field, nextRaw);
        if(nextToken !== firstToken){
          mixed = true;
          break;
        }
      }
      if(mixed){
        mixedKeys.add(field.key);
        data[field.key] = (field.type === "bool") ? false : "";
      }else{
        data[field.key] = firstRaw;
      }
    });
    return { data, mixedKeys };
  }

  function openBulkEditor(rows){
    const schema = SCHEMA[activeTab];
    const { data, mixedKeys } = computeBulkFieldState(schema, rows);
    editing.mode = "bulk";
    editing.id = null;
    editing.ids = rows.map((r) => String(r.id || "")).filter(Boolean);
    editing.data = data;
    editing.mixedKeys = mixedKeys;
    editing.lockedKeys = BULK_LOCKED_FIELDS[activeTab] ? new Set(BULK_LOCKED_FIELDS[activeTab]) : new Set();

    $("#modalTitle").textContent = `Bulk edit ${schema.label} (${editing.ids.length} selected)`;
    $("#recordMeta").textContent = `${editing.ids.length} selected`;

    const grid = $("#formGrid");
    grid.innerHTML = "";
    schema.fields.forEach((f) => {
      grid.appendChild(buildField(f, editing.data, {
        bulkMixed: editing.mixedKeys.has(f.key),
        bulkLocked: editing.lockedKeys.has(f.key)
      }));
    });

    const baseHelp = schema.help || "";
    const extra = [
      "Bulk edit rules:",
      "- Fields showing (multiple) are not changed unless you set a value.",
      "- Locked fields are disabled for safety (unique identifiers)."
    ].join("\n");
    $("#formHelp").textContent = baseHelp ? (baseHelp + "\n\n" + extra) : extra;

    showModal(true);
  }

  function hasArchiveFlag(tab){
    return tab === "accounts" || tab === "categories" || tab === "payees";
  }

  function pruneSelectionToVisibleRows(){
    const selected = selectedSetForTab(activeTab);
    const visible = new Set(records.map(r => String(r.id || "")));
    Array.from(selected).forEach(id => {
      if(!visible.has(id)) selected.delete(id);
    });
  }

  async function applyArchiveSelection(nextArchived){
    const schema = SCHEMA[activeTab];
    const selectedRows = selectedRowsForActiveTab();
    const targets = selectedRows.filter(r => !!r.is_archived !== !!nextArchived);
    if(!targets.length){
      toast("ok", "No changes", nextArchived ? "Selected rows are already archived." : "No selected archived rows to unarchive.");
      return;
    }
    let done = 0;
    for(const row of targets){
      await updateRecord(activeTab, row.id, { is_archived: !!nextArchived });
      done += 1;
    }
    toast("ok", "Updated", `${done} ${schema.label.toLowerCase()} ${nextArchived ? "archived" : "unarchived"}.`);
    refresh();
  }

  async function deleteSelectedRows(){
    const schema = SCHEMA[activeTab];
    const selectedRows = selectedRowsForActiveTab();
    if(!selectedRows.length){
      toast("bad", "Nothing selected", "Select one or more rows first.");
      return;
    }
    if(!selectedRows.every(r => canDeleteFromRow(activeTab, r))){
      toast("bad", "Delete blocked", "Delete is only available when all selected rows are deletable.");
      return;
    }
    let done = 0;
    for(const row of selectedRows){
      await deleteRecord(activeTab, row.id);
      done += 1;
    }
    toast("ok", "Deleted", `${done} ${schema.label.toLowerCase()} deleted.`);
    refresh();
  }

  async function mergeSelectedPayees(){
    if(activeTab !== "payees"){
      toast("bad", "Merge unavailable", "Merge is only available for payees.");
      return;
    }
    const selectedRows = selectedRowsForActiveTab();
    if(selectedRows.length < 2){
      toast("bad", "Select payees", "Select at least two payees to merge.");
      return;
    }

    const [target, ...sources] = selectedRows;
    const sourceIds = new Set(sources.map(r => String(r.id || "")).filter(Boolean));
    if(!sourceIds.size){
      toast("bad", "Merge unavailable", "No merge sources found.");
      return;
    }

    const targetLabel = target.name || target.id;
    const confirmMsg = `Merge ${selectedRows.length} payees into "${targetLabel}"? Transactions from ${sources.length} selected payee(s) will be moved, then the other selected payees will be deleted.`;
    if(!window.confirm(confirmMsg)) return;

    const { moved, moveFailed, deleted, deleteFailed, firstError, adoptedCategory } = await mergePayeesByIds(target.id, sourceIds, { adoptCardCategory: true });

    if(moveFailed || deleteFailed){
      toast(
        "bad",
        "Merge completed with errors",
        `Moved ${moved} txn(s), failed ${moveFailed}. Deleted ${deleted} payee(s), failed ${deleteFailed}.` + (adoptedCategory ? ` Card category set to ${adoptedCategory}.` : "") + (firstError ? ` First error: ${firstError}` : "")
      );
    }else{
      toast("ok", "Merge complete", `Moved ${moved} txn(s) to "${targetLabel}" and deleted ${deleted} payee(s).` + (adoptedCategory ? ` Card category set to ${adoptedCategory}.` : ""));
    }
    await refresh();

    let mergedPayee = records.find((r) => String(r?.id || "") === String(target.id || ""));
    if(!mergedPayee){
      try{
        mergedPayee = await getRecord("payees", target.id);
      }catch{}
    }
    if(mergedPayee){
      openEditor("edit", mergedPayee);
    }
  }

  async function cleanupPayees(){
    if(activeTab !== "payees"){
      toast("bad", "Cleanup unavailable", "Cleanup is only available on payees.");
      return;
    }
    if(!window.confirm("Cleanup payees? This will delete payees with 0 linked txns and archive payees whose newest txn is over 1 year old.")) return;

    const allPayees = await listAllRecords("payees", { q:"", showArchived:true, onlyArchived:false, perPage:500, sort:"name" });
    const stats = await computeEntryStats();
    const txnCounts = stats.payeeMap || new Map();
    const newestByPayee = stats.payeeNewestTxnDateMap || new Map();
    const cutoff = new Date();
    cutoff.setUTCFullYear(cutoff.getUTCFullYear() - 1);

    let deleted = 0;
    let archived = 0;
    let deleteFailed = 0;
    let archiveFailed = 0;
    let firstError = "";

    for(const p of allPayees){
      const payeeId = String(p?.id || "");
      if(!payeeId) continue;
      const txnCount = Number(txnCounts.get(payeeId) || 0);
      if(txnCount <= 0){
        try{
          await deleteRecord("payees", payeeId);
          deleted += 1;
        }catch(e){
          deleteFailed += 1;
          if(!firstError) firstError = e?.message || String(e);
        }
        continue;
      }

      const newestRaw = String(newestByPayee.get(payeeId) || "");
      const newestDate = parseTxnDate(newestRaw);
      if(!newestDate) continue;
      if(newestDate.getTime() < cutoff.getTime() && !p?.is_archived){
        try{
          await updateRecord("payees", payeeId, { is_archived: true });
          archived += 1;
        }catch(e){
          archiveFailed += 1;
          if(!firstError) firstError = e?.message || String(e);
        }
      }
    }

    if(deleteFailed || archiveFailed){
      toast("bad", "Cleanup partial", `Deleted ${deleted}, archived ${archived}, delete failed ${deleteFailed}, archive failed ${archiveFailed}.` + (firstError ? ` First error: ${firstError}` : ""));
    }else{
      toast("ok", "Cleanup complete", `Deleted ${deleted} payee(s). Archived ${archived} payee(s).`);
    }
    refresh();
  }

  async function mergePayeesByIds(targetId, sourceIds, opts={}){
    const targetIdStr = String(targetId || "");
    const sourceIdList = Array.from(sourceIds || [])
      .map((id) => String(id || ""))
      .filter((id) => !!id && id !== targetIdStr);
    if(!targetIdStr || !sourceIdList.length){
      throw new Error("Missing merge target/source.");
    }
    const sourceIdSet = new Set(sourceIdList);
    const adoptCardCategory = opts.adoptCardCategory !== false;

    let adoptedCategory = "";
    if(adoptCardCategory){
      let target = records.find((r) => String(r?.id || "") === targetIdStr);
      if(!target){
        try{ target = await getRecord("payees", targetIdStr); }catch{}
      }
      const targetCategory = String(target?.card_category || "").trim();
      if(!targetCategory){
        let sourceCategory = "";
        for(const sid of sourceIdList){
          let src = records.find((r) => String(r?.id || "") === sid);
          if(!src){
            try{ src = await getRecord("payees", sid); }catch{}
          }
          const cat = String(src?.card_category || "").trim();
          if(cat){
            sourceCategory = cat;
            break;
          }
        }
        if(sourceCategory){
          await updateRecord("payees", targetIdStr, { card_category: sourceCategory });
          adoptedCategory = sourceCategory;
        }
      }
    }

    let moved = 0;
    let moveFailed = 0;
    let deleted = 0;
    let deleteFailed = 0;
    let firstError = "";
    const allTxns = await listAllTxnsForStats();
    const txnsToMove = allTxns.filter((t) => sourceIdSet.has(String(t?.payee || "")));

    for(const txn of txnsToMove){
      try{
        await updateRecord("txns", txn.id, { payee: targetIdStr });
        moved += 1;
      }catch(e){
        moveFailed += 1;
        if(!firstError) firstError = e?.message || String(e);
      }
    }

    for(const sid of sourceIdList){
      try{
        await deleteRecord("payees", sid);
        deleted += 1;
      }catch(e){
        deleteFailed += 1;
        if(!firstError) firstError = e?.message || String(e);
      }
    }

    return { moved, moveFailed, deleted, deleteFailed, firstError, adoptedCategory };
  }

  function showDupModal(on){
    $("#dupModalBackdrop").classList.toggle("show", !!on);
    $("#dupModalBackdrop").setAttribute("aria-hidden", String(!on));
  }

  function renderDuplicateCandidates(){
    const tbody = $("#dupTableBody");
    if(!tbody) return;
    tbody.innerHTML = "";
    $("#dupMeta").textContent = `${duplicateCandidates.length} candidate pair(s)`;
    $("#dupHelp").textContent = "Confidence 1.00 means exact normalized-name match. Lower scores are fuzzy matches and should be reviewed manually.";

    if(!duplicateCandidates.length){
      const tr = document.createElement("tr");
      const td = document.createElement("td");
      td.colSpan = 5;
      td.className = "mono";
      td.textContent = "No duplicate candidates found.";
      tr.appendChild(td);
      tbody.appendChild(tr);
      return;
    }

    duplicateCandidates.forEach((cand) => {
      const a = duplicatePayeeById.get(String(cand.idA || ""));
      const b = duplicatePayeeById.get(String(cand.idB || ""));
      if(!a || !b) return;
      const target = pickDuplicateMergeTarget(a, b);
      const source = String(target.id || "") === String(a.id || "") ? b : a;
      const countA = Number(payeeTxnCounts.get(String(a.id || "")) || 0);
      const countB = Number(payeeTxnCounts.get(String(b.id || "")) || 0);
      const newestA = fmtTxnDate(payeeNewestTxnDates.get(String(a.id || "")) || "");
      const newestB = fmtTxnDate(payeeNewestTxnDates.get(String(b.id || "")) || "");
      const cardA = String(a?.card_category || "").trim() || "(none)";
      const cardB = String(b?.card_category || "").trim() || "(none)";

      const tr = document.createElement("tr");

      const tdScore = document.createElement("td");
      tdScore.innerHTML = `<span class="dupScore">${Number(cand.confidence || 0).toFixed(2)}</span>`;
      tr.appendChild(tdScore);

      const tdReason = document.createElement("td");
      tdReason.textContent = cand.reason || "";
      tr.appendChild(tdReason);

      const tdA = document.createElement("td");
      tdA.innerHTML = `${escapeHtml(a.name || a.id)}<br><span class="mono">card=${escapeHtml(cardA)} txns=${countA} newest=${escapeHtml(newestA || "-")}</span>`;
      tr.appendChild(tdA);

      const tdB = document.createElement("td");
      tdB.innerHTML = `${escapeHtml(b.name || b.id)}<br><span class="mono">card=${escapeHtml(cardB)} txns=${countB} newest=${escapeHtml(newestB || "-")}</span>`;
      tr.appendChild(tdB);

      const tdAction = document.createElement("td");
      const btnMerge = document.createElement("button");
      btnMerge.className = "btn";
      btnMerge.textContent = `Merge into ${target.name || target.id}`;
      btnMerge.addEventListener("click", async () => {
        const msg = `Merge "${source.name || source.id}" into "${target.name || target.id}"?\nThis will move linked txns and then delete "${source.name || source.id}".`;
        if(!window.confirm(msg)) return;
        try{
          const res = await mergePayeesByIds(target.id, [source.id], { adoptCardCategory: true });
          if(res.moveFailed || res.deleteFailed){
            toast("bad", "Merge partial", `Moved ${res.moved}, failed ${res.moveFailed}. Deleted ${res.deleted}, failed ${res.deleteFailed}.` + (res.adoptedCategory ? ` Card category set to ${res.adoptedCategory}.` : "") + (res.firstError ? ` First error: ${res.firstError}` : ""));
          }else{
            toast("ok", "Merged", `"${source.name || source.id}" merged into "${target.name || target.id}".` + (res.adoptedCategory ? ` Card category set to ${res.adoptedCategory}.` : ""));
          }
          await refresh();
          showDupModal(false);
          let mergedPayee = records.find((r) => String(r?.id || "") === String(target.id || ""));
          if(!mergedPayee){
            try{
              mergedPayee = await getRecord("payees", target.id);
            }catch{}
          }
          if(mergedPayee) openEditor("edit", mergedPayee);
        }catch(e){
          toast("bad", "Merge failed", e?.message || String(e));
        }
      });
      tdAction.appendChild(btnMerge);
      tr.appendChild(tdAction);

      tbody.appendChild(tr);
    });
  }

  async function runPayeeDuplicateDetection(openModal){
    const allPayees = await listAllRecords("payees", { q:"", showArchived:true, onlyArchived:false, perPage:500, sort:"name" });
    duplicatePayeeById = new Map(allPayees.map((p) => [String(p?.id || ""), p]));
    duplicateCandidates = buildPayeeDuplicateCandidates(allPayees.filter((p) => String(p?.name || "").trim()));
    renderDuplicateCandidates();
    if(openModal) showDupModal(true);
  }

  function renderBulkActions(){
    const wrap = $("#bulkActions");
    if(!wrap) return;
    wrap.innerHTML = "";
    const selected = selectedRowsForActiveTab();
    if(!selected.length){
      if(activeTab === "payees"){
        const btnCleanup = document.createElement("button");
        btnCleanup.className = "btn";
        btnCleanup.textContent = "Cleanup";
        btnCleanup.addEventListener("click", async () => {
          try{
            await cleanupPayees();
          }catch(e){
            toast("bad", "Cleanup failed", e.message || String(e));
          }
        });
        wrap.appendChild(btnCleanup);

        const btnDupes = document.createElement("button");
        btnDupes.className = "btn";
        btnDupes.textContent = "Find duplicates";
        btnDupes.addEventListener("click", async () => {
          try{
            await runPayeeDuplicateDetection(true);
          }catch(e){
            toast("bad", "Duplicate scan failed", e?.message || String(e));
          }
        });
        wrap.appendChild(btnDupes);
        wrap.classList.add("active");
      }else{
        wrap.classList.remove("active");
      }
      syncStickyOffsets();
      return;
    }

    const selectedCount = document.createElement("span");
    selectedCount.className = "mono";
    selectedCount.textContent = `${selected.length} selected`;
    wrap.appendChild(selectedCount);

    if(selected.length === 1){
      const btnEdit = document.createElement("button");
      btnEdit.className = "btn";
      btnEdit.textContent = "Edit";
      btnEdit.addEventListener("click", () => openEditor("edit", selected[0]));
      wrap.appendChild(btnEdit);
    }else if(selected.length > 1){
      const btnBulkEdit = document.createElement("button");
      btnBulkEdit.className = "btn";
      btnBulkEdit.textContent = "Bulk edit";
      btnBulkEdit.addEventListener("click", () => openBulkEditor(selected));
      wrap.appendChild(btnBulkEdit);
    }

    if(hasArchiveFlag(activeTab)){
      const btnArchive = document.createElement("button");
      btnArchive.className = "btn";
      btnArchive.textContent = "Archive";
      btnArchive.addEventListener("click", async () => {
        try{
          await applyArchiveSelection(true);
        }catch(e){
          toast("bad", "Update failed", e.message || String(e));
        }
      });
      wrap.appendChild(btnArchive);

      if(selected.some(r => !!r.is_archived)){
        const btnUnarchive = document.createElement("button");
        btnUnarchive.className = "btn";
        btnUnarchive.textContent = "Unarchive";
        btnUnarchive.addEventListener("click", async () => {
          try{
            await applyArchiveSelection(false);
          }catch(e){
            toast("bad", "Update failed", e.message || String(e));
          }
        });
        wrap.appendChild(btnUnarchive);
      }
    }

    if(selected.every(r => canDeleteFromRow(activeTab, r))){
      const btnDelete = document.createElement("button");
      btnDelete.className = "btn danger";
      btnDelete.textContent = "Delete";
      btnDelete.addEventListener("click", async () => {
        try{
          await deleteSelectedRows();
        }catch(e){
          toast("bad", "Delete failed", e.message || String(e));
        }
      });
      wrap.appendChild(btnDelete);
    }

    if(activeTab === "payees" && selected.length >= 2){
      const btnMerge = document.createElement("button");
      btnMerge.className = "btn";
      btnMerge.textContent = "Merge";
      btnMerge.addEventListener("click", async () => {
        try{
          await mergeSelectedPayees();
        }catch(e){
          toast("bad", "Merge failed", e.message || String(e));
        }
      });
      wrap.appendChild(btnMerge);
    }
    wrap.classList.add("active");
    syncStickyOffsets();
  }

  function syncStickyOffsets(){
    const topbar = $(".topbar");
    const panelHead = $(".panelHead");
    const stickyTop = topbar ? Math.ceil(topbar.offsetHeight + 12) : 12;
    const headHeight = panelHead ? Math.ceil(panelHead.offsetHeight) : 64;
    document.documentElement.style.setProperty("--sticky-offset", stickyTop + "px");
    document.documentElement.style.setProperty("--panel-head-height", headHeight + "px");
  }

  function serverSortExprForActiveTab(){
    const schema = SCHEMA[activeTab];
    const sortState = tableSortStateForTab(activeTab);
    const column = schema.columns.find(c => c.key === sortState.key) || schema.columns[0];
    if(!isServerSortableColumn(column)) return "";
    const key = column.key || "id";
    return (sortState.direction === "desc" ? "-" : "") + key;
  }

  function updatePagerUI(){
    const paging = tablePagingStateForTab(activeTab);
    const page = Math.max(1, paging.page || 1);
    const totalPages = Math.max(1, paging.totalPages || 1);
    const totalItems = Math.max(0, paging.totalItems || 0);
    $("#pageInfo").textContent = `Page ${page} of ${totalPages} (${totalItems} rows)`;
    $("#perPage").value = String(paging.perPage || 50);
    $("#btnPrevPage").disabled = page <= 1;
    $("#btnNextPage").disabled = page >= totalPages;
  }

  function updatePayeeFilterVisibility(){
    const isPayees = activeTab === "payees";
    $("#payeeCardCategoryFilterWrap").style.display = isPayees ? "" : "none";
    $("#payeeCategoryFilterWrap").style.display = isPayees ? "" : "none";
  }

  function refillPayeeFilterOptions(){
    const cardSelect = $("#payeeCardCategoryFilter");
    const categorySelect = $("#payeeCategoryFilter");
    if(!cardSelect || !categorySelect) return;

    const selectedCard = String(cardSelect.value || "");
    const selectedCategory = String(categorySelect.value || "");

    const payeeCardField = (SCHEMA.payees.fields || []).find((f) => f.key === "card_category");
    const cardOptions = Array.isArray(payeeCardField?.options) ? payeeCardField.options.slice() : [];
    const noneValue = "__none__";
    cardSelect.innerHTML = '<option value="">(all)</option><option value="' + noneValue + '">(none)</option>' + cardOptions.map((opt) => {
      const v = String(opt || "");
      return `<option value="${escapeHtml(v)}">${escapeHtml(v)}</option>`;
    }).join("");
    cardSelect.value = (selectedCard === noneValue || cardOptions.includes(selectedCard)) ? selectedCard : "";

    const categories = Array.from(categoriesIndex.values())
      .slice()
      .sort((a, b) => String(a?.name || "").localeCompare(String(b?.name || ""), undefined, { sensitivity:"base", numeric:true }));
    categorySelect.innerHTML = '<option value="">(all)</option>' + categories.map((cat) => {
      const id = String(cat?.id || "");
      const name = String(cat?.name || id || "");
      const label = cat?.is_archived ? `${name} [archived]` : name;
      return `<option value="${escapeHtml(id)}">${escapeHtml(label)}</option>`;
    }).join("");
    categorySelect.value = categories.some((c) => String(c?.id || "") === selectedCategory) ? selectedCategory : "";
  }

  async function listAllRecords(collection, { q="", showArchived=false, onlyArchived=false, perPage=500, sort="" }={}){
    let page = 1;
    let all = [];
    while(true){
      const data = await listRecords(collection, { q, showArchived, onlyArchived, page, perPage, sort });
      all = all.concat(data.items || []);
      if(page >= data.totalPages) break;
      page += 1;
    }
    return all;
  }

  async function listFilteredPayees({ q="", showArchived=false, onlyArchived=false, page=1, perPage=50, sort="", cardCategory="", categoryId="" }={}){
    const allPayees = await listAllRecords("payees", { q, showArchived, onlyArchived, perPage:500, sort });
    let filtered = allPayees.slice();
    if(cardCategory){
      if(cardCategory === "__none__"){
        filtered = filtered.filter((p) => !String(p?.card_category || "").trim());
      }else{
        filtered = filtered.filter((p) => String(p?.card_category || "") === cardCategory);
      }
    }
    if(categoryId){
      const allowed = payeeIdsByCategory.get(String(categoryId || "")) || new Set();
      filtered = filtered.filter((p) => allowed.has(String(p?.id || "")));
    }

    const safePerPage = Math.max(1, perPage);
    const totalItems = filtered.length;
    const totalPages = Math.max(1, Math.ceil(totalItems / safePerPage));
    const safePage = Math.min(Math.max(1, page), totalPages);
    const start = (safePage - 1) * safePerPage;
    const end = start + safePerPage;
    return {
      items: filtered.slice(start, end),
      page: safePage,
      perPage: safePerPage,
      totalPages,
      totalItems
    };
  }

  function rowSortValue(row, column){
    if(column.render === "parentName"){
      const parentId = row.parent || "";
      return parentId ? (categoriesIndex.get(parentId)?.name || parentId) : "";
    }
    if(column.render === "accountCurrentBalance"){
      const b = accountStats.get(row.id) || { current: 0, cleared: 0, entryCount: 0 };
      return Number(b.current || 0);
    }
    if(column.render === "accountEntryCount"){
      const b = accountStats.get(row.id) || { current: 0, cleared: 0, entryCount: 0 };
      return Number(b.entryCount || 0);
    }
    if(column.render === "accountClearedBalance"){
      const b = accountStats.get(row.id) || { current: 0, cleared: 0, entryCount: 0 };
      return Number(b.cleared || 0);
    }
    if(column.render === "assetEntryCount"){
      return Number(assetEntryCounts.get(row.id) || 0);
    }
    if(column.render === "categoryEntryCount"){
      return Number(categoryEntryCounts.get(row.id) || 0);
    }
    if(column.render === "payeeTxnCount"){
      return Number(payeeTxnCounts.get(row.id) || 0);
    }
    if(column.render === "payeeNewestTxnDate"){
      const raw = payeeNewestTxnDates.get(row.id) || "";
      const d = parseTxnDate(raw);
      return d ? d.getTime() : 0;
    }
    if(column.pillBool){
      return row[column.key] ? 1 : 0;
    }
    return row[column.key];
  }

  function sortedRecordsForTable(schema){
    const sortState = tableSortStateForTab(activeTab);
    const column = schema.columns.find(c => c.key === sortState.key) || schema.columns[0];
    if(!column) return records.slice();
    if(isServerSortableColumn(column)) return records.slice();

    const rows = records.slice();

    rows.sort((a, b) => {
      const av = rowSortValue(a, column);
      const bv = rowSortValue(b, column);
      const cmp = compareSortValues(av, bv, sortState.direction);
      if(cmp !== 0) return cmp;
      return String(a?.id || "").localeCompare(String(b?.id || ""), undefined, { sensitivity:"base", numeric:true });
    });
    return rows;
  }

  function toggleTableSort(columnKey){
    if(!columnKey) return;
    const sortState = tableSortStateForTab(activeTab);
    const paging = tablePagingStateForTab(activeTab);
    if(sortState.key === columnKey){
      sortState.direction = sortState.direction === "asc" ? "desc" : "asc";
    }else{
      sortState.key = columnKey;
      sortState.direction = "asc";
    }
    paging.page = 1;
    refresh();
  }

  function setActiveTab(tab){
    activeTab = tab;
    if(tab !== "payees") showDupModal(false);
    const paging = tablePagingStateForTab(tab);
    paging.page = 1;
    $$(".tab").forEach(b => b.classList.toggle("active", b.dataset.tab === tab));
    $$(".tab").forEach(b => b.setAttribute("aria-selected", String(b.dataset.tab === tab)));
    $("#hint").textContent = `Manage ${SCHEMA[tab].label}: add, edit, delete.`;
    $("#q").value = "";
    $("#showArchived").checked = false;
    $("#onlyArchived").checked = false;
    $("#payeeCardCategoryFilter").value = "";
    $("#payeeCategoryFilter").value = "";
    updatePayeeFilterVisibility();
    selectedSetForTab(activeTab).clear();
    renderBulkActions();
    refresh();
  }

  function renderTable(){
    const schema = SCHEMA[activeTab];
    const sortState = tableSortStateForTab(activeTab);
    if(!schema.columns.some(c => c.key === sortState.key)){
      sortState.key = schema.columns[0] ? schema.columns[0].key : "id";
      sortState.direction = "asc";
    }
    const thead = $("#table thead");
    const tbody = $("#table tbody");
    thead.innerHTML = "";
    tbody.innerHTML = "";

    const trh = document.createElement("tr");
    const thSel = document.createElement("th");
    thSel.className = "selectionCell";
    const allCb = document.createElement("input");
    allCb.type = "checkbox";
    allCb.title = "Select all rows on this page";
    const selectedIds = selectedSetForTab(activeTab);
    const visibleIds = records.map(r => String(r.id || ""));
    const selectedVisible = visibleIds.filter(id => selectedIds.has(id)).length;
    allCb.checked = visibleIds.length > 0 && selectedVisible === visibleIds.length;
    allCb.indeterminate = selectedVisible > 0 && selectedVisible < visibleIds.length;
    allCb.addEventListener("change", () => {
      const checked = allCb.checked;
      if(checked){
        records.forEach(r => selectedIds.add(String(r.id || "")));
      }else{
        records.forEach(r => selectedIds.delete(String(r.id || "")));
      }
      renderTable();
      renderBulkActions();
    });
    thSel.appendChild(allCb);
    trh.appendChild(thSel);

    schema.columns.forEach(c => {
      const th = document.createElement("th");
      th.textContent = c.label;
      th.classList.add("sortable");
      if(c.key === sortState.key){
        th.classList.add(sortState.direction === "asc" ? "sorted-asc" : "sorted-desc");
        th.setAttribute("aria-sort", sortState.direction === "asc" ? "ascending" : "descending");
      }else{
        th.setAttribute("aria-sort", "none");
      }
      th.addEventListener("click", () => toggleTableSort(c.key));
      trh.appendChild(th);
    });
    thead.appendChild(trh);

    $("#empty").style.display = records.length ? "none" : "block";

    const sortedRows = sortedRecordsForTable(schema);
    const selected = selectedSetForTab(activeTab);
    sortedRows.forEach(r => {
      const tr = document.createElement("tr");
      tr.classList.add("selectableRow");
      const rowId = String(r.id || "");
      if(selected.has(rowId)) tr.classList.add("selected");

      const tdSel = document.createElement("td");
      tdSel.className = "selectionCell";
      const rowCb = document.createElement("input");
      rowCb.type = "checkbox";
      rowCb.checked = selected.has(rowId);
      rowCb.addEventListener("click", (e) => e.stopPropagation());
      rowCb.addEventListener("change", () => {
        if(rowCb.checked) selected.add(rowId);
        else selected.delete(rowId);
        renderTable();
        renderBulkActions();
      });
      tdSel.appendChild(rowCb);
      tr.appendChild(tdSel);

      schema.columns.forEach(c => {
        const td = document.createElement("td");
        if(c.render === "parentName"){
          const parentId = r.parent || "";
          td.textContent = parentId ? (categoriesIndex.get(parentId)?.name || parentId) : "";
          if(parentId) td.classList.add("mono");
        } else if(c.render === "accountCurrentBalance"){
          const b = accountStats.get(r.id) || { current: 0, cleared: 0, entryCount: 0 };
          td.textContent = fmtBalance(b.current);
        } else if(c.render === "accountEntryCount"){
          const b = accountStats.get(r.id) || { current: 0, cleared: 0, entryCount: 0 };
          td.textContent = String(b.entryCount);
        } else if(c.render === "accountClearedBalance"){
          const b = accountStats.get(r.id) || { current: 0, cleared: 0, entryCount: 0 };
          td.textContent = fmtBalance(b.cleared);
        } else if(c.render === "assetEntryCount"){
          td.textContent = String(assetEntryCounts.get(r.id) || 0);
        } else if(c.render === "categoryEntryCount"){
          td.textContent = String(categoryEntryCounts.get(r.id) || 0);
        } else if(c.render === "payeeTxnCount"){
          td.textContent = String(payeeTxnCounts.get(r.id) || 0);
        } else if(c.render === "payeeNewestTxnDate"){
          const raw = payeeNewestTxnDates.get(r.id) || "";
          td.textContent = raw ? fmtTxnDate(raw) : "";
        } else if(c.pillBool){
          const v = !!r[c.key];
          const span = document.createElement("span");
          span.className = "pill " + (v ? "warn" : "ok");
          span.textContent = v ? "Yes" : "No";
          td.appendChild(span);
        } else if(c.pill){
          const span = document.createElement("span");
          span.className = "pill";
          span.textContent = r[c.key] ?? "";
          td.appendChild(span);
        } else {
          const v = r[c.key];
          td.textContent = v == null ? "" : String(v);
          if(c.mono) td.classList.add("mono");
        }
        tr.appendChild(td);
      });
      tr.addEventListener("click", (e) => {
        if(e.target && e.target.closest && e.target.closest("button,a,input,select,textarea,label")) return;
        if(selected.has(rowId)) selected.delete(rowId);
        else selected.add(rowId);
        renderTable();
        renderBulkActions();
      });
      tbody.appendChild(tr);
    });
    updatePagerUI();
  }

  function buildField(field, data, opts={}){
    const bulkMixed = !!opts.bulkMixed;
    const bulkLocked = !!opts.bulkLocked;
    const colSpan = (field.type === "json") ? "col-12" : (field.type === "relation") ? "col-6" : "col-6";
    const box = document.createElement("div");
    box.className = colSpan + " field";

    const label = document.createElement("label");
    const requiredSuffix = field.required ? " *" : "";
    if(bulkLocked){
      label.textContent = `${field.label}${requiredSuffix} (locked)`;
      label.classList.add("bulkLockedLabel");
    }else if(bulkMixed){
      label.textContent = `${field.label}${requiredSuffix} (multiple)`;
      label.classList.add("bulkMixedLabel");
    }else{
      label.textContent = field.label + requiredSuffix;
    }
    label.htmlFor = "f_" + field.key;
    box.appendChild(label);

    const mixedToken = "__bulk_multiple__";
    let input;

    if(field.type === "select"){
      input = document.createElement("select");
      input.id = "f_" + field.key;
      const isNew = editing.mode === "new";
      if(bulkMixed){
        const mixedOpt = document.createElement("option");
        mixedOpt.value = mixedToken;
        mixedOpt.textContent = "(multiple)";
        input.appendChild(mixedOpt);
      }
      if(!field.required){
        const noneOpt = document.createElement("option");
        noneOpt.value = "";
        noneOpt.textContent = "(none)";
        input.appendChild(noneOpt);
      } else if(isNew){
        const selectOpt = document.createElement("option");
        selectOpt.value = "";
        selectOpt.textContent = "Select...";
        input.appendChild(selectOpt);
      }
      field.options.forEach(v => {
        const opt = document.createElement("option");
        opt.value = v;
        opt.textContent = v;
        input.appendChild(opt);
      });
      const baseValue = (data[field.key] == null) ? "" : String(data[field.key]);
      input.value = bulkMixed ? mixedToken : baseValue;
      if(bulkMixed){
        input.classList.add("bulkMixedControl");
        input.addEventListener("change", () => {
          if(input.value !== mixedToken){
            editing.mixedKeys.delete(field.key);
            input.classList.remove("bulkMixedControl");
            label.textContent = field.label + requiredSuffix;
            label.classList.remove("bulkMixedLabel");
          }
        });
      }
    } else if(field.type === "bool"){
      const row = document.createElement("label");
      row.className = "toggle";
      row.style.color = "var(--text)";
      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.id = "f_" + field.key;
      cb.checked = !!data[field.key];
      if(bulkMixed){
        cb.indeterminate = true;
        cb.classList.add("bulkMixedControl");
        cb.addEventListener("change", () => {
          editing.mixedKeys.delete(field.key);
          cb.indeterminate = false;
          cb.classList.remove("bulkMixedControl");
        });
      }
      if(bulkLocked){
        cb.disabled = true;
      }
      row.appendChild(cb);
      const t = document.createElement("span");
      if(bulkLocked){
        t.textContent = `${field.label} (locked)`;
      }else if(bulkMixed){
        t.textContent = `${field.label} (multiple)`;
      }else{
        t.textContent = field.label;
      }
      row.appendChild(t);
      box.innerHTML = "";
      box.appendChild(row);
      return box;
    } else if(field.type === "number"){
      input = document.createElement("input");
      input.id = "f_" + field.key;
      input.type = "text";
      input.placeholder = bulkMixed ? "(multiple)" : (field.placeholder || "");
      input.value = (bulkMixed || data[field.key] == null) ? "" : String(data[field.key]);
      input.inputMode = "decimal";
      if(bulkMixed){
        input.classList.add("bulkMixedControl");
        input.addEventListener("input", () => {
          editing.mixedKeys.delete(field.key);
          input.classList.remove("bulkMixedControl");
          label.textContent = field.label + requiredSuffix;
          label.classList.remove("bulkMixedLabel");
        });
      }
    } else if(field.type === "json"){
      input = document.createElement("textarea");
      input.id = "f_" + field.key;
      input.placeholder = bulkMixed ? "(multiple)" : (field.placeholder || "");
      input.value = (bulkMixed || data[field.key] == null) ? "" : JSON.stringify(data[field.key], null, 2);
      if(bulkMixed){
        input.classList.add("bulkMixedControl");
        input.addEventListener("input", () => {
          editing.mixedKeys.delete(field.key);
          input.classList.remove("bulkMixedControl");
          label.textContent = field.label + requiredSuffix;
          label.classList.remove("bulkMixedLabel");
        });
      }
    } else if(field.type === "relation"){
      input = document.createElement("select");
      input.id = "f_" + field.key;
      if(bulkMixed){
        const mixedOpt = document.createElement("option");
        mixedOpt.value = mixedToken;
        mixedOpt.textContent = "(multiple)";
        input.appendChild(mixedOpt);
      }

      const opt0 = document.createElement("option");
      opt0.value = "";
      opt0.textContent = "(none)";
      input.appendChild(opt0);

      const items = Array.from(categoriesIndex.values()).sort((a,b) => (a.name||"").localeCompare(b.name||""));
      items.forEach(cat => {
        const opt = document.createElement("option");
        opt.value = cat.id;
        opt.textContent = `${cat.name}  —  ${cat.kind}`;
        input.appendChild(opt);
      });
      input.value = bulkMixed ? mixedToken : (data[field.key] ?? "");
      if(bulkMixed){
        input.classList.add("bulkMixedControl");
        input.addEventListener("change", () => {
          if(input.value !== mixedToken){
            editing.mixedKeys.delete(field.key);
            input.classList.remove("bulkMixedControl");
            label.textContent = field.label + requiredSuffix;
            label.classList.remove("bulkMixedLabel");
          }
        });
      }
    } else {
      input = document.createElement("input");
      input.id = "f_" + field.key;
      input.type = "text";
      input.placeholder = bulkMixed ? "(multiple)" : (field.placeholder || "");
      input.value = bulkMixed ? "" : (data[field.key] ?? "");
      if(bulkMixed){
        input.classList.add("bulkMixedControl");
        input.addEventListener("input", () => {
          editing.mixedKeys.delete(field.key);
          input.classList.remove("bulkMixedControl");
          label.textContent = field.label + requiredSuffix;
          label.classList.remove("bulkMixedLabel");
        });
      }
    }

    if(bulkLocked){
      input.disabled = true;
      input.classList.add("bulkLockedControl");
    }
    box.appendChild(input);
    return box;
  }

  function openEditor(mode, record){
    const schema = SCHEMA[activeTab];
    editing.mode = mode;
    editing.id = mode === "edit" ? record.id : null;
    editing.ids = [];
    editing.data = mode === "edit" ? record : {};
    editing.mixedKeys = new Set();
    editing.lockedKeys = new Set();

    $("#modalTitle").textContent = (mode === "edit" ? "Edit " : "New ") + schema.label.slice(0,-1);
    $("#recordMeta").textContent = mode === "edit"
      ? `created=${fmtDate(record.created)}  updated=${fmtDate(record.updated)}`
      : "";

    const grid = $("#formGrid");
    grid.innerHTML = "";
    schema.fields.forEach(f => grid.appendChild(buildField(f, editing.data)));

    $("#formHelp").textContent = schema.help;

    showModal(true);
  }

  function showModal(on){
    $("#modalBackdrop").classList.toggle("show", !!on);
    $("#modalBackdrop").setAttribute("aria-hidden", String(!on));
    if(on){
      setTimeout(() => {
        const first = $("#formGrid input, #formGrid select, #formGrid textarea");
        if(first) first.focus();
      }, 0);
    }
  }

  function readEditorBody(){
    const schema = SCHEMA[activeTab];
    const isBulk = editing.mode === "bulk";
    const isNew = editing.mode === "new";
    const mixedToken = "__bulk_multiple__";
    const out = {};
    for(const f of schema.fields){
      if(isBulk && editing.lockedKeys.has(f.key)) continue;
      if(isBulk && editing.mixedKeys.has(f.key)) continue;

      const id = "#f_" + f.key;
      if(f.type === "bool"){
        const cb = $(id);
        if(!cb) continue;
        if(isBulk && cb.indeterminate) continue;
        out[f.key] = cb.checked;
        continue;
      }
      const el = $(id);
      if(!el) continue;
      if(isBulk && (el.value || "") === mixedToken) continue;
      const raw = (el?.value ?? "").trim();

      if(f.type === "select"){
        out[f.key] = raw || null;
      } else if(f.type === "number"){
        if(raw === "") out[f.key] = null;
        else {
          const n = Number(raw);
          if(!Number.isFinite(n)) throw new Error(`${f.label} must be a valid number.`);
          out[f.key] = n;
        }
      } else if(f.type === "json"){
        const parsed = safeJsonParse(raw);
        if(!parsed.ok) throw new Error(`${f.label}: ${parsed.error}`);
        out[f.key] = parsed.value;
      } else if(f.type === "relation"){
        out[f.key] = raw || null;
      } else {
        let v = raw;
        if(f.transform === "upper") v = v.toUpperCase();
        out[f.key] = v || null;
      }

      if(f.required && (!isBulk || Object.prototype.hasOwnProperty.call(out, f.key))){
        const v = out[f.key];
        if(v === null || v === "" || v === undefined){
          throw new Error(`${f.label} is required.`);
        }
      }
    }

    if("meta" in out && out.meta === null) delete out.meta;
    if(isNew && activeTab === "categories" && out.parent === null) delete out.parent;
    if(isNew){
      ["institution","name","symbol","card_category"].forEach((k) => {
        if(out[k] === null) delete out[k];
      });
    }

    return out;
  }

  async function refresh(){
    try{
      $("#btnRefresh").disabled = true;
      $("#btnNew").disabled = true;
      $("#btnPrevPage").disabled = true;
      $("#btnNextPage").disabled = true;
      $("#perPage").disabled = true;
      accountStats = new Map();
      assetEntryCounts = new Map();
      categoryEntryCounts = new Map();
      payeeTxnCounts = new Map();
      payeeNewestTxnDates = new Map();
      payeeIdsByCategory = new Map();

      const catsAllRes = await listRecords("categories", { q:"", showArchived:true, onlyArchived:false, page:1, perPage:500 });
      categoriesIndex = new Map((catsAllRes.items || []).map(c => [c.id, c]));
      refillPayeeFilterOptions();

      const q = $("#q").value;
      const showArchived = $("#showArchived").checked;
      const onlyArchived = $("#onlyArchived").checked;
      const payeeCardCategory = activeTab === "payees" ? String($("#payeeCardCategoryFilter").value || "") : "";
      const payeeCategoryId = activeTab === "payees" ? String($("#payeeCategoryFilter").value || "") : "";
      if(onlyArchived) $("#showArchived").checked = true;

      const stats = await computeEntryStats();
      accountStats = stats.accountMap;
      assetEntryCounts = stats.assetMap;
      categoryEntryCounts = stats.categoryMap;
      payeeTxnCounts = stats.payeeMap;
      payeeNewestTxnDates = stats.payeeNewestTxnDateMap || new Map();
      payeeIdsByCategory = stats.payeeIdsByCategoryMap || new Map();

      const paging = tablePagingStateForTab(activeTab);
      let listRes;
      if(activeTab === "payees" && (payeeCardCategory || payeeCategoryId)){
        listRes = await listFilteredPayees({
          q,
          showArchived,
          onlyArchived,
          page: paging.page,
          perPage: paging.perPage,
          sort: serverSortExprForActiveTab(),
          cardCategory: payeeCardCategory,
          categoryId: payeeCategoryId
        });
      }else{
        listRes = await listRecords(activeTab, {
          q,
          showArchived,
          onlyArchived,
          page: paging.page,
          perPage: paging.perPage,
          sort: serverSortExprForActiveTab()
        });
        if(paging.page > listRes.totalPages){
          paging.page = listRes.totalPages;
          listRes = await listRecords(activeTab, {
            q,
            showArchived,
            onlyArchived,
            page: paging.page,
            perPage: paging.perPage,
            sort: serverSortExprForActiveTab()
          });
        }
      }
      paging.page = listRes.page;
      paging.totalPages = listRes.totalPages;
      paging.totalItems = listRes.totalItems;
      records = listRes.items || [];
      pruneSelectionToVisibleRows();
      renderTable();
      renderBulkActions();
      updatePagerUI();
    }catch(e){
      records = [];
      selectedSetForTab(activeTab).clear();
      renderTable();
      renderBulkActions();
      updatePagerUI();
      toast("bad", "Refresh failed", e.message || String(e));
    }finally{
      $("#btnRefresh").disabled = false;
      $("#btnNew").disabled = false;
      $("#btnPrevPage").disabled = false;
      $("#btnNextPage").disabled = false;
      $("#perPage").disabled = false;
      updatePagerUI();
    }
  }

  $$(".tab").forEach(b => b.addEventListener("click", () => setActiveTab(b.dataset.tab)));

  $("#btnRefresh").addEventListener("click", refresh);
  $("#btnNew").addEventListener("click", () => openEditor("new", {}));

  $("#q").addEventListener("keydown", (e) => {
    if(e.key === "Enter"){
      tablePagingStateForTab(activeTab).page = 1;
      refresh();
    }
  });
  $("#showArchived").addEventListener("change", () => {
    if(!$("#showArchived").checked) $("#onlyArchived").checked = false;
    tablePagingStateForTab(activeTab).page = 1;
    refresh();
  });
  $("#onlyArchived").addEventListener("change", () => {
    if($("#onlyArchived").checked) $("#showArchived").checked = true;
    tablePagingStateForTab(activeTab).page = 1;
    refresh();
  });
  $("#payeeCardCategoryFilter").addEventListener("change", () => {
    tablePagingStateForTab(activeTab).page = 1;
    refresh();
  });
  $("#payeeCategoryFilter").addEventListener("change", () => {
    tablePagingStateForTab(activeTab).page = 1;
    refresh();
  });
  $("#btnPrevPage").addEventListener("click", () => {
    const paging = tablePagingStateForTab(activeTab);
    if(paging.page <= 1) return;
    paging.page -= 1;
    refresh();
  });
  $("#btnNextPage").addEventListener("click", () => {
    const paging = tablePagingStateForTab(activeTab);
    if(paging.page >= paging.totalPages) return;
    paging.page += 1;
    refresh();
  });
  $("#perPage").addEventListener("change", () => {
    const paging = tablePagingStateForTab(activeTab);
    const v = Number($("#perPage").value);
    if(!Number.isFinite(v) || v < 1) return;
    paging.perPage = v;
    paging.page = 1;
    refresh();
  });

  $("#btnClose").addEventListener("click", () => showModal(false));
  $("#btnCancel").addEventListener("click", () => showModal(false));
  $("#btnDupClose").addEventListener("click", () => showDupModal(false));
  $("#btnDupDone").addEventListener("click", () => showDupModal(false));
  $("#btnDupRefresh").addEventListener("click", async () => {
    try{
      await runPayeeDuplicateDetection(true);
    }catch(e){
      toast("bad", "Duplicate scan failed", e?.message || String(e));
    }
  });
  $("#modalBackdrop").addEventListener("click", (e) => { if(e.target === $("#modalBackdrop")) showModal(false); });
  $("#dupModalBackdrop").addEventListener("click", (e) => { if(e.target === $("#dupModalBackdrop")) showDupModal(false); });
  window.addEventListener("keydown", (e) => {
    if(e.key !== "Escape") return;
    if($("#modalBackdrop").classList.contains("show")) showModal(false);
    if($("#dupModalBackdrop").classList.contains("show")) showDupModal(false);
  });

  $("#btnSave").addEventListener("click", async () => {
    const schema = SCHEMA[activeTab];
    try{
      $("#btnSave").disabled = true;
      const body = readEditorBody();

      if(editing.mode === "new"){
        await createRecord(activeTab, body);
        toast("ok", "Created", `${schema.label.slice(0,-1)} created.`);
      } else if(editing.mode === "bulk"){
        const ids = Array.isArray(editing.ids) ? editing.ids.slice() : [];
        if(!ids.length){
          throw new Error("No selected rows found for bulk edit.");
        }
        if(!Object.keys(body).length){
          throw new Error("No bulk changes to apply. Set at least one field.");
        }
        let done = 0;
        let failed = 0;
        let firstErr = "";
        for(const id of ids){
          try{
            await updateRecord(activeTab, id, body);
            done += 1;
          }catch(e){
            failed += 1;
            if(!firstErr) firstErr = e?.message || String(e);
          }
        }
        if(failed){
          toast("bad", "Bulk edit partial", `Updated ${done} row(s), failed ${failed}.` + (firstErr ? ` First error: ${firstErr}` : ""));
        }else{
          toast("ok", "Bulk updated", `Updated ${done} ${schema.label.toLowerCase()}.`);
        }
      } else {
        await updateRecord(activeTab, editing.id, body);
        toast("ok", "Saved", `${schema.label.slice(0,-1)} updated.`);
      }

      showModal(false);
      refresh();
    }catch(e){
      toast("bad", "Save failed", e.message || String(e));
    }finally{
      $("#btnSave").disabled = false;
    }
  });

  async function pbAuthWithPassword(email, password){
    // Hard-coded auth collection: users
    const body = JSON.stringify({ identity: email, password });
    return pbFetch(`/api/collections/${encodeURIComponent("users")}/auth-with-password`, { method:"POST", body });
  }

  async function pbAuthRefresh(){
    // Validates current token and (usually) returns a refreshed token
    return pbFetch(`/api/collections/${encodeURIComponent("users")}/auth-refresh`, { method:"POST" });
  }

  function setLoggedInUI(isLoggedIn){
    const authPanel = $("#authPanel");
    const logout = $("#logoutLink");
    if(authPanel) authPanel.style.display = isLoggedIn ? "none" : "flex";
    if(logout) logout.style.display = isLoggedIn ? "inline" : "none";
    syncStickyOffsets();
  }

  async function validateCachedSession(){
    if(!SESSION.base || !SESSION.token) return false;
    try{
      const res = await pbAuthRefresh();
      if(res?.token){
        SESSION.token = res.token;
        store.set("pbToken", res.token);
      }
      return true;
    }catch{
      return false;
    }
  }

  $("#logoutLink").addEventListener("click", (e) => {
    e.preventDefault();
    SESSION.base = "";
    SESSION.token = "";
    store.del("pbUrl");
    store.del("pbEmail");
    store.del("pbToken");
    $("#pbUrl").value = "";
    $("#pbEmail").value = "";
    $("#pbPass").value = "";
    setLoggedInUI(false);
    showDupModal(false);
    records = [];
    selectedSetForTab(activeTab).clear();
    tablePagingStateForTab(activeTab).page = 1;
    tablePagingStateForTab(activeTab).totalPages = 1;
    tablePagingStateForTab(activeTab).totalItems = 0;
    $("#payeeCardCategoryFilter").value = "";
    $("#payeeCategoryFilter").value = "";
    updatePayeeFilterVisibility();
    renderTable();
    renderBulkActions();
    updatePagerUI();
    toast("ok", "Logged out", "Local session cleared.");
  });

  $("#btnLogin").addEventListener("click", async () => {
    const base = $("#pbUrl").value.trim().replace(/\/+$/, "");
    const email = $("#pbEmail").value.trim();
    const password = $("#pbPass").value;

    if(!base){
      toast("bad", "Login", "Enter URL.");
      return;
    }
    if(!email || !password){
      toast("bad", "Login", "Enter email and password.");
      return;
    }

    // persist URL + email for convenience
    store.set("pbUrl", base);
    store.set("pbEmail", email);

    try{
      $("#btnLogin").disabled = true;
      SESSION.base = base;
      SESSION.token = "";

      const res = await pbAuthWithPassword(email, password);
      const token = res?.token;
      if(!token) throw new Error("No token returned by PocketBase.");

      SESSION.token = token;
      store.set("pbToken", token);

      setLoggedInUI(true);
      toast("ok", "Login succeeded", "Session saved.");
      refresh();
    }catch(e){
      SESSION.token = "";
      store.del("pbToken");
      setLoggedInUI(false);
      toast("bad", "Login failed", e.message || String(e));
    }finally{
      $("#btnLogin").disabled = false;
      // Do not persist password
      $("#pbPass").value = "";
    }
  });

  // Prefill from localStorage
  $("#pbUrl").value = store.get("pbUrl", "");
  $("#pbEmail").value = store.get("pbEmail", "");
  updatePayeeFilterVisibility();
  updatePagerUI();
  syncStickyOffsets();
  window.addEventListener("resize", syncStickyOffsets);

  // On load: if URL + token exist, validate them; if valid hide login; else show login
  (async () => {
    SESSION.base = ($("#pbUrl").value || "").trim().replace(/\/+$/, "");
    SESSION.token = (store.get("pbToken", "") || "").trim();

    if(SESSION.base && SESSION.token){
      const ok = await validateCachedSession();
      if(ok){
        setLoggedInUI(true);
        refresh();
        return;
      }
      // token invalid
      SESSION.token = "";
      store.del("pbToken");
    }

    setLoggedInUI(false);
    records = [];
    renderTable();
    renderBulkActions();
    syncStickyOffsets();
    updatePagerUI();
    toast("bad", "Not logged in", "Enter URL, email, password and click Login.");
  })();
})();
</script>
</body>
</html>
